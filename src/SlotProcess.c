/*************************************************************************************************************************************************
**                                                                                                                                              **
** Copyright (C) SAIC Technologies (2020)                                                                                                       **
**                                                                                                                                              **
** All rights reserved.                                                                                                                         **
**                                                                                                                                              **
** This document contains proprietary information belonging to SAIC                                                                             **
** Technologies. Passing on and copying of this document, and communication                                                                     **
** of its contents is not permitted without prior written authorization.                                                                        **
**                                                                                                                                              **
**************************************************************************************************************************************************
**                                                                                                                                              **
**  $FILENAME   : APASlotProcess.c $                                                                                                            **
**                                                                                                                                              **
**  $CC VERSION : \main\94 $                                                                                                                    **
**                                                                                                                                              **
**  $DATE       : 2020-08-18                                                                                                                    **
**                                                                                                                                              **
**  AUTHOR      : SAIC - US Group -Engineering                                                                                                  **
**                                                                                                                                              **
**  VENDOR      : SAIC Technologies                                                                                                             **
**                                                                                                                                              **
**  DESCRIPTION : This file contains                                                                                                            **
**                - USS slot process main function                          ..                                                                  **
**                                                                                                                                              **
**  MAY BE CHANGED BY USER [yes/no]: Yes                                                                                                        **
**                                                                                                                                              **
*************************************************************************************************************************************************/
/*************************************************************************************************************************************************
 **                                                     Includes
 *************************************************************************************************************************************************/
#include "SlotProcess.h"
#include "SlotProcessSubFunction.h"
#include "USS.h"
#include "USSSubFunction.h"
#include "APACommonFunctions.h"
#include "APACalibration.h"
#include "Stm.h"
#include <stdio.h>

/*************************************************************************************************************************************************
 **                                                     Global Constant Definitions                                                              **
 *************************************************************************************************************************************************/

/*************************************************************************************************************************************************
 **                                                     Global Variable Definitions                                                              **
 *************************************************************************************************************************************************/
#define ALG_START_SEC_VAR_32BIT
#include "IS31_UserMemMap.h"

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER
#define APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS 500
uchar APASlotPcDebugSnsDtFilterDebug1;
#endif


uint8 u8USS_CutSteps = 5;/* wsc 20200721: split task to 2 steps to run*/
SINT16 APASideSnsDtObjDisBuf[PA_SYS_NUM][2][25];
uint32 Task_LoopDoWhileExeTimeTest[2][4]    = {0};
APACarCoordinateDataCalFloatType CarCenterPtBackUp;
UCHAR SlotIndexToDebug = 0; // ���������Ҳ�����,Debug_SW_ExeTimeTest��Debug_SW_COUNTLOOP�����õ�
uint16 iscurb_cnt[5][2] = {0}; /*iscurb_cnt[i][0]: current frame cnt;iscurb_cnt[i][1]: max cnt during the process*/
uint16 DebugMaxCnt = 15; // Largeenough��IsCurbDetect���ִ�д���
uint16 DebugDoWhileCnt[2][2] = {0}; // Do=whileѭ��������0/2����1/2��do-whileѭ��ʵʱ������1/3����1/2��do-while������
uint16 DebugLoopICnt[2][2] = {0}; // iѭ������
uint16 DebugLoopKCnt[2][2] = {0}; // kѭ������
uint8 DebugDoWhile = 3; // 0x00:2��do-while��������;0x01:ֻ���е�һ��do-while;0x02:ֻ���еڶ���do-while;0x03:����2��do-while
uint8 DebugRecheckCurb = 1; // 0: ע��RecheckCurb��1������RecheckCurb
uint8 DebugIsCurbDetected = 1; // 0: ע��IsCurbDetected��1������IsCurbDetected
uint8 DebugLargeEnough = 1; // 0: ע��LargeEnough��1������LargeEnough
uint8 DebugSaveSlot = 1; // 0: ע��SaveSlot��1������SaveSlot
APA_INDEX_TYPE SlotStartIndexBk = -1;
APA_INDEX_TYPE SlotEndIndexBk = -1;
uint8 IsCurbDetectMaxCnt[6] = {0};

#define ALG_STOP_SEC_VAR_32BIT
#include "IS31_UserMemMap.h"

//#define APA_SLOT_SUPPORT_DEBUG2

#define ALG_START_SEC_VAR_32BIT
#include "IS31_UserMemMap.h"

APASlotSnsDtdObjPtBufType APASnsDtdObjPtBuf[APA_SIDE_SENSOR_NUM];

#ifdef APA_SLOT_SUPPORT_DEBUG2
uchar cSlotDebug2;
#endif

#ifdef APA_PARKPROC_DRIVE_DIRECTION_DEBUG
APA_DISTANCE_TYPE APASlotProcFrontSnsDtMinDisDebug;
APA_DISTANCE_TYPE APASlotProcRearSnsDtMinDisDebug;
#endif

#ifdef APA_SLOT_SUPPORT_DEBUG1
uchar cSlotDebug;
#endif



tAPASlotCorrectionFlagType APASlotCorrectionFlag;                       // 64bit
tAPASlotCorrectionIndicationFlagType APASlotCorrectionIndicationFlag;   // 8bit
tAPACarInSlotCarMayHitObj1Or2FlagType APACarInSlotCarMayHitObj1Or2Flag; // 8bit
tDtObjUPASnsDtObjDisInfoType DtObjUPASnsDtObjDisInfo[PA_SYS_NUM];       // 16bit
tDtObjSnsDtObjNearestDisInfoType SnsDtObjNearestDisInfo[PA_SYS_NUM];    // 32bit

APA_MS_TIME_TYPE APASlotCorrectionTimer; // 16bit
APA_MS_TIME_TYPE APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[PA_SYS_NUM];
APA_MS_TIME_TYPE APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[PA_SYS_NUM];

APA_ENUM_TYPE APASlotVehicleStaticTimer;                     // Used to update the objpt when the vehicle is static.
APA_ENUM_TYPE APASlotPObj2NotExistObj1BorderLineFitSequence; // Used to dtm if a compensate ang (3deg) should be added.
APA_ENUM_TYPE APASlotPObj1Obj2CorSequence;
APA_ENUM_TYPE APASlotPObj2XCorSequenceWithNoObj2Exist;
APA_ENUM_TYPE APASlotPObjExistCheckSequence;
APA_ENUM_TYPE APASlotPSlotBorderLineFitSequence;
APA_ENUM_TYPE APASlotPSlotBorderLineFitConvexShapeCheckSequence;
APA_ENUM_TYPE APASlotPSlotCorEndPosYCalMethod;
APA_ENUM_TYPE APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[PA_SYS_NUM];
APA_ENUM_TYPE APASlotCorrectionObj12ExistCheckFlag[PA_SYS_NUM]; // bit 0: Obj1NotDtdWhenVehicleIsStatic, bit 1: Obj1CorrectedWhenVehicleIsStatic
APA_ENUM_TYPE APASlotDetectState;
APA_ENUM_TYPE APASlotSnsDtdObjLoopCnt;

// UCHAR APASlotParkProcReqSlotBorderLineCorrectSeq;
UCHAR bParkOutCarWithinPerependicularSlot; // For DX7 Parking Out

APA_DISTANCE_TYPE APASlotCorrectionOriginalObj1Y;
APA_DISTANCE_TYPE APASlotCorrectionOriginalObj2Y;
APA_DISTANCE_TYPE APASlotPObj2CorAtTurnAroundObj2WithCarMayHitObj2SnsDtDis;
APA_DISTANCE_TYPE APASlotCorrectionObj12CarCornerMinY[PA_SYS_NUM];
APA_DISTANCE_TYPE APASlotCorrectionObj12CarCornerMaxY[PA_SYS_NUM];

//    APA_ENUM_TYPE  APASlotDetectState;
UCHAR SDGChimeCmd;
SDG_DISTANCE_TYPE SDGKeepObjPtDis;
SDG_DISTANCE_TYPE SDGKeepObjPtMinDeltaDtdDis;
SDG_DISTANCE_TYPE SDGSamplePointUpdateLongDeltaLen;
SDG_DISTANCE_TYPE SDGSamplePointCanBeRemovedMaxObjDis;

#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
#define APA_SLOT_PROC_SLOT_CORRECTION_CALED_CAR_END_POS_NUM 1000
#define APA_SLOT_PROC_SLOT_CORRECTION_CALED_CAR_END_POS_LINE_NUM 1000
APACoordinateDataCalFloatType APASlotCorrectionCaledObj1Pt[APA_SLOT_PROC_SLOT_CORRECTION_CALED_CAR_END_POS_NUM];
APACoordinateDataCalFloatType APASlotCorrectionCaledObj2Pt[APA_SLOT_PROC_SLOT_CORRECTION_CALED_CAR_END_POS_NUM];
APACarCoordinateDataCalFloatType APASlotCorrectionCaledCarEndPos[APA_SLOT_PROC_SLOT_CORRECTION_CALED_CAR_END_POS_NUM];
APALineParameterABCType APASlotCorrectionCaledCarEndPosLine[APA_SLOT_PROC_SLOT_CORRECTION_CALED_CAR_END_POS_LINE_NUM];
SINT16 APASlotCorrectionCaledCarEndPosIndex;
SINT16 APASlotCorrectionCaledCarEndPosLineIndex;
#endif

#define ALG_STOP_SEC_VAR_32BIT
#include "IS31_UserMemMap.h"

#define ALG_START_SEC_VAR_32BIT
#include "IS31_UserMemMap.h"

SINT16 APASideSnsDtObjDis[PA_SYS_NUM][2];
APA_DISTANCE_TYPE APASlotPrevCarPosXForObj1Obj2Cor;
APA_ANGLE_TYPE APASlotPrevCarAngForEndPosCarAngCor;
BOOLEAN bAPASlotPrevCarDrvDirForEndPosCarAngCor1;
APA_ENUM_TYPE APASlotCarDrvFwBkCntForEndPosCarAngCor;

//#define APA_SLOT_PROC_DEBUG_SLOT_PT_REMOVE
#ifdef APA_SLOT_PROC_DEBUG_SLOT_PT_REMOVE
#define APA_SLOT_PROC_SLOT_PT_REMOVE_PT_NUM 50
APA_DISTANCE_TYPE APASlotPTRemovedDis[APA_SLOT_PROC_SLOT_PT_REMOVE_PT_NUM];
APA_INDEX_TYPE APASlotPTRemovedDisIndex;
#endif

#define ALG_STOP_SEC_VAR_32BIT
#include "IS31_UserMemMap.h"

#define ALG_START_SEC_VAR_32BIT
#include "IS31_UserMemMap.h"

#ifdef TTE_DEBUG_FRAME_TX_EN
#define APA_SLOT_OBJ2_COMPENSATE_DIS_DEBUG
#endif

#ifdef APA_SLOT_OBJ2_COMPENSATE_DIS_DEBUG
APA_DISTANCE_TYPE APASlotObj2CompensateDisCalDeltaObjDisDebug;
APA_SLOT_PT_SLOPE_TYPE APASlotPTSlopeDebug;
#endif

#define ALG_STOP_SEC_VAR_32BIT
#include "IS31_UserMemMap.h"

/*************************************************************************************************************************************************
 **                                                     Private Function Definitions                                                             **
 *************************************************************************************************************************************************/
#define ALG_START_SEC_CODE
#include "IS31_UserMemMap.h"
void APASlotProcSlotFoundSaveSlot(APA_ENUM_TYPE SlotType,
                                  APA_DISTANCE_TYPE SlotCalDisCarToObj1, // APASlotCoordinateDataType Pt1,
                                  APA_DISTANCE_TYPE SlotCalDisCarToObj2, // APASlotCoordinateDataType Pt2,
                                  APA_ENUM_TYPE SlotStartPtIndex,
                                  APA_ENUM_TYPE SlotEndPtIndex,
                                  APA_ENUM_TYPE StartIndex,
                                  APA_DISTANCE_TYPE DisCarToObj1ByPassingSlot,
                                  APA_DISTANCE_TYPE DisCarToObj2ByPassingSlot,
                                  APA_DISTANCE_TYPE SlotDepth,
                                  APA_DISTANCE_TYPE SlotLenTotal,
                                  APA_DISTANCE_TYPE APASlotDetectionCompensateLengthHead,
                                  APA_DISTANCE_TYPE APASlotDetectionCompensateLengthTail,
                                  UCHAR CurrentSlotIndex,
                                  APA_DISTANCE_TYPE SlotDepthDetected1,
                                  APA_DISTANCE_TYPE SlotDepthDetected2,
                                  APA_DISTANCE_TYPE SlotDepthDetected3,
                                  APA_DISTANCE_TYPE SlotLenDetected1,
                                  APA_DISTANCE_TYPE SlotLenDetected2,
                                  APA_DISTANCE_TYPE SlotLenDetected3,
                                  BOOLEAN bSameSlotFound,
                                  APA_ENUM_TYPE Obj1Type,
                                  APA_ENUM_TYPE Obj2Type,
                                  APA_ENUM_TYPE Obj1StartIndex,
                                  APA_ENUM_TYPE Obj1EndIndex,
                                  APA_ENUM_TYPE Obj2StartIndex,
                                  APA_ENUM_TYPE Obj2EndIndex,
                                  APA_DISTANCE_TYPE Obj1Width,
                                  APA_DISTANCE_TYPE Obj2Width

);//xsj 20210305 for so
/*************************************************************************************************************************************************
 ** Syntax :  void USS(void)                                                                                                                     **
 **                                                                                                                                              **
 ** Service ID:   : NO.1.1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

void APASlotProcResetSlotInfo(UCHAR ClearSlotParIndex) {
  uchar i, j;

  if (ClearSlotParIndex < APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM) {
    j = ClearSlotParIndex;
  } else {
    j = 0;
  }
  for (; j < APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM; j++) {
    for (i = 0; i < APA_SLOT_SUPPORT_MAX_SLOT_NUM; i++) {
      USSPar.Slot[j].SlotPar[i].SlotType                                         = APA_SLOT_TYPE_INVALID;
      USSPar.Slot[j].SlotPar[i].SlotStartIndex                                   = 0;
      USSPar.Slot[j].SlotPar[i].SlotEndIndex                                     = 0;
      USSPar.Slot[j].SlotPar[i].SlotLengthDetected1                              = APA_SLOT_NO_SLOT_DETECTED;
      USSPar.Slot[j].SlotPar[i].SlotLengthDetected2                              = APA_SLOT_NO_SLOT_DETECTED;
      USSPar.Slot[j].SlotPar[i].SlotLengthDetected3                              = APA_SLOT_NO_SLOT_DETECTED;
      USSPar.Slot[j].SlotPar[i].SlotLengthTotal                                  = APA_SLOT_NO_SLOT_DETECTED;
      USSPar.Slot[j].SlotPar[i].SlotLength                                       = APA_SLOT_NO_SLOT_DETECTED;
      USSPar.Slot[j].SlotPar[i].SlotDepthDetected1                               = NO_OBJ_DISTANCE;
      USSPar.Slot[j].SlotPar[i].SlotDepthDetected2                               = NO_OBJ_DISTANCE;
      USSPar.Slot[j].SlotPar[i].SlotDepthDetected3                               = NO_OBJ_DISTANCE;
      USSPar.Slot[j].SlotPar[i].SlotDepthParallel                                = NO_OBJ_DISTANCE;
      USSPar.Slot[j].SlotPar[i].SlotDepth                                        = NO_OBJ_DISTANCE;
      USSPar.Slot[j].SlotPar[i].DisCarToObj1ByPassingSlot                        = NO_OBJ_DISTANCE;
      USSPar.Slot[j].SlotPar[i].DisCarToObj2ByPassingSlot                        = NO_OBJ_DISTANCE;
      USSPar.Slot[j].SlotPar[i].CarPassTheSlotEndPtDistance                      = 0;
      USSPar.Slot[j].SlotPar[i].CarPassTheSlotDistanceTrajectoryCaled            = 0;
      USSPar.Slot[j].SlotPar[i].CarPassTheSlotDistanceUsedToRecalTrajectoryIndex = 0;
      USSPar.Slot[j].SlotPar[i].TrajectoryCalRequestType                         = APAParkProcSlotFoundTrajCalReqWithoutCaled;

#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
      USSPar.Slot[j].SlotPar[i].bSlotHeadCompensated = FALSE;
      USSPar.Slot[j].SlotPar[i].bSlotTailCompensated = FALSE;
#endif
      USSPar.Slot[j].SlotPar[i].bSlotCurbHasBeenRechecked         = FALSE;
      USSPar.Slot[j].SlotPar[i].bSlotCalConfirmed                 = FALSE;
      //USSPar.Slot[j].SlotPar[i].bSlotCalConfirmedSpeakerHasChimed = FALSE;
      USSPar.Slot[j].SlotPar[i].ParkProcCarEndPosition            = APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2;
      // USSPar.Slot[j].SlotPar[i].SlotCenterLinePar.K               = 0.0;
      // USSPar.Slot[j].SlotPar[i].SlotCenterLinePar.B               = 0.0;
      USSPar.Slot[j].SlotPar[i].SlotID                            = 0;
      USSPar.Slot[j].SlotPar[i].Obj1Width                         = 0;
      USSPar.Slot[j].SlotPar[i].Obj2Width                         = 0;
      USSPar.Slot[j].SlotPar[i].Obj1Type                          = 0;
      USSPar.Slot[j].SlotPar[i].Obj2Type                          = 0;
      USSPar.Slot[j].SlotPar[i].Obj1StartPtIndex                  = 0;
      USSPar.Slot[j].SlotPar[i].Obj1EndPtIndex                    = 0;
      USSPar.Slot[j].SlotPar[i].Obj2StartPtIndex                  = 0;
      USSPar.Slot[j].SlotPar[i].Obj2EndPtIndex                    = 0;
    }
    USSPar.Slot[j].SlotNum        = 0;
    USSPar.Slot[j].SlotConfirmSeq = 0;
    // USSPar.Slot[j].RequestToRemoveSlotNum = 0;
    // USSPar.Slot[j].PrevSlotEndIndex = 0;
    if (ClearSlotParIndex < APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM) {
      break;
    }
  }
  // Parking Out Parameter Start
  USSPar.SlotPEStartSlotCheckTimer = 0;
  if (ClearSlotParIndex >= APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM) {
    for (j = 0; j < APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM; j++) {
      USSPar.Slot[j].SlotDtFailCause = APA_SLOT_DT_FAILED_BY_NO_FAILURE;
    }
  } else {
    USSPar.Slot[ClearSlotParIndex].SlotDtFailCause = APA_SLOT_DT_FAILED_BY_NO_FAILURE;
  }
  // Parking Out Parameter End.
}
/*************************************************************************************************************************************************
 ** Syntax :  void APASlotProcResetSlotBufAndFilterBufData(void) **
 **                                                                                                                                              **
 ** Service ID:   : NO.1                                                                                                                           **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

void APASlotProcResetSlotBufAndFilterBufData(void) {
  uchar i;
  SDGOperatingStateType SDGTempState;
  SDGTempState = SDGState;

  if (SDGTempState != SDG_OPERATION_MODE) {
    USSPar.APASnsDtdObjDisInfoBufReadIndex  = 0;
    USSPar.APASnsDtdObjDisInfoBufWriteIndex = 0;
  }
  for (i = 0; i < APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM; i++) {
    USSPar.Slot[i].SlotOutline.Lane.ObjPtCnt                                                                                 = 0;
    USSPar.Slot[i].SlotOutline.Lane.WrIndex                                                                                  = 0;
    USSPar.Slot[i].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtCntRSns                                  = 0;
    USSPar.Slot[i].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.RemoveIndex                                   = 0;
    USSPar.Slot[i].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.APASlotRearSideSnsCheckCurbPrevValidCurbPtNum = 0;
    USSPar.Slot[i].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope =
        APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;
  }
  for (i = 0; i < APA_SIDE_SENSOR_NUM; i++) {
    APASnsDtdObjPtBuf[i].RemovedPtIndex = 0;
    APASnsDtdObjPtBuf[i].WrIndex        = 0;
  }
  APASlotSnsDtdObjLoopCnt = 0;
  // memset(USSPar.Slot[0].SlotOutline.Data, 0, sizeof(USSPar.Slot[0].SlotOutline.Data));  /*20191231*/
  // memset(&USSPar.Slot[0].SlotOutline.Lane, 0, sizeof(USSPar.Slot[0].SlotOutline.Lane)); /*20191231*/
  // memset(USSPar.Slot[1].SlotOutline.Data, 0, sizeof(USSPar.Slot[1].SlotOutline.Data));  /*20191231*/
  // memset(&USSPar.Slot[1].SlotOutline.Lane, 0, sizeof(USSPar.Slot[1].SlotOutline.Lane)); /*20191231*/
  memset(&USSPar.Slot[0], 0, sizeof(USSPar.Slot[0]));
  memset(&USSPar.Slot[1], 0, sizeof(USSPar.Slot[1]));
  APASlotProcResetSlotInfo(APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM);
  // bAPANewSlotFound = FALSE;
  // USSPar.Slot.bCurbDetected = FALSE;
}
/*************************************************************************************************************************************************
 ** Syntax :  void APASlotProcCorrectSlotReCalculateTheSlotEndPosY(APA_DISTANCE_TYPE SlotLen) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-1-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

void APASlotProcCorrectSlotReCalculateTheSlotEndPosY(APA_DISTANCE_TYPE SlotLen) {
  APA_DISTANCE_CAL_FLOAT_TYPE EndPosY;
  APA_ENUM_TYPE CarEndPosition;

  CarEndPosition = USSPar.ParkProcCarEndPosition;
  if ((SlotLen < (APACal.LengthOfCar + APACal.APAParkProcCarEndPositionToObj1Dis + APACal.APAParkProcCarEndPositionToObj2Dis)) ||
      ((CarEndPosition == APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2))) {
    // Just park the car at the mid of slot.
    EndPosY        = USSPar.TrajCalObj2Pos.y - SlotLen / 2 - (APACal.LenBetweenRAxisAndFBumper - APACal.LengthOfCar / 2);
    CarEndPosition = APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2;
  } else if (CarEndPosition == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1) {
    EndPosY = USSPar.TrajCalObj1Pos.y + APACal.APAParkProcCarEndPositionToObj1Dis + APACal.LenBetweenRAxisAndRBumper;
  } else /*if(USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2)*/
  {
    EndPosY = USSPar.TrajCalObj2Pos.y - APACal.APAParkProcCarEndPositionToObj2Dis - APACal.LenBetweenRAxisAndFBumper;
  }
  USSPar.ParkProcCarEndPosition                                      = CarEndPosition;
  APASlotCorrectionIndicationFlag.Bits.CarEndPosYChanged                = TRUE;
  USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength = SlotLen;
  USSPar.TrajCalCarEndPos.Coordinate.y                               = EndPosY;
}
/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcCorrectSlotReCalculateTheSlotObj2YEndPosY(APA_DISTANCE_CAL_FLOAT_TYPE Obj2Y, APA_DISTANCE_TYPE SlotLen) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
BOOLEAN APASlotProcCorrectSlotReCalculateTheSlotObj2YEndPosY(APA_DISTANCE_CAL_FLOAT_TYPE Obj2Y, APA_DISTANCE_TYPE SlotLen) {
  APA_DISTANCE_TYPE Dis1;

  Dis1 = APACal.APASlotMinSmallSlotLen - SlotLen;
  if (Dis1 > APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS) {
    // ?? Data error
    // ?? Actually code should never reach.
    // If yes. it may be the Obj2.y compensate to much.
    // Just ignore the current correction and return.
  } else {
    if (Dis1 > 400) {
      SlotLen = APACal.APASlotMinSmallSlotLen;
      // The Obj1.y and Obj2.y will be compensated with Dis1 / 2.
      Dis1 /= 2;
      Obj2Y += Dis1;
      USSPar.TrajCalObj1Pos.y -= Dis1;
      //} else if(SlotLen > APACal.APASlotMaxSlotLength) {
      // ?? Data error or the car has just run over the Obj1 and Obj1 has moved away.
      // Just treat as the bigest slot length.
      // SlotLen = APACal.APASlotMaxSlotLength;
      // USSPar.TrajCalObj1Pos.y = ObjPt.y - SlotLen;
    } else {
      // The slot length is still within the min small slot len range.
      // OK.
    }
    // adjust the car end pos.y
    USSPar.TrajCalObj2Pos.y = Obj2Y;
    // APASlotCorrectionIndicationFlag.Bits.Obj2YChanged = TRUE;
    USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist = TRUE;
    APASlotCorrectionFlag.Bits.Obj2YHasBeenCorrected     = TRUE;

    APASlotProcCorrectSlotReCalculateTheSlotEndPosY(SlotLen);

    return TRUE;
  }
  return FALSE;
}

/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcCorrectSlotReCalculateTheSlotObj1YEndPosY(
 APA_DISTANCE_CAL_FLOAT_TYPE Obj1Y, APA_DISTANCE_TYPE SlotLen) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-2-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

BOOLEAN APASlotProcCorrectSlotReCalculateTheSlotObj1YEndPosY(APA_DISTANCE_CAL_FLOAT_TYPE Obj1Y, APA_DISTANCE_TYPE SlotLen) {
  APA_DISTANCE_TYPE Dis1;

  Dis1 = APACal.APASlotMinSmallSlotLen - SlotLen;
  if (Dis1 > APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS) {
    // ?? Data error
    // ?? Actually code should never reach.
    // If yes. it may be the Obj2.y compensate to much.
    // Just ignore the current correction and return.
  } else {
    if (Dis1 > 400) {
      SlotLen = APACal.APASlotMinSmallSlotLen;
      // The Obj1.y and Obj2.y will be compensated with Dis1 / 2.
      Dis1 /= 2;
      Obj1Y -= Dis1;
      USSPar.TrajCalObj2Pos.y += Dis1;
      //} else if(SlotLen > APACal.APASlotMaxSlotLength) {
      // ?? Data error or the car has just run over the Obj1 and Obj1 has moved away.
      // Just treat as the bigest slot length.
      //	SlotLen = APACal.APASlotMaxSlotLength;
      //	USSPar.TrajCalObj2Pos.y = ObjPt.y + SlotLen;
    } else {
      // The slot length is still within the min small slot len range.
      // OK.
    }
    // adjust the car end pos.y

    USSPar.TrajCalObj1Pos.y                           = Obj1Y;
    APASlotCorrectionIndicationFlag.Bits.Obj1YChanged    = TRUE;
    USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist = TRUE;
    APASlotCorrectionFlag.Bits.Obj2YHasBeenCorrected     = TRUE;

    APASlotProcCorrectSlotReCalculateTheSlotEndPosY(SlotLen);
    return TRUE;
  }
  return FALSE;
}
/*************************************************************************************************************************************************
 ** Syntax :  void APASlotProcCorrectObj12YDuringParallelParkingInCheckResetOfObjY(
 BOOLEAN bObjDtdBySns, BOOLEAN bObjCorBySns, APA_ENUM_TYPE cSysType,
 APA_DISTANCE_TYPE CarCornerPtY, APA_DISTANCE_TYPE SlotObj1Y,
 APA_DISTANCE_TYPE SlotObj2Y, APA_DISTANCE_TYPE EndPosToCurCarPosDeltaX) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-2 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

void APASlotProcCorrectObj12YDuringParallelParkingInCheckResetOfObjY(BOOLEAN bObjDtdBySns,
                                                                     BOOLEAN bObjCorBySns,
                                                                     APA_ENUM_TYPE cSysType,
                                                                     APA_DISTANCE_TYPE CarCornerPtY,
                                                                     APA_DISTANCE_TYPE SlotObj1Y,
                                                                     APA_DISTANCE_TYPE SlotObj2Y,
                                                                     APA_DISTANCE_TYPE EndPosToCurCarPosDeltaX) {
  BOOLEAN bSlotCorVehicleIsMoving, bSlotCorVehicleIsStatic, bResetObjY, bAPACarIsRunningBackwards;
  APA_DISTANCE_TYPE MaxSnsDtdObj12CorRange;
  APA_DISTANCE_TYPE SlotLen, CarCornerToObjDis, GearPosChangedAndVehicleMoveDis, CarPosY, MinGearPosChangedAndVehicleMoveDis;
  APA_DISTANCE_TYPE ConfirmedAsNotDtdMaxCarToObjDisWithVehIsMovingCor, ConfirmedAsNotDtdMinCarToObjDisWithVehIsMovingCor;

  bSlotCorVehicleIsMoving   = bAPAVehicleIsMoving;
  bSlotCorVehicleIsStatic   = bAPAVehicleIsStatic;
  bAPACarIsRunningBackwards = USSPar.APACommonFlags.Bits.bCarIsDrivingBackwards;
  bResetObjY                = FALSE;

  if ((bObjDtdBySns == TRUE) || (bObjCorBySns == TRUE)) {
    APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[cSysType]     = 0;
    APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType] = 0;
  }
  // check when the obj is static and object is detected and obj12Y is corrected, after the object moves away, reset the original Obj12Y.
  if ((bSlotCorVehicleIsMoving == TRUE) || (bSlotCorVehicleIsStatic == FALSE)) {
    APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[cSysType] = 0;
    // APASlotCorrectionFlag.Bits.Obj2NotDtdWhenVehicleIsStatic = FALSE;
    // APASlotCorrectionFlag.Bits.Obj2CorrectedWhenVehicleIsStatic = FALSE;
    APASlotCorrectionObj12ExistCheckFlag[cSysType] = 0;
    if (bObjCorBySns == TRUE) {
      APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] = 1; // obj corrected during vehicle is moving.
    }
    if (bObjDtdBySns == TRUE) {
      if (APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] > 1) {
        APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] = 0;
      }
    }
  } else {
    if (APASlotCorrectionObj12ExistCheckFlag[cSysType] == 0) {
      if (APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[cSysType] < APACal.APASlotCorObjConfirmedAsNotDtdDelayTimeWhenVehicleIsStatic) {
        APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[cSysType]++;
      } else {
        APASlotCorrectionObj12ExistCheckFlag[cSysType] = 1;
      }
    } else {
      if (bObjCorBySns == TRUE) {
        APASlotCorrectionObj12ExistCheckFlag[cSysType]                   = 2;
        APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] = 0;
      }
      if (APASlotCorrectionObj12ExistCheckFlag[cSysType] == 2) {
        if (APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[cSysType] < APACal.APASlotCorObjConfirmedAsNotDtdTimeWhenVehicleIsStatic) {
          APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[cSysType]++;
        } else if (APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[cSysType] ==
                   APACal.APASlotCorObjConfirmedAsNotDtdTimeWhenVehicleIsStatic) {
          // when the vehilce is static, the obj2 is not detected, and then it is detected, then it is not detected again for over 3s.
          // Just reset the current slot length to the original and obj pos.
          APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[cSysType]++;
          bResetObjY = TRUE;
        }
      }
    }
  }

  // Check if the objY should be reset to original one when object is moving and the object is corrected.
  if (cSysType == PARearSys) {
    CarCornerToObjDis      = (APA_DISTANCE_TYPE)(CarCornerPtY - SlotObj1Y);
    MaxSnsDtdObj12CorRange = APACal.APASlotCorObj1YStCorMaxCornerSnsDtDis;
    if (MaxSnsDtdObj12CorRange < APACal.APASlotCorObj1YStCorMaxMidSnsDtDis2) {
      MaxSnsDtdObj12CorRange = APACal.APASlotCorObj1YStCorMaxMidSnsDtDis2;
    }
  } else {
    CarCornerToObjDis      = (APA_DISTANCE_TYPE)(SlotObj2Y - CarCornerPtY);
    MaxSnsDtdObj12CorRange = APACal.APASlotCorObj2YStCorMaxCornerSnsDtDis1;
    if (MaxSnsDtdObj12CorRange < APACal.APASlotCorObj2YStCorMaxMidSnsDtDis1) {
      MaxSnsDtdObj12CorRange = APACal.APASlotCorObj2YStCorMaxMidSnsDtDis1;
    }
  }

  if (EndPosToCurCarPosDeltaX < APACal.APASlotCorObjConfirmedAsNotDtdDeltaCarToEndPosXDevidedDis) {
    ConfirmedAsNotDtdMaxCarToObjDisWithVehIsMovingCor = APACal.APASlotCorObjConfirmedAsNotDtdMaxCarToObjDisWithVehIsMovingCor1;
    // ConfirmedAsNotDtdMinCarToObjDisWithVehIsMovingCor = APACal.APASlotCorObjConfirmedAsNotDtdMinCarToObjDisWithVehIsMovingCor1;
    MinGearPosChangedAndVehicleMoveDis = APACal.APASlotCorObjConfirmedAsNotDtdMinCarDrvDisWithOneGearChanged1;
  } else {
    ConfirmedAsNotDtdMaxCarToObjDisWithVehIsMovingCor = APACal.APASlotCorObjConfirmedAsNotDtdMaxCarToObjDisWithVehIsMovingCor2;
    // ConfirmedAsNotDtdMinCarToObjDisWithVehIsMovingCor = APACal.APASlotCorObjConfirmedAsNotDtdMinCarToObjDisWithVehIsMovingCor2;
    MinGearPosChangedAndVehicleMoveDis = APACal.APASlotCorObjConfirmedAsNotDtdMinCarDrvDisWithOneGearChanged2;
  }

  if ((APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] == 1) && (bObjDtdBySns == FALSE)) {
    // Obj has been corrected when vehicle is moving.
    // check car can drv fw dis.
    if (CarCornerToObjDis <= ConfirmedAsNotDtdMaxCarToObjDisWithVehIsMovingCor) {
      // Ok, distance between the obj and the car is within 46cm. (actually it is safety dis 26cm + 20cm).
      APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] = 2;
    } /*else if(Dis1 >= ConfirmedAsNotDtdMinCarToObjDisWithVehIsMovingCor){
     // Ok, distance between the obj and the car is within 46cm. (actually it is safety dis 26cm + 20cm).
     APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] = 3;
     }*/
    APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType] = 0;
    APASlotCorrectionObj12CarCornerMinY[cSysType]                          = 20000;
    APASlotCorrectionObj12CarCornerMaxY[cSysType]                          = -20000;
  } else if ((APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] == 2)
             /*|| (APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] == 3)*/) {
    if (CarCornerToObjDis > MaxSnsDtdObj12CorRange) {
      APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] = 0;
    } else {
      if (bAPACarIsRunningBackwards == FALSE) {
        // drv fw.
        if (APASlotCorrectionObj12CarCornerMaxY[cSysType] < CarCornerPtY) {
          APASlotCorrectionObj12CarCornerMaxY[cSysType] = CarCornerPtY;
        }
      } else {
        // drv bk.
        if (APASlotCorrectionObj12CarCornerMinY[cSysType] > CarCornerPtY) {
          APASlotCorrectionObj12CarCornerMinY[cSysType] = CarCornerPtY;
        }
      }
      if ((APASlotCorrectionObj12CarCornerMaxY[cSysType] != (-20000)) && (APASlotCorrectionObj12CarCornerMinY[cSysType] != 20000)) {
        // Gear pos changed.
        GearPosChangedAndVehicleMoveDis = (APASlotCorrectionObj12CarCornerMaxY[cSysType] - APASlotCorrectionObj12CarCornerMinY[cSysType]);
      } else {
        GearPosChangedAndVehicleMoveDis = 0;
      }
      /*if(APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] == 2)*/
      {
        // Obj has enter 60cm area.
        // check if the obj dis has been out of 80cm.
        if (/*(CarCornerToObjDis >= ConfirmedAsNotDtdMinCarToObjDisWithVehIsMovingCor)
         || */
            (GearPosChangedAndVehicleMoveDis >= MinGearPosChangedAndVehicleMoveDis)) {
          // Ok, distance between the obj and the car is over 80cm (actually it is safety dis 26cm + 54cm).
          if (APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType] < APACal.APASlotCorObjConfirmedAsNotDtdTimeMovingAwayFromObj) {
            APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType]++;
          } else if (APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType] ==
                     APACal.APASlotCorObjConfirmedAsNotDtdTimeMovingAwayFromObj) {
            // Just reset the current slot length to the original and obj pos.
            APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType]++;
            bResetObjY                                                       = TRUE;
            APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[cSysType] = 0;
          }
        }
      } /*else {
       // Obj has enter 60cm area.
       // check if the obj dis has been out of 80cm.
       if((CarCornerToObjDis <= ConfirmedAsNotDtdMaxCarToObjDisWithVehIsMovingCor)
       || (GearPosChangedAndVehicleMoveDis >= MinGearPosChangedAndVehicleMoveDis)){
       // Ok, distance between the obj and the car is within 46cm. (actually it is safety dis 26cm + 20cm).
       if(APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType] < APACal.APASlotCorObjConfirmedAsNotDtdTimeMovingCloseToObj){
       APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType] ++;
       } else if(APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType] == APACal.APASlotCorObjConfirmedAsNotDtdTimeMovingCloseToObj){
       // Just reset the current slot length to the original and obj pos.
       APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[cSysType] ++;
       bResetObjY = TRUE;
       }
       }
       }*/
    }
  }
  if (bResetObjY == TRUE) {
    if (cSysType == PARearSys) {
      SlotLen      = SlotObj2Y - APASlotCorrectionOriginalObj1Y;
      bObjCorBySns = APASlotProcCorrectSlotReCalculateTheSlotObj1YEndPosY(APASlotCorrectionOriginalObj1Y, SlotLen);
    } else {
      SlotLen      = APASlotCorrectionOriginalObj2Y - SlotObj1Y;
      bObjCorBySns = APASlotProcCorrectSlotReCalculateTheSlotObj2YEndPosY(APASlotCorrectionOriginalObj2Y, SlotLen);
    }
  }
}

/*************************************************************************************************************************************************
 ** Syntax :  APACoordinateDataCalFloatType APASlotProcCalObjPtCoordinateBySnsDtdDis(
 APA_DISTANCE_TYPE SnsDtdDis,
 APA_ANGLE_CAL_FLOAT_TYPE AngBetObjAndSnsCenterLine, UCHAR SnsIndex) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-4 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

APACoordinateDataCalFloatType
APASlotProcCalObjPtCoordinateBySnsDtdDis(APA_DISTANCE_TYPE SnsDtdDis, APA_ANGLE_CAL_FLOAT_TYPE AngBetObjAndSnsCenterLine, UCHAR SnsIndex) {
  APACoordinateDataCalFloatType ObjPt;
  APA_DISTANCE_CAL_FLOAT_TYPE DisToObj;
  APA_ANGLE_CAL_FLOAT_TYPE SnsAng;

  if (SnsDtdDis == NO_OBJ_DISTANCE) {
    ObjPt.x = APACal.SnsPos[SnsIndex].x;
    ObjPt.y = APACal.SnsPos[SnsIndex].y;
  } else {
    SnsAng   = APACal.SnsAng[SnsIndex] + AngBetObjAndSnsCenterLine;
    DisToObj = (APA_DISTANCE_CAL_FLOAT_TYPE)SnsDtdDis * MATH_COS(SnsAng);

    ObjPt.x  = DisToObj + APACal.SnsPos[SnsIndex].x;
    DisToObj = (APA_DISTANCE_CAL_FLOAT_TYPE)SnsDtdDis * MATH_SIN(SnsAng);
    ObjPt.y  = APACal.SnsPos[SnsIndex].y + DisToObj;
  }
  return ObjPt;
}
/*************************************************************************************************************************************************
 ** Syntax :  APASlotCoordinateDataCalFloatType APASlotProcCalSlotRelativeToCarCoordinateBySnsDtdDis(
 APA_DISTANCE_TYPE SnsDtdDis, UCHAR SnsIndex) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2                                                                                                                           **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

APASlotCoordinateDataCalFloatType APASlotProcCalSlotRelativeToCarCoordinateBySnsDtdDis(APA_DISTANCE_TYPE SnsDtdDis, UCHAR SnsIndex) {
  APASlotCoordinateDataCalFloatType SlotPt;
  APA_DISTANCE_CAL_FLOAT_TYPE DisToObj;

  if (SnsDtdDis == NO_OBJ_DISTANCE) {
    SlotPt.Coordinate.y = APACal.SnsPos[SnsIndex].y;
    if (APACal.SnsPos[SnsIndex].x > 0) {
      SlotPt.Coordinate.x = APACal.WidthOfCar / 2;
    } else {
      SlotPt.Coordinate.x = -APACal.WidthOfCar / 2;
    }
    SlotPt.DisFromCarToObj = NO_OBJ_DISTANCE;
  } else {
    DisToObj               = (APA_DISTANCE_CAL_FLOAT_TYPE)SnsDtdDis * APACal.SnsAngCos[SnsIndex];
    SlotPt.DisFromCarToObj = (APA_DISTANCE_TYPE)(MATH_FABS(DisToObj));
    SlotPt.Coordinate.x    = (APA_DISTANCE_CAL_FLOAT_TYPE)DisToObj + APACal.SnsPos[SnsIndex].x;
    DisToObj               = (APA_DISTANCE_CAL_FLOAT_TYPE)SnsDtdDis * APACal.SnsAngSin[SnsIndex];
    SlotPt.Coordinate.y    = APACal.SnsPos[SnsIndex].y + (APA_DISTANCE_CAL_FLOAT_TYPE)DisToObj;
  }
  return SlotPt;
}
/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcCheckIfObjPt12IsValid(
 APACarCoordinateDataCalFloatType CurCarPos,
 APACoordinateDataCalFloatType *pObjPt, APA_ENUM_TYPE ObjIndex) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2                                                                                                                           **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

BOOLEAN APASlotProcCheckIfObjPt12IsValid(APACarCoordinateDataCalFloatType CurCarPos, APACoordinateDataCalFloatType *pObjPt, APA_ENUM_TYPE ObjIndex) {
  // ObjIndex = 0; Obj1.
  // ObjIndex = 1: Obj2.
  APALineParameterABCType CurCarPosLineD, CurCarPosLineC;
  APACoordinateDataCalFloatType PtTemp1, CarCornerPt;
  BOOLEAN bHitCar;

  bHitCar = FALSE;
  if (CurCarPos.CarAng > PI / 2) {
    if (ObjIndex == 0) {
      // Obj1.
    } else {
      // Obj2.
      CarCornerPt.x = APACal.HalfWidthOfCar;
      CarCornerPt.y = -APACal.LenBetweenRAxisAndRBumper;
      CarCornerPt   = APATrajCalPointPosWithAngAndCenterPt(CarCornerPt, CurCarPos.CarAng, CurCarPos.Coordinate);

      CarCornerPt.y += APACal.APASlotPObj2YCorCompensateDeltaDis1IfInvalid; // ???
      if (pObjPt->y < CarCornerPt.y) {
        // Car hit obj2.
        bHitCar = TRUE;
        // pObjPt->y = CarCornerPt.y;
      }
      return bHitCar;
    }
  } else {
    if (ObjIndex == 0) {
      // Obj1.
      CarCornerPt.x = -APACal.HalfWidthOfCar;
      CarCornerPt.y = -APACal.LenBetweenRAxisAndRBumper;
      CarCornerPt   = APATrajCalPointPosWithAngAndCenterPt(CarCornerPt, CurCarPos.CarAng, CurCarPos.Coordinate);

      CarCornerPt.y -= APACal.APASlotPObj1YCorCompensateDeltaDis1IfInvalid; // ???
      if (pObjPt->y > CarCornerPt.y) {
        // Car hit obj1.
        // pObjPt->y = CarCornerPt.y;
        bHitCar = TRUE;
      }
      return bHitCar;
    } else {
      // Obj2.
    }
  }

  CurCarPosLineD = APATrajCalLineParABCByCurrentCarPosition(&CurCarPos, 0);

  CurCarPosLineC = APATrajCalLineParABCByPerPendLineAndPointOnLine(CurCarPos.Coordinate, &CurCarPosLineD);

  PtTemp1.x = APATrajCalGetPointToLineDis((*pObjPt), CurCarPosLineD);
  PtTemp1.y = APATrajCalGetPointToLineDis((*pObjPt), CurCarPosLineC);

  if ((PtTemp1.x < APACal.HalfWidthOfCar) && (PtTemp1.y < APACal.LenBetweenRAxisAndRBumper)) {
    // Obj is within Car rect
    // return the car corner pt?
    if (CurCarPos.CarAng > PI / 2) {
      if (ObjIndex == 0) {
        // Obj1.
        PtTemp1.x   = -APACal.HalfWidthOfCar - APACal.APASlotPObj1YCorCompensateDeltaDis2IfInvalid;
        CarCornerPt = APATrajCalPointPosWithAngAndCenterPt(PtTemp1, CurCarPos.CarAng, CurCarPos.Coordinate);
        if (pObjPt->y > CarCornerPt.y) {
          // Hit car.
          bHitCar   = TRUE;
          pObjPt->y = CarCornerPt.y; // ???
        }
      } else {
        // Obj2.
      }
    } else {
      if (ObjIndex == 0) {
        // Obj1.
      } else {
        // Obj2.
        PtTemp1.x   = APACal.HalfWidthOfCar + APACal.APASlotPObj2YCorCompensateDeltaDis2IfInvalid;
        CarCornerPt = APATrajCalPointPosWithAngAndCenterPt(PtTemp1, CurCarPos.CarAng, CurCarPos.Coordinate);
        if (pObjPt->y < CarCornerPt.y) {
          // Hit Car.
          bHitCar   = TRUE;
          pObjPt->y = CarCornerPt.y; // ???
        }
      }
    }
    // return FALSE;
  }
  return bHitCar;
}
/*************************************************************************************************************************************************
 ** Syntax :  APA_DISTANCE_TYPE APASlotProcCorrectSlotPGetObj1ExistMaxSnsDtDis(
 APA_DISTANCE_TYPE APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2,
 APA_DISTANCE_TYPE APASlotCorPObjExistMaxSnsDtDis,
 APACoordinateDataType CarPos
 //APA_ENUM_TYPE APASnsIndex
 )                                                                                                                    **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-5-1-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

APA_DISTANCE_TYPE APASlotProcCorrectSlotPGetObj1ExistMaxSnsDtDis(APA_DISTANCE_TYPE APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2,
                                                                 APA_DISTANCE_TYPE APASlotCorPObjExistMaxSnsDtDis,
                                                                 APACoordinateDataType CarPos
                                                                 // APA_ENUM_TYPE APASnsIndex
) {
  // APASnsIndex = APA_RLS_SNS_INDEX, APA_RL_SNS_INDEX

  APA_DISTANCE_CAL_FLOAT_TYPE CrossPtY;
  APA_DISTANCE_TYPE DeltaY;

  if (APASlotPSlotCorEndPosYCalMethod == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2) {
    // Close to obj2.
    // Just use a small obj1 dis value.

    // if((APASnsIndex == APA_RLS_SNS_INDEX)
    //|| (APASnsIndex == APA_RL_SNS_INDEX)){
    //
    //}

    CrossPtY = USSPar.TrajCalCarEndPosLine.A * CarPos.x + USSPar.TrajCalCarEndPosLine.C;
    DeltaY   = (APA_DISTANCE_TYPE)(CrossPtY - CarPos.y);

    DeltaY = APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2 - DeltaY;
    if (DeltaY < 0) {
      DeltaY = 0;
    } else if (DeltaY > APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2) {
      DeltaY = APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2;
    }
    return DeltaY;
  } else {
    // Mid of obj1 and obj2. or close to obj1.
    return APASlotCorPObjExistMaxSnsDtDis;
  }
}
/*************************************************************************************************************************************************
 ** Syntax :  APA_DISTANCE_TYPE APASlotProcCorrectSlotPGetObj1MaxYWithSDGBuf(
 APA_ENUM_TYPE SDGSnsIndex)                                                                                                                    **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-5-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
#if Debug_SW_PARKINFUNC
APA_DISTANCE_TYPE APASlotProcCorrectSlotPGetObj1MaxYWithSDGBuf(APA_ENUM_TYPE SDGSnsIndex) {

  // Input Par:
  // SDGSnsIndex: SDG_RLS_SNS_INDEX or SDG_FLS_SNS_INDEX (RLC sns)

  // Return value:
  APA_ENUM_TYPE ObjPtCnt, ObjIndex;
  APA_DISTANCE_TYPE Obj1MaxY, Obj1MaxYSearchMinObjPtX;
  APACoordinateDataType CarPosMax1, CarPosMin1;
  APA_DISTANCE_TYPE Obj1MaxYSearchMaxObjPtX, ObjExistMaxSnsDtDis;
  SDGObjPtBufType *pSDGObjPtBuf;

  pSDGObjPtBuf = &SDGObjInfo.SnsObjPtBuf[SDGSnsIndex];
  ObjPtCnt     = pSDGObjPtBuf->ObjPtCnt;
  Obj1MaxY     = USSPar.TrajCalObj1Pos.y;

  if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE) {
    Obj1MaxYSearchMaxObjPtX = USSPar.TrajCalObj1Pos.x + APACal.APASlotCorPEndPosYCalObj1YSearchBkEndDeltaXDis;
  } else {
    return Obj1MaxY;
  }

  CarPosMin1.x = APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_X_MIN1;
  CarPosMin1.y = APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MIN1;
  // CarPosMax1.x = APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_X_MAX1;
  CarPosMax1.y            = APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MAX1;
  CarPosMax1.x            = USSPar.TrajCalCarEndPos.Coordinate.x - 1500;
  Obj1MaxYSearchMinObjPtX = USSPar.TrajCalObj1Pos.x + APACal.APASlotCorPEndPosYCalObj1YSearchBkStartDeltaXDis;
  for (ObjIndex = 0; ObjIndex < ObjPtCnt; ObjIndex++) {
    if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < Obj1MaxYSearchMinObjPtX) {
      // Searching over.
      break;
    }
    if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < Obj1MaxYSearchMaxObjPtX) {
      ObjExistMaxSnsDtDis = APASlotProcCorrectSlotPGetObj1ExistMaxSnsDtDis(APACal.APASlotCorPRecalObjYMaxSnsDtDisEndPosCloseToObj1or2,
                                                                           APACal.APASlotCorPRecalObjYExistMaxSnsDtDis,
                                                                           pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate);
      if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < ObjExistMaxSnsDtDis)) {
        if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x > CarPosMin1.x) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x < CarPosMax1.x) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y > CarPosMin1.y) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y < CarPosMax1.y) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng > APACal.APASlotCorPGetObj1MaxYMinCarAng) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng < APACal.APASlotCorPGetObj1MaxYMaxCarAng)) {
          if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y > Obj1MaxY) {
            Obj1MaxY = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y;
          }
        }
      }
    }
  }
  return Obj1MaxY;
}
#endif
/*************************************************************************************************************************************************
 ** Syntax :  APA_DISTANCE_TYPE APASlotProcCorrectSlotPGetObj2MinYWithSDGBuf(
 APA_ENUM_TYPE SDGSnsIndex)                                                                                                                   **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-5-2-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

APA_DISTANCE_TYPE APASlotProcCorrectSlotPGetObj2ExistMaxSnsDtDis(APA_DISTANCE_TYPE APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2,
                                                                 APA_DISTANCE_TYPE APASlotCorPObjExistMaxSnsDtDis,
                                                                 APACoordinateDataType CarPos
                                                                 // APA_ENUM_TYPE APASnsIndex
) {
  // APASnsIndex = APA_RRS_SNS_INDEX, APA_RR_SNS_INDEX
  APA_DISTANCE_CAL_FLOAT_TYPE CrossPtY;
  APA_DISTANCE_TYPE DeltaY;

  if (APASlotPSlotCorEndPosYCalMethod == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1) {
    // Close to obj1.
    // Just use a small obj2 dis value.

    // if((APASnsIndex == APA_RRS_SNS_INDEX)
    //|| (APASnsIndex == APA_RR_SNS_INDEX)){
    //
    //}
    CrossPtY = USSPar.TrajCalCarEndPosLine.A * CarPos.x + USSPar.TrajCalCarEndPosLine.C;
    DeltaY   = (APA_DISTANCE_TYPE)(CarPos.y - CrossPtY);

    DeltaY = APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2 - DeltaY;
    if (DeltaY < 0) {
      DeltaY = 0;
    } else if (DeltaY > APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2) {
      DeltaY = APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2;
    }
    return DeltaY;
  } else {
    // Mid of obj1 and obj2. or close to obj2.
    return APASlotCorPObjExistMaxSnsDtDis;
  }
}
/*************************************************************************************************************************************************
 ** Syntax :  APA_DISTANCE_TYPE APASlotProcCorrectSlotPGetObj2MinYWithSDGBuf(
 APA_ENUM_TYPE SDGSnsIndex)                                                                                                                   **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-5-2 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
#if Debug_SW_PARKINFUNC
APA_DISTANCE_TYPE APASlotProcCorrectSlotPGetObj2MinYWithSDGBuf(APA_ENUM_TYPE SDGSnsIndex) {
  // Input Par:
  // SDGSnsIndex: SDG_RRS_SNS_INDEX or SDG_FRS_SNS_INDEX (RRC sns)
  // Return value:

  APA_ENUM_TYPE ObjPtCnt, ObjIndex, MinObjYIndex;
  APA_DISTANCE_TYPE Obj2MinY, Obj2MinYSearchMinObjPtX;
  APACoordinateDataType CarPosMax1, CarPosMin1;
  APA_DISTANCE_TYPE Obj2MinYSearchMaxObjPtX, ObjExistMaxSnsDtDis;
  APA_ANGLE_CAL_FLOAT_TYPE CarAngTemp;
  APA_DISTANCE_CAL_FLOAT_TYPE fDis;

  SDGObjPtBufType *pSDGObjPtBuf;

  pSDGObjPtBuf = &SDGObjInfo.SnsObjPtBuf[SDGSnsIndex];

  ObjPtCnt = pSDGObjPtBuf->ObjPtCnt;

  Obj2MinY = USSPar.TrajCalObj2Pos.y;

  if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
    Obj2MinYSearchMaxObjPtX = USSPar.TrajCalObj2Pos.x + APACal.APASlotCorPEndPosYCalObj2YSearchBkEndDeltaXDis;
  } else {
    return Obj2MinY;
  }

  CarPosMin1.x = APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_POS_X_MIN1;
  CarPosMin1.y = APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MIN1;
  // CarPosMax1.x = APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_POS_X_MAX1;
  CarPosMax1.y            = APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MAX1;
  CarPosMax1.x            = USSPar.TrajCalCarEndPos.Coordinate.x - 1500;
  Obj2MinYSearchMinObjPtX = USSPar.TrajCalObj2Pos.x + APACal.APASlotCorPEndPosYCalObj2YSearchBkStartDeltaXDis;
  MinObjYIndex            = ObjPtCnt;
  for (ObjIndex = 0; ObjIndex < ObjPtCnt; ObjIndex++) {
    if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < Obj2MinYSearchMinObjPtX) {
      // Searching over.
      break;
    }
    if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < Obj2MinYSearchMaxObjPtX) {
      ObjExistMaxSnsDtDis = APASlotProcCorrectSlotPGetObj2ExistMaxSnsDtDis(APACal.APASlotCorPRecalObjYMaxSnsDtDisEndPosCloseToObj1or2,
                                                                           APACal.APASlotCorPRecalObjYExistMaxSnsDtDis,
                                                                           pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate);
      if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < ObjExistMaxSnsDtDis)) {
        if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x > CarPosMin1.x) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x < CarPosMax1.x) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y > CarPosMin1.y) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y < CarPosMax1.y) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng > APACal.APASlotCorPGetObj2MinYMinCarAng) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng < APACal.APASlotCorPGetObj2MinYMaxCarAng)) {
          if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y < Obj2MinY) {
            Obj2MinY     = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y;
            MinObjYIndex = ObjIndex;
          }
        }
      }
    }
  }

  if (MinObjYIndex < ObjPtCnt) {
    CarAngTemp = MATH_FABS(pSDGObjPtBuf->ObjPtBuf[MinObjYIndex].CarPos.CarAng - USSPar.TrajCalCarEndPos.CarAng);

    if (CarAngTemp > (40.0 * PI / 180.0)) {
      // Compensate a dis. 40cm.
      Obj2MinY += APACal.APASlotCorPObj2YCorRRSSnsCompDisWithDelatCarAng1;
    } else if (CarAngTemp > (10.0 * PI / 180.0)) {
      // 10 ~ 40deg. compensate: 0 ~ 40cm.
      fDis = APACal.APASlotCorPObj2YCorRRSSnsCompDisWithDelatCarAng2;
      fDis = fDis * (CarAngTemp - 10.0 * PI / 180.0) / (40.0 * PI / 180.0 - 10.0 * PI / 180.0);
      Obj2MinY += fDis;
    }
    if (Obj2MinY > USSPar.TrajCalObj2Pos.y) {
      Obj2MinY = USSPar.TrajCalObj2Pos.y;
    }
  }
  return Obj2MinY;
}
#endif
/*************************************************************************************************************************************************
 ** Syntax :  void APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(APA_DISTANCE_TYPE SlotLen,
 APA_ENUM_TYPE Obj1Or2Cor)                                                                                                                    **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-5 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
#if Debug_SW_PARKINFUNC
void APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(APA_DISTANCE_TYPE SlotLen, APA_ENUM_TYPE Obj1Or2Cor) {
  // Obj1Or2Cor = 0: Obj1 is corrected.
  //            = 1: Obj2 is corrected.

  APA_DISTANCE_CAL_FLOAT_TYPE EndPosY, fDis1, fDis2, fDis3;
  APA_ENUM_TYPE EndPosYCalMethod;
  APACarCoordinateDataCalFloatType CarCenterPt;
  APA_ANGLE_CAL_FLOAT_TYPE CarAngTemp, LineAng;
  APA_DISTANCE_TYPE Dis1, Dis2, Obj1MaxY, Obj2MinY, DeltaX1, DeltaY1, EndPosTolY;
  APA_DISTANCE_TYPE Obj2CompDis;
  APA_ENUM_TYPE Obj2TypeGroupIndex, Obj2Type;

  if (APASlotCorrectionFlag.Bits.SlotBorderLineHasBeenCorrected == TRUE) {
    return;
  }

  CarCenterPt = USSPar.APACarCenterPt;
  EndPosTolY  = USSPar.ParkProcCarEndPositionTol;

  if (APACal.APACalCommonFlags.Bits.bAPASlotCorPReDetermineEndPosSide == TRUE) {
    if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == FALSE) {
      // Close to obj2.
      USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2; // close to obj2.
    } else if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == FALSE) {
      USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1; // close to obj1.
    } else {
      Dis1 = SlotLen;
      if (USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2) {
        Dis2 = APACal.APATrajCalPMaxSlotLengthForAGivenSlot + APA_PARKPROC_CAR_END_POSITION_REDTM_SLOT_TOL1;
        if (Dis1 > Dis2) {
          // Big than a regular slot.
          // redtm the parking side.
          if ((CarCenterPt.Coordinate.y - USSPar.TrajCalObj1Pos.y) < (USSPar.TrajCalObj2Pos.y - CarCenterPt.Coordinate.y)) {
            // Car is now close to obj1.
            USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1;
          } else {
            USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2;
          }
        }
      } else {
        // car park close to obj1 or obj2.
        Dis2 = (APACal.WidthOfCar + APACal.APAParkProcCarEndPositionToObj1Dis + APACal.APAParkProcCarEndPositionToObj2Dis);
        if (Dis1 < Dis2) {
          // Park at mid of slot.
          USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2;
        } else {
          // Remain the last state.
        }
      }
    }
  } else {
  }

  // Search the Obj1 Max Y and Obj2 min Y
  Obj1MaxY = APASlotProcCorrectSlotPGetObj1MaxYWithSDGBuf(SDG_RLS_SNS_INDEX);

  Dis1 = APASlotProcCorrectSlotPGetObj1MaxYWithSDGBuf(SDG_FLS_SNS_INDEX);

  if (Obj1MaxY < Dis1) {
    Obj1MaxY = Dis1;
  }

  if (APASlotCorrectionIndicationFlag.Bits.Obj2YChanged == FALSE) {
    if (Obj1Or2Cor == 0) {
      if (SlotLen < APACal.APASlotPCorMaxSlotLenToAddCompForObj2IfObj1CorObj2NotCor) {
        // SLot len < 3.4m
        Obj2Type = USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].Obj2Type;

        if (Obj2Type <= APA_SLOT_OBJ_TYPE_SQUARE_OBJ_WITH_FALLING_SHAPE) {
          Obj2TypeGroupIndex = 0;
        } else if (Obj2Type <= APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_BIG_RISING_AND_FALLING_SHAPE) {
          Obj2TypeGroupIndex = 1;
        } else if (Obj2Type <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_SMALL_WIDTH) {
          Obj2TypeGroupIndex = 2;
        } else if (Obj2Type <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_NORMAL_FLAT_NORMAL_WIDTH) {
          Obj2TypeGroupIndex = 3;
        } else if (Obj2Type <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_NORMAL_WIDTH) {
          Obj2TypeGroupIndex = 4;
        } else if (Obj2Type <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_SMALL_FLAT_BIG_WIDTH) {
          Obj2TypeGroupIndex = 5;
        } else if (Obj2Type <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_NORMAL_FLAT_BIG_WIDTH) {
          Obj2TypeGroupIndex = 6;
        } else if (Obj2Type <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_BIG_WIDTH) {
          Obj2TypeGroupIndex = 7;
        } else {
          Obj2TypeGroupIndex = 8;
        }
        Obj2CompDis = APACal.APASlotPCorObj2CompDisIfObjIsCorObj2IsNotCor[Obj2TypeGroupIndex];
        // check com dis by obj type.
        USSPar.TrajCalObj2Pos.y += Obj2CompDis;
        SlotLen += Obj2CompDis;
      }
      APASlotCorrectionIndicationFlag.Bits.Obj2YChanged = TRUE;
    }
  }
  Obj2MinY = APASlotProcCorrectSlotPGetObj2MinYWithSDGBuf(SDG_RRS_SNS_INDEX);
  Dis1     = APASlotProcCorrectSlotPGetObj2MinYWithSDGBuf(SDG_FRS_SNS_INDEX);
  if (Obj2MinY > Dis1) {
    Obj2MinY = Dis1;
  }
  EndPosYCalMethod = USSPar.ParkProcCarEndPosition;
  if (EndPosYCalMethod == APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2) {
    EndPosY = (Obj1MaxY + Obj2MinY) / 2; // (USSPar.TrajCalObj1Pos.y + USSPar.TrajCalObj2Pos.y) / 2;
    // Check if the car end pos almost achieved ?
    DeltaX1    = USSPar.TrajCalCarEndPos.Coordinate.x - CarCenterPt.Coordinate.x;
    CarAngTemp = MATH_FABS(CarCenterPt.CarAng - USSPar.TrajCalCarEndPos.CarAng);
    fDis1      = USSPar.TrajCalCarEndPosLine.A * CarCenterPt.Coordinate.x + USSPar.TrajCalCarEndPosLine.C; // Y.
    DeltaY1    = (APA_DISTANCE_TYPE)fDis1;
    if ((DeltaX1 < APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMinDeltaX) &&
        (CarAngTemp < APACal.APAParkProcPInSlotStartUseCorSteeringAngleDeltaCarAngle) && (DeltaY1 < EndPosTolY)) {
      // End pos almost achieved.
      // do not recheck if offset a dis or not.
      // just remain the last state.
      if (APASlotCorrectionFlag.Bits.EndPosYHasBeenCorrectedToOffsetFromObj1 == TRUE) {
        EndPosY += APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlot;
      }
    } else {
      if (APASlotCorrectionFlag.Bits.EndPosYHasBeenCorrectedToOffsetFromObj1 == FALSE) {
        if ((SlotLen > (APACal.WidthOfCar + APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMinSideDis)) &&
            (SlotLen < (APACal.WidthOfCar + APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMaxSideDis))) {
          EndPosY += APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlot;
          APASlotCorrectionFlag.Bits.EndPosYHasBeenCorrectedToOffsetFromObj1 = TRUE;
        }
      } else {
        if ((SlotLen < (APACal.WidthOfCar + APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMinSideDis -
                        APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlotResetTol)) ||
            (SlotLen > (APACal.WidthOfCar + APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMaxSideDis +
                        APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlotResetTol))) {
          APASlotCorrectionFlag.Bits.EndPosYHasBeenCorrectedToOffsetFromObj1 = FALSE;
        } else {
          EndPosY += APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlot;
        }
      }
    }
  } else if (EndPosYCalMethod == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1) {
    EndPosY = APACal.APATrajCalPCarEndPositionToObj1Dis + APACal.HalfWidthOfCar + Obj1MaxY; // + USSPar.TrajCalObj1Pos.y;
  } else {
    EndPosY = /*USSPar.TrajCalObj2Pos.y*/ Obj2MinY - APACal.APATrajCalPCarEndPositionToObj2Dis - APACal.HalfWidthOfCar;
  }

  if (USSPar.TrajCalSlotLeftSideLine.K == 0) {
    USSPar.TrajCalSlotLeftSideLine.B = USSPar.TrajCalObj1Pos.y;
  }
  if (USSPar.TrajCalSlotRightSideLine.K == 0) {
    USSPar.TrajCalSlotRightSideLine.B = USSPar.TrajCalObj2Pos.y;
  }
  APASlotPSlotCorEndPosYCalMethod                                       = EndPosYCalMethod;
  APASlotCorrectionIndicationFlag.Bits.CarEndPosYChanged                = TRUE;
  USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength = SlotLen;
  USSPar.TrajCalCarEndPos.Coordinate.y                               = EndPosY;
  if (USSPar.TrajCalCarEndPosLine.LineType == APALineIsHorizontal) {
    USSPar.TrajCalCarEndPosLine.C = USSPar.TrajCalCarEndPos.Coordinate.y;
  }
  if (APASlotCorrectionFlag.Bits.SlotBorderLineHasBeenCorrected == FALSE) {
    USSPar.TrajCalCarEndPos.CarAng       = PI / 2;
    USSPar.TrajCalCarEndPos.Coordinate.x = USSPar.SlotCarEndPosXPrevValue;
    USSPar.TrajCalCarEndPosLine.A        = 0;
    USSPar.TrajCalCarEndPosLine.B        = 1.0;
    USSPar.TrajCalCarEndPosLine.C        = USSPar.TrajCalCarEndPos.Coordinate.y;
    USSPar.TrajCalCarEndPosLine.LineType = APALineIsHorizontal;
  } else {
  }
  if (APASlotCarDrvFwBkCntForEndPosCarAngCor > 2) {
    // Corrent the car end pos angle.
    if (APASlotCorrectionFlag.Bits.SlotBorderLineHasBeenCorrected == FALSE) {
      CarAngTemp = PI / 2.0;
      LineAng    = APASlotCarDrvFwBkCntForEndPosCarAngCor - 2;
      LineAng *= APACal.APASlotCorPCarEndPosAngCompensateAngPerFrwAndBk;
      CarAngTemp += LineAng;
      LineAng                                 = MATH_TAN(LineAng);
      fDis1                                   = LineAng * USSPar.TrajCalCarEndPos.Coordinate.x + EndPosY;
      USSPar.TrajCalCarEndPos.CarAng       = CarAngTemp;
      USSPar.TrajCalCarEndPos.Coordinate.y = fDis1;
      USSPar.TrajCalCarEndPosLine.LineType = APALineIsIncline;
      USSPar.TrajCalCarEndPosLine.A        = LineAng;
      USSPar.TrajCalCarEndPosLine.B        = 1.0;
      USSPar.TrajCalCarEndPosLine.C        = EndPosY;
      ;
    } else {
    }
  } else {
  }
}
#endif

/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcCorrectSlotPReCalObj2YWithSDGBuf(
 APACarCoordinateDataCalFloatType CurCarCenterPt,
 APA_ENUM_TYPE SDGSnsIndex)                                                                                                                    **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-6 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
#if Debug_SW_PARKINFUNC
BOOLEAN APASlotProcCorrectSlotPReCalObj2YWithSDGBuf(APACarCoordinateDataCalFloatType CurCarCenterPt, APA_ENUM_TYPE SDGSnsIndex) {

  // Input Par:
  // SDGSnsIndex: SDG_RRS_SNS_INDEX or SDG_FRS_SNS_INDEX (RRC sns)

  // Return value: TRUE: Obj2.y corrected.
  //               FALSE: no corrected.

  APA_ENUM_TYPE ObjPtCnt, ObjIndex, ObjIndex2, ObjIndex3, ObjIndex4, ObjIndex5, ObjIndex6, CalCnt;
  APA_ENUM_TYPE OptimalPointNum, ValidObjIndex[SDG_MAX_SUPPORT_OBJ_POINT_BUF_SIZE], ValidObjPtNum;
  APA_DISTANCE_TYPE SnsDtNearestDis, SnsDtNearestDis2, ObjPt2Y, SlotLen, Dis1, Dis2, Dis3, ObjPt2X;
  APACoordinateDataCalFloatType ObjPt, CarCornerPt, CarPos;
  APA_ANGLE_CAL_FLOAT_TYPE MaxCarAng, CarAngTemp, MaxCarAng2;
  APACoordinateDataType CarPos1, CarPosMax1, CarPosMin1;
  APA_DISTANCE_TYPE ObjPtMinX1, ObjPtYMinValue, ObjExistMaxSnsDtDis, ObjPtXSearchBkMinDeltaDis;
  BOOLEAN bFlag, bObj2Exist, bOptimalPtFound, bObjPtLessThanObj2YFound;
  APA_ENUM_TYPE APASnsIndex, OptimalPointIndex, OptimalPointObjMinYIndex;
  APA_DISTANCE_CAL_FLOAT_TYPE fDis;
  APA_DISTANCE_TYPE Obj2PtX, OptimalPointObjY, DisY, OptimalPointObjMinY;

  SDGObjPtBufType *pSDGObjPtBuf;

  pSDGObjPtBuf = &SDGObjInfo.SnsObjPtBuf[SDGSnsIndex];
  ObjPtCnt     = pSDGObjPtBuf->ObjPtCnt;

  if (ObjPtCnt < 1) {
    return FALSE;
  }

  if (SDGSnsIndex == SDG_RRS_SNS_INDEX) {
    APASnsIndex = APA_RRS_SNS_INDEX;
  } else {
    APASnsIndex = APA_RR_SNS_INDEX;
  }

  SnsDtNearestDis   = NO_OBJ_DISTANCE;
  SnsDtNearestDis2  = NO_OBJ_DISTANCE;
  MaxCarAng         = 0;
  ObjIndex2         = ObjPtCnt;
  ObjIndex3         = ObjPtCnt;
  ObjIndex4         = ObjPtCnt;
  ObjIndex5         = ObjPtCnt;
  OptimalPointIndex = 0;

  // if(USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE){
  // CarPos1.x = USSPar.TrajCalObj2Pos.x + APACal.APASlotCorPObjYCorSearchBkDeltaXDis;
  //} else {
  /*if(SDGSnsIndex == SDG_RLS_SNS_INDEX){
   CarPos1.x = USSPar.TrajCalCarEndPos.Coordinate.x - APACal.APASlotCorPObjExistMaxSnsDtDis;
   } else {
   CarPos1.x = USSPar.TrajCalCarEndPos.Coordinate.x - APACal.APASlotCorPObjExistMaxSnsDtDis;
   }*/

  CarPos1.x = -500;
  //}

  CarPos1.y    = APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MAX1;
  Obj2PtX      = USSPar.TrajCalObj2Pos.x;
  ObjPt2Y      = APASlotCorrectionOriginalObj2Y; // USSPar.TrajCalObj2Pos.y;
  ObjPtMinX1   = Obj2PtX + APACal.APASlotCorPEndPosYCalObj2YOptimalPtMinDeltaX;
  CarPosMin1.x = APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_POS_X_MIN1;
  CarPosMin1.y = APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MIN1;
  // CarPosMax1.x = APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_POS_X_MAX1;
  CarPosMax1.y = APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MAX1;
  // PrevCarAng = PI / 2.0;
  CarPosMax1.x   = USSPar.TrajCalCarEndPos.Coordinate.x - APACal.APASlotCorPRecalObj2YCarPosXMinDeltaDisToEndPosX;
  ObjPtYMinValue = NO_OBJ_DISTANCE;

  MaxCarAng2 = PI;

  bObj2Exist = USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist;

  ValidObjPtNum = 0;

  OptimalPointObjY         = -5000;
  bObjPtLessThanObj2YFound = FALSE;
  for (ObjIndex = 0; ObjIndex < ObjPtCnt; ObjIndex++) {

    if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y > CarPos1.y) ||
        ((ObjIndex3 != ObjPtCnt) && (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x < CarPos1.x)) ||
        (MATH_FABS(CurCarCenterPt.CarAng - pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng) > APACal.APASlotCorPObj2YCorMaxDeltaCarAng) ||
        ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < APACal.APASlotCorPRecalObjYExistMaxSnsDtDis) &&
         ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y - APACal.APASlotCorPObj2YCorAllowObjMaxYAndMinYDeltaDis) > ObjPtYMinValue))) {
      // Searching over.
      break;
    }

    if (bObj2Exist == FALSE) {
      ObjExistMaxSnsDtDis = APASlotProcCorrectSlotPGetObj2ExistMaxSnsDtDis(APACal.APASlotCorPRecalObjYMaxSnsDtDisEndPosCloseToObj1or2,
                                                                           APACal.APASlotCorPRecalObjYExistMaxSnsDtDis,
                                                                           pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate);
    } else {
      ObjExistMaxSnsDtDis = APACal.APASlotCorPObj2YCorObj2ExistAllowMaxSnsDtDis;
    }

    if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < ObjExistMaxSnsDtDis)) {
      if ((bObj2Exist == TRUE) &&
          (((pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < ObjPtMinX1) && (ObjIndex4 != ObjPtCnt)) || (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < Obj2PtX))) {
        // Searching over.
        break;
      }

#if 0
			if(MATH_FABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng - PrevCarAng)
					> (10.0 * PI / 180.0)) {
				PrevCarAng = pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng;
				CarPosMax1.x = APASlotProcInSlotCalculateSlotBorderLineGetMaxCarPosXWithCarAng(
						PrevCarAng,
						APASnsIndex);
				CarPosMax1.x -= APACal.APASlotCorPRecalObj2YCarPosXMinDeltaDisToEndPosX;
			}
#endif

      if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x > CarPosMin1.x) &&
          (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x < CarPosMax1.x) &&
          (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y > CarPosMin1.y) &&
          (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y < CarPosMax1.y) &&
          (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng > APACal.APASlotCorPRecalObj2YMinCarAng) &&
          (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng < APACal.APASlotCorPRecalObj2YMaxCarAng)) {
        if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y < (ObjPt2Y - APACal.APASlotCorPObj2YCorRegardedAsInvalidObj2YMaxDeltaObj2YDis)) {
          bObjPtLessThanObj2YFound = TRUE;
        }
        bFlag = FALSE;
        if (MATH_FABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng - USSPar.TrajCalCarEndPos.CarAng) >
            APACal.APASlotCorPObj2YCorRegardedAsInvalidObj2YMaxDeltaCarAng2) {
          // The delta car angle is very big.
          if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis > APACal.APASlotCorPObj2YCorRegardedAsInvalidObj2YMaxSnsDtObjDis) {
            // It is an object which may be with great tolerance.
            // Just disable it.
            // regarded as an invalid obj point.
            Dis1 = ObjPt2Y - pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y;
            if (MATH_ABS(Dis1) > (APACal.APASlotCorPObj2YCorRegardedAsInvalidObj2YMaxDeltaObj2YDis)) {
              // Invalid obj pt.
              bFlag = TRUE;
            }
          }
        }

        if (bFlag == FALSE) {
          if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x > ObjPtMinX1) &&
              (MATH_ABS(ObjPt2Y - pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y) < (APACal.APASlotCorPEndPosYCalObj2YOptimalPtDeltaYWithOriginalObj2Y))) {
            ValidObjIndex[ValidObjPtNum] = ObjIndex;
            ValidObjPtNum++;
            if (OptimalPointObjY < pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y) {
              OptimalPointObjY  = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y;
              OptimalPointIndex = ObjIndex;
            }
          }
          if ((ObjPtYMinValue > pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y)) {
            ObjPtYMinValue = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y;
          }
          if (MaxCarAng < pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng) {
            ObjIndex2 = ObjIndex;
            MaxCarAng = pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng;
          }
          if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < SnsDtNearestDis) {
            ObjIndex3       = ObjIndex;
            SnsDtNearestDis = pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis;
          }

          if (MaxCarAng2 == PI) {
            MaxCarAng2 = pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng;
          }

          CarAngTemp = MaxCarAng2 - pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng;
          if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < SnsDtNearestDis2) && (CarAngTemp < 25.0 * PI / 180.0)) {
            ObjIndex5        = ObjIndex;
            SnsDtNearestDis2 = pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis;
          }

          ObjIndex4 = ObjIndex;
        }
      }
    }
  }

  // check which point is more optimal to cal the obj2.y
  // Max car angle has a great optunity.

  // Check Obj2.y:
  // ObjIndex2: Max car angle:
  // ObjIndex3: Nearest dis:
  // ObjIndex4: last valid obj index:

  if ((ObjIndex2 < ObjPtCnt) && (ObjIndex3 < ObjPtCnt) && (ObjIndex4 < ObjPtCnt)) {
    // OK ,
    // Check if the point is within optimal range.
    if (bObj2Exist == FALSE) {
      // Actually code should never reach.
      // but just incase.
      // Here we just use the min dis to regarded as obj2.x.
      ObjPt2X = pSDGObjPtBuf->ObjPtBuf[ObjIndex3].Pt.x;


      USSPar.TrajCalObj2Pos.x = ObjPt2X;
      // APASlotCorrectionIndicationFlag.Bits.Obj2XChanged = TRUE;
      // APASlotCorrectionFlag.Bits.Obj2XHasbeenCorrectedWhenObj2DoesNotExist = TRUE;
      USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist = TRUE;

      // Actually it is hard to determine the exact obj.x, do not adjust the endpos.x
#if 0
			// adjust the car end pos.x
			if((bAPATrajCalCarParkAlongCurb == FALSE)
					&& (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE)) {
				Dis1 = USSPar.TrajCalObj1Pos.x;
				Dis1 -= ObjPt2X;
				if(Dis1 < 0) {
					Dis1 = -Dis1;
				}
				if(Dis1 < APACal.APATrajCalPCalCarEndPosXWithMeanValueAllowObj1Obj2MaxOffsetDis) {

					USSPar.TrajCalCarEndPos.Coordinate.x =
					(USSPar.TrajCalObj1Pos.x + USSPar.TrajCalObj2Pos.x) / 2.0 + APACal.LenBetweenRAxisAndFBumper;
					APASlotCorrectionIndicationFlag.Bits.CarEndPosXChanged = TRUE;

					USSPar.SlotCarEndPosXPrevValue = USSPar.TrajCalCarEndPos.Coordinate.x;
				}

			}
#endif
    }

    // Check Obj2.y:
    // ObjIndex2: Max car angle:
    // ObjIndex3: Nearest dis:
    // ObjIndex4: last valid obj index:

    bOptimalPtFound = FALSE;
    if (OptimalPointObjY != (-5000)) {
      // Point not found
      for (CalCnt = 0; CalCnt < 4; CalCnt++) {
        OptimalPointNum          = 0;
        OptimalPointObjMinY      = OptimalPointObjY;
        OptimalPointObjMinYIndex = OptimalPointIndex;
        for (ObjIndex = 0; ObjIndex < ValidObjPtNum; ObjIndex++) {
          ObjIndex6 = ValidObjIndex[ObjIndex];
          DisY      = OptimalPointObjY - pSDGObjPtBuf->ObjPtBuf[ObjIndex6].Pt.y;
          if (MATH_ABS(DisY) < APACal.APASlotCorPEndPosYCalObj2YOptimalPtDeltaY) {
            DisY = OptimalPointObjY - ObjPt2Y;
            OptimalPointNum++;
            if (OptimalPointObjMinY > pSDGObjPtBuf->ObjPtBuf[ObjIndex6].Pt.y) {
              OptimalPointObjMinY      = pSDGObjPtBuf->ObjPtBuf[ObjIndex6].Pt.y;
              OptimalPointObjMinYIndex = ObjIndex6;
            }
            if (OptimalPointNum >= APACal.APASlotCorPEndPosYCalObj2YOptimalPtMinPtNum) {
              // Optimal point found.
              bOptimalPtFound = TRUE;
              // break;
            }
          }
        }
        if (bOptimalPtFound == TRUE) {
          break;
        }
        DisY             = OptimalPointObjY;
        OptimalPointObjY = -5000;
        for (ObjIndex = 0; ObjIndex < ValidObjPtNum; ObjIndex++) {
          ObjIndex6 = ValidObjIndex[ObjIndex];
          if (DisY > pSDGObjPtBuf->ObjPtBuf[ObjIndex6].Pt.y) {
            if (OptimalPointObjY < pSDGObjPtBuf->ObjPtBuf[ObjIndex6].Pt.y) {
              OptimalPointObjY  = pSDGObjPtBuf->ObjPtBuf[ObjIndex6].Pt.y;
              OptimalPointIndex = ObjIndex6;
            }
          }
        }
        if (OptimalPointObjY == (-5000)) {
          // Point not found
          break;
        }
      }
    }
    ObjIndex                  = ObjPtCnt;
    ObjPt2X                   = (USSPar.TrajCalObj2Pos.x);
    ObjPtXSearchBkMinDeltaDis = (APACal.APASlotCorPObjYCorSearchBkDeltaXDis / 2);

    if (bOptimalPtFound == TRUE) {
      ObjIndex = OptimalPointObjMinYIndex;
    } else if (ObjIndex5 < ObjPtCnt) {
      ObjIndex4 = ObjIndex5;
      Dis1      = pSDGObjPtBuf->ObjPtBuf[ObjIndex5].Pt.x - ObjPt2X; // Nearest dis.
      if (Dis1 < APACal.APASlotCorPObjYCorSearchBkDeltaXDis) {
        // Just use the nearest dis with high priority.
        ObjIndex = ObjIndex5;
      }
    } else if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.y - pSDGObjPtBuf->ObjPtBuf[ObjIndex3].Pt.y) < 200) { // kjy changed from 30cm to 20cm, 2014 07 24
      // Within 30cm tolerance

      Dis1 = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x - ObjPt2X; // Max car angle.
      Dis2 = pSDGObjPtBuf->ObjPtBuf[ObjIndex3].Pt.x - ObjPt2X; // Nearest dis.
      if (MATH_FABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex2].CarPos.CarAng - pSDGObjPtBuf->ObjPtBuf[ObjIndex3].CarPos.CarAng) > 30.0 * PI / 180.0) {
        // Use max car angle as high priority.

        if (Dis1 < APACal.APASlotCorPObjYCorSearchBkDeltaXDis) {
          // Just use the max car angle with high priority.
          ObjIndex = ObjIndex2;
        } else {
          // Check the nearest dis .X.
          if (Dis2 > ObjPtXSearchBkMinDeltaDis) {
            if (Dis2 < APACal.APASlotCorPObjYCorSearchBkDeltaXDis) {
              // Just use the min dis with high priority.
              ObjIndex = ObjIndex3;
            } else {
              // from ObjIndex4 searching back.
            }

          } else {
            // Nearest obj dis .X < 0
            // from Objindex4 searching back.
            ObjIndex4 = ObjIndex3;
          }
        }
      } else {
        // Max car angle obj dis .X < 50cm
        // Check the nearest dis .X
        if (Dis2 > ObjPtXSearchBkMinDeltaDis) {
          if (Dis2 < APACal.APASlotCorPObjYCorSearchBkDeltaXDis) {
            // Just use the min dis with high priority.
            ObjIndex = ObjIndex3;
          } else {
            // Use the max car angle index to search back.
            // from ObjIndex4 searching back.
            ObjIndex4 = ObjIndex2;
          }
        } else {
          // Nearest obj dis .X < 0
          // from Objindex4 searching back.
          if (ObjIndex2 < ObjIndex3) {
            ObjIndex4 = ObjIndex2;
          } else {
            ObjIndex4 = ObjIndex3;
          }
        }
      }
    } else {
      ObjIndex4 = ObjIndex3;
      Dis1      = pSDGObjPtBuf->ObjPtBuf[ObjIndex3].Pt.x - ObjPt2X; // Nearest dis.
      if (Dis1 < APACal.APASlotCorPObjYCorSearchBkDeltaXDis) {
        // Just use the nearest dis with high priority.
        ObjIndex = ObjIndex3;
      }
    }

    if (ObjIndex >= ObjPtCnt) {

      // from ObjIndex4 searching back.
      ObjIndex = ObjIndex4;
      Dis2     = pSDGObjPtBuf->ObjPtBuf[ObjIndex4].Pt.x - ObjPt2X;

      // PrevCarAng = PI / 2.0;
      CarPosMax1.x = USSPar.TrajCalCarEndPos.Coordinate.x - APACal.APASlotCorPRecalObj2YCarPosXMinDeltaDisToEndPosX;

      while (ObjIndex4 > 0) {
        ObjIndex4--;

#if 0
				if(MATH_FABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng - PrevCarAng)
						> (10.0 * PI / 180.0)) {
					PrevCarAng = pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng;
					CarPosMax1.x = APASlotProcInSlotCalculateSlotBorderLineGetMaxCarPosXWithCarAng(
							PrevCarAng,
							APASnsIndex);
					CarPosMax1.x -= APACal.APASlotCorPRecalObj2YCarPosXMinDeltaDisToEndPosX;
				}
#endif

        if (bObj2Exist == FALSE) {
          ObjExistMaxSnsDtDis = APASlotProcCorrectSlotPGetObj2ExistMaxSnsDtDis(APACal.APASlotCorPRecalObjYMaxSnsDtDisEndPosCloseToObj1or2,
                                                                               APACal.APASlotCorPRecalObjYExistMaxSnsDtDis,
                                                                               pSDGObjPtBuf->ObjPtBuf[ObjIndex4].CarPos.Coordinate);
        } else {
          ObjExistMaxSnsDtDis = APACal.APASlotCorPObj2YCorObj2ExistAllowMaxSnsDtDis;
        }

        if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex4].ObjDis < ObjExistMaxSnsDtDis) &&
            ((pSDGObjPtBuf->ObjPtBuf[ObjIndex4].ObjDis - SnsDtNearestDis2) < 400) // 40cm max delta dis.
            && ((pSDGObjPtBuf->ObjPtBuf[ObjIndex4].CarPos.Coordinate.x > CarPosMin1.x) &&
                (pSDGObjPtBuf->ObjPtBuf[ObjIndex4].CarPos.Coordinate.x < CarPosMax1.x) &&
                (pSDGObjPtBuf->ObjPtBuf[ObjIndex4].CarPos.Coordinate.y > CarPosMin1.y) &&
                (pSDGObjPtBuf->ObjPtBuf[ObjIndex4].CarPos.Coordinate.y < CarPosMax1.y) &&
                (pSDGObjPtBuf->ObjPtBuf[ObjIndex4].CarPos.CarAng > APACal.APASlotCorPRecalObj2YMinCarAng) &&
                (pSDGObjPtBuf->ObjPtBuf[ObjIndex4].CarPos.CarAng < APACal.APASlotCorPRecalObj2YMaxCarAng))) {

          Dis1 = pSDGObjPtBuf->ObjPtBuf[ObjIndex4].Pt.x - ObjPt2X;
          if (Dis1 > APACal.APASlotCorPObjYCorSearchBkDeltaXDis) {
            if (Dis2 > ObjPtXSearchBkMinDeltaDis) {
              break;
            }
            Dis2 = APACal.APASlotCorPObjYCorSearchBkDeltaXDis - Dis2;
            Dis1 = Dis1 - APACal.APASlotCorPObjYCorSearchBkDeltaXDis;
            if (Dis2 < Dis1) {
              break;
            } else {
              ObjIndex = ObjIndex4;
            }
            break;
          }
          ObjIndex = ObjIndex4;
          Dis2     = Dis1;
        }
      }
    }

    ObjPt2Y = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y;
    if ((ObjPt2Y < APA_SLOT_PER_OBJ2Y_CORRECT_OBJ_Y_MAX) && (ObjPt2Y > APA_SLOT_PER_OBJ2Y_CORRECT_OBJ_Y_MIN)) {
      // Recorrect the slot length.

      // Compensate the Obj2Y according to the car angle.

      // Check if it is a car or a big object,
      // if yes, compensate the obj2y.
      Dis1 = USSPar.TrajCalObj2Pos.x;
      Dis2 = USSPar.TrajCalObj2Pos.y;
      for (ObjIndex2 = 0; ObjIndex2 < ObjPtCnt; ObjIndex2++) {
        if (pSDGObjPtBuf->ObjPtBuf[ObjIndex2].ObjDis != NO_OBJ_DISTANCE) {
          if (MATH_ABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.y - Dis2) < 1500) {
            // OK, Valid obj. < 1.5m
            Dis3 = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x - Dis1;
            if (Dis3 > 0) {
              if (Dis3 < 2500) { // 2.5m
                // Obj Pt found
                break;
              }
            } else {
              if (Dis3 > -1000) { // < 1m
                // Obj Pt found
                break;
              }
            }
          }
        }
      }
      bFlag = FALSE; // def to not a big obj.
      if (ObjIndex2 < ObjPtCnt) {
        Dis3 = MATH_ABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x - Dis1);
        if (Dis3 > APACal.APASlotCorPObj2YCorRRSSnsCompMinXYWidth) {
          // Obj.X is large than 100cm.
          //
          bFlag = TRUE;
        }
#if 0
				else {
					Dis3 = MATH_ABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.y - Dis2);
					if(Dis3 > APACal.APASlotCorPObj2YCorRRSSnsCompMinXYWidth) {
						// Obj.y is large than 100cm. 
						// 
						bFlag = TRUE;
					}
				}
				if(bFlag == FALSE) {
					ObjIndex3 = ObjPtCnt - 1;
					while(ObjIndex3 > ObjIndex2) {
						if(pSDGObjPtBuf->ObjPtBuf[ObjIndex3].ObjDis != NO_OBJ_DISTANCE) {
							if(MATH_ABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex3].Pt.y - Dis2) < 1500) {
								// OK, Valid obj. < 1.5m
								Dis3 = pSDGObjPtBuf->ObjPtBuf[ObjIndex3].Pt.x - Dis1;
								if(Dis3 > 0) {
									if(Dis3 < 2500) { // 2.5m
										// Obj Pt found
										break;
									}
								} else {
									if(Dis3 > -1000) { // < 1m
										// Obj Pt found
										break;
									}
								}
							}

						}
						ObjIndex3 --;
					}
					if(ObjIndex3 > ObjIndex2) {
						Dis3 = MATH_ABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex3].Pt.x - Dis1);
						if(Dis3 > APACal.APASlotCorPObj2YCorRRSSnsCompMinXYWidth) {
							// Obj.X is large than 100cm. 
							// 
							bFlag = TRUE;
						} else {
							Dis3 = MATH_ABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex3].Pt.y - Dis2);
							if(Dis3 > APACal.APASlotCorPObj2YCorRRSSnsCompMinXYWidth) {
								// Obj.y is large than 100cm. 
								// 
								bFlag = TRUE;
							}
						}

					}
				}
#endif
      }
      if (bFlag == TRUE) {
        if ((SDGSnsIndex == APA_RRS_SNS_INDEX) &&
            ((CurCarCenterPt.Coordinate.y - pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y) >
             APA_SLOT_PER_OBJ2Y_CORRECT_RRS_CAL_COMPENSATE_DELTA_CAR_POS_Y_MIN) &&
            (MATH_FABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng - USSPar.TrajCalCarEndPos.CarAng) > (20.0 * PI / 180.0))) {
          // Check if it is necessary to compensate the obj2.y
          CarAngTemp = APACal.APASlotCorPObj2YCorRRSSnsCalCompensateMaxCarAng;
          if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng < APACal.APASlotCorPObj2YCorRRSSnsCalCompensateMaxCarAng) {
            ObjPt2Y -= APACal.APASlotCorPObj2YCorRRSSnsCalObj2YCompensateDis;
          } else if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng > (80.0 * PI / 180.0)) {
            // Do not compensate
          } else if (APACal.APASlotCorPObj2YCorRRSSnsCalObj2YCompensateDis > 200) {
            CarAngTemp = APACal.APASlotCorPObj2YCorRRSSnsCalObj2YCompensateDis;
            CarAngTemp = CarAngTemp - (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng - APACal.APASlotCorPObj2YCorRRSSnsCalCompensateMaxCarAng) *
                                          (CarAngTemp - 200) / (80.0 * PI / 180.0 - APACal.APASlotCorPObj2YCorRRSSnsCalCompensateMaxCarAng);

            ObjPt2Y -= CarAngTemp;
          }
        } else {
          CarCornerPt.x = APACal.HalfWidthOfCar;
          CarCornerPt.y = -APACal.LenBetweenRAxisAndRBumper;
          CarPos.x      = pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x;
          CarPos.y      = pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y;
          CarCornerPt   = APATrajCalPointPosWithAngAndCenterPt(CarCornerPt, pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng, CarPos);

          if ((CarCornerPt.y < ObjPt2Y)) {
            CarAngTemp = MATH_FABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng - USSPar.TrajCalCarEndPos.CarAng);
            if (CarAngTemp > (40.0 * PI / 180.0)) {
              // Compensate a dis. 40cm.
              ObjPt2Y += APACal.APASlotCorPObj2YCorRRSSnsCompDisWithDelatCarAng1;
            } else if (CarAngTemp > (10.0 * PI / 180.0)) {
              // 10 ~ 40deg. compensate: 0 ~ 40cm.
              fDis = APACal.APASlotCorPObj2YCorRRSSnsCompDisWithDelatCarAng2;
              fDis = fDis * (CarAngTemp - 10.0 * PI / 180.0) / (40.0 * PI / 180.0 - 10.0 * PI / 180.0);
              ObjPt2Y += fDis;
            }
            Dis1 = ObjPt2Y - ObjPtYMinValue;
            if ((Dis1) > APACal.APASlotCorPObj2YCorAllowObjMaxYAndMinYDeltaDis) {
              ObjPt2Y = ObjPtYMinValue + APACal.APASlotCorPObj2YCorAllowObjMaxYAndMinYDeltaDis;
            }
          }
        }
      }

      SlotLen = ObjPt2Y - USSPar.TrajCalObj1Pos.y;
      // Dis1 = APACal.APASlotPMinSmallSlotLen - SlotLen;
      // if(Dis1 > APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS) {
      // ?? Data error
      // ?? Actually code should never reach.
      // If yes. it may be the Obj2.y compensate to much.
      // Just use the mean value.
      // SlotLen = APACal.APASlotPMinSmallSlotLen;
      // The Obj2.y will compensate back (Dis1 - APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS).
      // ObjPt2Y += (Dis1 - APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS);
      // The Obj1.y will compensate: APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS.
      // USSPar.TrajCalObj1Pos.y = ObjPt2Y - SlotLen;
      // return FALSE;
      //} else
      if (SlotLen < (APACal.WidthOfCar)) {
        // ?? Data error ??

        // SlotLen = APACal.APASlotPMinSmallSlotLen;
        // The Obj1.y will compensate: Dis1.
        // USSPar.TrajCalObj1Pos.y = ObjPt2Y - SlotLen;
        return FALSE;
      } else {
        // The slot length is still within the min small slot len range.
        // OK.
      }

      ObjPt   = USSPar.TrajCalObj2Pos;
      ObjPt.y = ObjPt2Y;
      bFlag   = APASlotProcCheckIfObjPt12IsValid(CurCarCenterPt, &ObjPt, 1);

      /*if(bFlag == FALSE){
       USSPar.TrajCalObj2Pos.y = ObjPt2Y;
       }*/

      if (bObjPtLessThanObj2YFound == TRUE) {
        if ((MATH_FABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng - USSPar.TrajCalCarEndPos.CarAng) >
             APACal.APASlotCorPObj2YCorRegardedAsInvalidObj2YMaxDeltaCarAng1) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < (USSPar.TrajCalObj2Pos.x + APACal.APASlotCorPEndPosYCalObj2YSearchBkStartDeltaXDis))) {
          // May be invalid obj2.
          Dis1 = APASlotCorrectionOriginalObj2Y - ObjPt.y;
          if (MATH_ABS(Dis1) > (APACal.APASlotCorPObj2YCorRegardedAsInvalidObj2YMaxDeltaObj2YDis)) {
            // Invalid obj pt.
            return FALSE;
          }
        }
      }

      if (MATH_FABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng - USSPar.TrajCalCarEndPos.CarAng) >
          APACal.APASlotCorPObj2YCorRegardedAsInvalidObj2YMaxDeltaCarAng2) {
        // The delta car angle is very big.
        if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis > APACal.APASlotCorPObj2YCorRegardedAsInvalidObj2YMaxSnsDtObjDis) {
          // It is an object which may be with great tolerance.
          // Just disable it.
          // regarded as an invalid obj point.
          Dis1 = APASlotCorrectionOriginalObj2Y - ObjPt.y;
          if (MATH_ABS(Dis1) > (APACal.APASlotCorPObj2YCorRegardedAsInvalidObj2YMaxDeltaObj2YDis)) {
            // Invalid obj pt.
            return FALSE;
          }
        }
      }

      bFlag = FALSE;
      if ((CurCarCenterPt.Coordinate.x < USSPar.TrajCalObj2Pos.x) &&
          (CurCarCenterPt.Coordinate.y > (USSPar.TrajCalObj2Pos.y - APACal.APASlotCorPObj2YCorAllowObj2YAndCarPosYDeltaDis)) &&
          (CurCarCenterPt.CarAng < (70.0 * PI / 180.0))) {
        // car is above the obj2.
        // do not correct.
        if (USSPar.TrajCalObj2Pos.y < (ObjPt.y - APACal.APASlotCorPObj2YCorDuringStep2AllowObj2YDeltaDis)) {
          // do not correct.
          // due to the rear corner may hit the obj2 if the obj2 is corrected.
          bFlag = TRUE;
        }
      }

      if (bFlag == FALSE) {

        USSPar.TrajCalObj2Pos.y = ObjPt.y;

        USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist = TRUE;

        // adjust the car end pos.y
        APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(SlotLen, 1);

        return TRUE;
      }
    }
  }

  return FALSE;
}
#endif
/*************************************************************************************************************************************************
 ** Syntax :  APA_ENUM_TYPE APASlotProcCorrectSlotPCheckIfTheObj1Obj2Exist(
 APA_DISTANCE_CAL_FLOAT_TYPE CurCarCenterPtX, APA_ENUM_TYPE SDGSnsIndex) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-7 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
#if Debug_SW_PARKINFUNC
APA_ENUM_TYPE APASlotProcCorrectSlotPCheckIfTheObj1Obj2Exist(APA_DISTANCE_CAL_FLOAT_TYPE CurCarCenterPtX, APA_ENUM_TYPE SDGSnsIndex) {
  // Check if the obj2 exist?
  // return value:
  // 0: does not exist.
  // 1: exist.
  // 2: uncertain.

  APA_ENUM_TYPE ObjIndex;
  APA_DISTANCE_TYPE CarPosMaxX, CarPosStartX, ObjExistMaxSnsDtDis;
  SDGObjPtBufType *pSDGObjPtBuf;

  pSDGObjPtBuf = &SDGObjInfo.SnsObjPtBuf[SDGSnsIndex];

  CarPosStartX = (USSPar.TrajCalCarEndPos.Coordinate.x - APA_SLOT_PER_START_CHECK_OBJ_EXIST_END_POS_DELTA_X);
  if (CurCarCenterPtX < CarPosStartX) {
    // Check if the rear obj is dtd.
    CarPosMaxX = CurCarCenterPtX - APACal.APASlotCorPObjExistMaxSnsDtDis - 300; // 300mm is a safety dis.
    if (CarPosMaxX > CarPosStartX) {
      CarPosMaxX = CarPosStartX;
    }
    ObjIndex = SDGObjInfo.SnsObjPtBuf[SDGSnsIndex].ObjPtCnt;
    while (ObjIndex > 0) {
      ObjIndex--;
      if ((SDGSnsIndex == SDG_RRS_SNS_INDEX) || (SDGSnsIndex == SDG_FRS_SNS_INDEX)) {
        ObjExistMaxSnsDtDis = APASlotProcCorrectSlotPGetObj2ExistMaxSnsDtDis(APACal.APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2,
                                                                             APACal.APASlotCorPObjExistMaxSnsDtDis,
                                                                             pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate);
      } else {
        ObjExistMaxSnsDtDis = APASlotProcCorrectSlotPGetObj1ExistMaxSnsDtDis(APACal.APASlotCorPObjExistMaxSnsDtDisEndPosCloseToObj1or2,
                                                                             APACal.APASlotCorPObjExistMaxSnsDtDis,
                                                                             pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate);
      }
      if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < ObjExistMaxSnsDtDis)) {
        if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x < CarPosMaxX) {
          return 1;
        } else {
          return 2;
        }
      }
    }

    if (APASlotCorrectionFlag.Bits.ObjExistCheckCarHasDrvnOutOfSlotWithCarAngAlmostAch == TRUE) {
      return 0;
    }
  } else {
    // It is hard to check.
  }
  return 2;
}
#endif
/*************************************************************************************************************************************************
 ** Syntax :  APA_DISTANCE_TYPE APASlotProcInSlotCalculateSlotBorderLineGetMaxCarPosXWithCarAng(
 APA_ANGLE_CAL_FLOAT_TYPE CarAng, APA_ENUM_TYPE APASnsIndex) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-8-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

APA_DISTANCE_TYPE APASlotProcInSlotCalculateSlotBorderLineGetMaxCarPosXWithCarAng(APA_ANGLE_CAL_FLOAT_TYPE CarAng, APA_ENUM_TYPE APASnsIndex) {

  APA_DISTANCE_CAL_FLOAT_TYPE fDis1, fDis2;
  APA_ANGLE_CAL_FLOAT_TYPE SnsAng;
  APA_DISTANCE_TYPE MaxCarPosX;
  BOOLEAN bCalPosX;

  MaxCarPosX = (APA_DISTANCE_TYPE)USSPar.TrajCalCarEndPos.Coordinate.x;
  MaxCarPosX -= APACal.APASlotCorPSlotBorderLineFitDeltaCarPosToEndPos;
  bCalPosX = FALSE;
  if ((APASnsIndex == APA_RRS_SNS_INDEX) || (APASnsIndex == APA_RR_SNS_INDEX)) {
    SnsAng = CarAng - 2.0 * PI + APACal.SnsAng[APASnsIndex];
    if (SnsAng < (70.0 * PI / 180.0)) {
      bCalPosX = TRUE;
    } else {
      // Jut use the max end pos.x
    }
  } else {
    SnsAng = 2.0 * PI - CarAng - APACal.SnsAng[APASnsIndex];
    if (APASnsIndex == APA_RLS_SNS_INDEX) {
      if (SnsAng < (80.0 * PI / 180.0)) {
        bCalPosX = TRUE;
      } else {
        // Jut use the max end pos.x
      }
    } else {
      // RLC sns.
      if (SnsAng < PI / 2.0) {
        bCalPosX = TRUE;
      } else {
        // Jut use the max end pos.x
      }
    }
  }
  if (bCalPosX == TRUE) {
    fDis1 = APACal.APASlotCorPSlotBorderLineFitMaxSnsDtDis;
    fDis2 = fDis1 * MATH_COS(SnsAng);
    MaxCarPosX -= (APA_DISTANCE_TYPE)fDis2;
  } else {
    // Jut use the max end pos.x
  }
  return MaxCarPosX;
}
/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcCorrectSlotPReCalObj1YWithSDGBuf(
 APACarCoordinateDataCalFloatType CurCarCenterPt,
 APA_ENUM_TYPE SDGSnsIndex)                                                                                                                   **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-8 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
#if Debug_SW_PARKINFUNC
BOOLEAN APASlotProcCorrectSlotPReCalObj1YWithSDGBuf(APACarCoordinateDataCalFloatType CurCarCenterPt, APA_ENUM_TYPE SDGSnsIndex) {

  // Input Par:
  // SDGSnsIndex: SDG_RLS_SNS_INDEX or SDG_FLS_SNS_INDEX (RLC sns)

  // Return value: TRUE: Obj1.y corrected.
  //               FALSE: no corrected.

  APA_ENUM_TYPE ObjPtCnt, ObjIndex, ObjIndex2, ObjIndex3;
  APA_DISTANCE_TYPE ObjPt1Y, SlotLen, Dis1, Dis2, ObjPt1X;
  APACoordinateDataCalFloatType ObjPt;
  APACoordinateDataType CarPosMax1, CarPosMin1;
  APA_DISTANCE_TYPE ObjPtMaxX2, ObjExistMaxSnsDtDis, Obj1MaxYSearchMinObjPtX;
  BOOLEAN bFlag;
  APA_DISTANCE_TYPE SnsDtNearestDis;
  // APA_ANGLE_CAL_FLOAT_TYPE PrevCarAng;

  APA_ENUM_TYPE APASnsIndex;

  SDGObjPtBufType *pSDGObjPtBuf;

  pSDGObjPtBuf = &SDGObjInfo.SnsObjPtBuf[SDGSnsIndex];

  ObjPtCnt = pSDGObjPtBuf->ObjPtCnt;

  if (ObjPtCnt < 1) {
    return FALSE;
  }

  if (SDGSnsIndex == SDG_RLS_SNS_INDEX) {
    APASnsIndex = APA_RLS_SNS_INDEX;
  } else {
    APASnsIndex = APA_RL_SNS_INDEX;
  }

  if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE) {
    ObjPtMaxX2              = USSPar.TrajCalObj1Pos.x + APACal.APASlotCorPObjYCorSearchBkDeltaXDis;
    Obj1MaxYSearchMinObjPtX = USSPar.TrajCalObj1Pos.x + APACal.APASlotCorPEndPosYCalObj1YSearchBkStartDeltaXDis;
  } else {
    Obj1MaxYSearchMinObjPtX = 0;

    ObjPtMaxX2 = APASlotProcInSlotCalculateSlotBorderLineGetMaxCarPosXWithCarAng(CurCarCenterPt.CarAng, APASnsIndex);

    // if(SDGSnsIndex == SDG_RLS_SNS_INDEX){
    //	ObjPtMaxX2 = CarPosMax1.x - APACal.APASlotCorPObjExistMaxSnsDtDis / 2;
    //} else {
    //	ObjPtMaxX2 = CarPosMax1.x - APACal.APASlotCorPObjExistMaxSnsDtDis;
    //}
  }

  CarPosMin1.x = APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_X_MIN1;
  CarPosMin1.y = APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MIN1;
  // CarPosMax1.x = APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_X_MAX1;
  CarPosMax1.y = APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MAX1;

  ObjIndex  = ObjPtCnt;
  ObjIndex2 = ObjPtCnt;
  ObjIndex3 = ObjPtCnt;
  // PrevCarAng = PI / 2.0;
  CarPosMax1.x    = USSPar.TrajCalCarEndPos.Coordinate.x - APACal.APASlotCorPRecalObj1YCarPosXMinDeltaDisToEndPosX;
  SnsDtNearestDis = NO_OBJ_DISTANCE;
  while (ObjIndex > 0) {
    ObjIndex--;
    if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x > Obj1MaxYSearchMinObjPtX) {
      ObjExistMaxSnsDtDis = APASlotProcCorrectSlotPGetObj1ExistMaxSnsDtDis(APACal.APASlotCorPRecalObjYMaxSnsDtDisEndPosCloseToObj1or2,
                                                                           APACal.APASlotCorPRecalObjYExistMaxSnsDtDis,
                                                                           pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate);
      if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < ObjExistMaxSnsDtDis) {
#if 0
				if(MATH_FABS(pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng - PrevCarAng)
						> (10.0 * PI / 180.0)) {
					PrevCarAng = pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng;
					CarPosMax1.x = APASlotProcInSlotCalculateSlotBorderLineGetMaxCarPosXWithCarAng(
							PrevCarAng,
							APASnsIndex);
					CarPosMax1.x -= APACal.APASlotCorPRecalObj1YCarPosXMinDeltaDisToEndPosX;
				}
#endif

        if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x > CarPosMin1.x) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x < CarPosMax1.x) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y > CarPosMin1.y) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y < CarPosMax1.y) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng > APACal.APASlotCorPRecalObj1YMinCarAng) &&
            (pSDGObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng < APACal.APASlotCorPRecalObj1YMaxCarAng)) {
          ObjIndex2 = ObjIndex;
          if (pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < SnsDtNearestDis) {
            ObjIndex3       = ObjIndex;
            SnsDtNearestDis = pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis;
          }

          if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == FALSE) {

            // Actually code should never reach.
            // but just incase.
            ObjPt1X = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x;
            bFlag   = FALSE;
            if (APASnsIndex == APA_RL_SNS_INDEX) {
              // Corner Sensor.
              Dis2 = USSPar.TrajCalObj1Pos.x;
              Dis1 = Dis2 - ObjPt1X;
              if (Dis1 < 1500) {
                // corner Sensor FOV width.
                // Just keep the previous Obj1.X
                ObjPt1X = Dis2;
                bFlag   = TRUE;
              }
            } else {
              // side Sensor.
              Dis2 = USSPar.TrajCalObj1Pos.x;
              Dis1 = Dis2 - ObjPt1X;
              if (Dis1 < 900) {
                // side Sensor FOV width.
                // Just keep the previous Obj1.X
                ObjPt1X = Dis2;
                bFlag   = TRUE;
              }
            }

            if (bFlag == FALSE) {

              USSPar.TrajCalObj1Pos.x = ObjPt1X;
              // APASlotCorrectionIndicationFlag.Bits.Obj1XChanged = TRUE;
              // APASlotCorrectionFlag.Bits.Obj1XHasbeenCorrectedWhenObj1DoesNotExist = TRUE;
              USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist = TRUE;
            }
            // Actually it is hard to determine the exact obj.x, do not adjust the endpos.x
#if 0
						// adjust the car end pos.x
						if((bAPATrajCalCarParkAlongCurb == FALSE)
								&& (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE)) {
							Dis1 = USSPar.TrajCalObj2Pos.x;
							Dis1 -= ObjPt1X;
							if(Dis1 < 0) {
								Dis1 = -Dis1;
							}
							if(Dis1 < APACal.APATrajCalPCalCarEndPosXWithMeanValueAllowObj1Obj2MaxOffsetDis) {

								USSPar.TrajCalCarEndPos.Coordinate.x =
								(USSPar.TrajCalObj1Pos.x + USSPar.TrajCalObj2Pos.x) / 2.0 + APACal.LenBetweenRAxisAndFBumper;
								APASlotCorrectionIndicationFlag.Bits.CarEndPosXChanged = TRUE;

								USSPar.SlotCarEndPosXPrevValue = USSPar.TrajCalCarEndPos.Coordinate.x;
							}

						}
#endif

            ObjPtMaxX2 = ObjPt1X + APACal.APASlotCorPObjYCorSearchBkDeltaXDis;
          }
        }
      }
      if ((ObjIndex2 != ObjPtCnt) && (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x > ObjPtMaxX2)) {
        // Searching over.
        break;
      }
    }
  }

  // check which point is more optimal to cal the obj1.y

  if (ObjIndex2 < ObjPtCnt) {
    // OK ,
    // Check if the point is within optimal range.
    if (ObjIndex3 < ObjPtCnt) {
      ObjIndex = ObjIndex3;
    } else {
      ObjIndex = ObjIndex2;
    }

    ObjPt1X = (USSPar.TrajCalObj1Pos.x);
#if 0
		if(ObjIndex3 >= ObjPtCnt) {
			//ObjIndex = ObjIndex2;
		} else {
			Dis1 = pSDGObjPtBuf->ObjPtBuf[ObjIndex3].Pt.x - ObjPt1X;
			Dis2 = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x - ObjPt1X;
			Dis1 = APACal.APASlotCorPObjYCorSearchBkDeltaXDis - Dis1;
			Dis2 = Dis2 - APACal.APASlotCorPObjYCorSearchBkDeltaXDis;
			if(Dis1 <= Dis2) {
				ObjIndex = ObjIndex3;
			} else {
				//ObjIndex = ObjIndex2;
			}
		}
#endif

    ObjPt1Y = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y;

#if 0
		// Check if it is necessary to compensate the objPt1Y.
		if((CurCarCenterPt.Coordinate.y < - 500)
				&& (CurCarCenterPt.Coordinate.x > 0)
				&& (CurCarCenterPt.Coordinate.x < 1500)
				&& (CurCarCenterPt.Coordinate.y > USSPar.TrajCalObj1Pos.y)
				&& (CurCarCenterPt.CarAng > 30.0 * PI / 180.0)
				&& (CurCarCenterPt.CarAng < 80.0 * PI / 180.0)
		) {
			//RearSnsDtMinDis = USSPar.ParkProcRearSnsDtdNearestDis;
			if(USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
				RLSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX];
				RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
				RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
			} else {
				RLSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX];
				RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
				RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
			}

			if((RLSnsDtDis != NO_OBJ_DISTANCE)
					&& (RRMSnsDtDis != NO_OBJ_DISTANCE)
					&& (RLMSnsDtDis != NO_OBJ_DISTANCE)
					&& (RLMSnsDtDis > RLSnsDtDis)
					&& (RRMSnsDtDis > RLMSnsDtDis)
					&& (RRMSnsDtDis - RLSnsDtDis) < 100) {
				//RLSnsDtDis *= 10; // cm -> mm.
				//RRMSnsDtDis *= 10; // cm -> mm.
				//RLMSnsDtDis *= 10; // cm -> mm.
				// Just compensate the obj1.y
				ObjPt1Y += 600;// 60cm.
			}

		}
#endif

    if ((ObjPt1Y < APA_SLOT_PER_OBJ1Y_CORRECT_OBJ_Y_MAX) && (ObjPt1Y > APA_SLOT_PER_OBJ1Y_CORRECT_OBJ_Y_MIN)) {
      // Recorrect the slot length.

#if 0
			SlotLen = USSPar.TrajCalObj1Pos.y - ObjPt1Y;
			SlotLen += USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength;
			Dis1 = APACal.APASlotPMinSmallSlotLen - SlotLen;
			if(Dis1 > APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS) {
				// ?? Data error
				// ?? Actually code should never reach.
				// If yes. it may be the Obj1.y compensate to much.
				// Just use the mean value.
				/*SlotLen = APACal.APASlotPMinSmallSlotLen;
				 // The Obj1.y will compensate back (Dis1 - APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS).
				 ObjPt1Y -= (Dis1 - APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS);
				 // The Obj2.y will compensate: APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS.
				 USSPar.TrajCalObj2Pos.y = ObjPt1Y + SlotLen;*/
				return FALSE;
			} else if(SlotLen < (APACal.WidthOfCar)) {
				// ?? Data error ??

				//SlotLen = APACal.APASlotPMinSmallSlotLen;
				// The Obj1.y will compensate: Dis1.
				//USSPar.TrajCalObj2Pos.y = ObjPt1Y + SlotLen;
				return FALSE;
			} else {
				// The slot length is still within the min small slot len range.
				// OK.
			}
#else

      SlotLen = USSPar.TrajCalObj2Pos.y - ObjPt1Y;
      if (SlotLen < (APACal.WidthOfCar)) {
        // ?? Data error ??

        // SlotLen = APACal.APASlotPMinSmallSlotLen;
        // The Obj1.y will compensate: Dis1.
        // USSPar.TrajCalObj2Pos.y = ObjPt1Y + SlotLen;
        return FALSE;
      } else {
        // The slot length is still within the min small slot len range.
        // OK.
      }
#endif
#ifdef Mike_Yi_Debug
      DebugDistance = ObjPt1Y;
#endif
      ObjPt   = USSPar.TrajCalObj1Pos;
      ObjPt.y = ObjPt1Y;
      bFlag   = APASlotProcCheckIfObjPt12IsValid(CurCarCenterPt, &ObjPt, 0);

      /*if(bFlag == FALSE){
       USSPar.TrajCalObj2Pos.y = ObjPt2Y;
       }*/
      USSPar.TrajCalObj1Pos.y = ObjPt.y;

      // USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist = TRUE;

      // adjust the car end pos.y
      APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(SlotLen, 0);

      return TRUE;
    }
  }

  return FALSE;
}
#endif
/*************************************************************************************************************************************************
 ** Syntax :  APA_ANGLE_CAL_FLOAT_TYPE APASlotPCorCorSnsDisCompensatCalculation(
 APA_ENUM_TYPE DeltaAngIndex, APA_ENUM_TYPE ObjDisIndex,
 APA_ENUM_TYPE CorSnsIndex, APA_ANGLE_CAL_FLOAT_TYPE DeltaAng,
 APA_DISTANCE_TYPE ObjDis, APA_ENUM_TYPE CorOrSideSnsIndex,
 BOOLEAN bCompDisMethodFlag)                                                                                                                   **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-9 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
APA_ANGLE_CAL_FLOAT_TYPE APASlotPCorCorSnsDisCompensatCalculation(APA_ENUM_TYPE DeltaAngIndex,
                                                                  APA_ENUM_TYPE ObjDisIndex,
                                                                  APA_ENUM_TYPE CorSnsIndex,
                                                                  APA_ANGLE_CAL_FLOAT_TYPE DeltaAng,
                                                                  APA_DISTANCE_TYPE ObjDis,
                                                                  APA_ENUM_TYPE CorOrSideSnsIndex,
                                                                  BOOLEAN bCompDisMethodFlag) {
  APA_ANGLE_CAL_FLOAT_TYPE X1, X2, Y1, Y2;
  APA_ANGLE_CAL_FLOAT_TYPE Y_D1, Y_D2, CorSnsDisCompensationAng;

  if (bCompDisMethodFlag == FALSE) {
    if (((DeltaAngIndex == 0) || (DeltaAngIndex == (APACal.APASlotPCorRROrRLDeltaAngBetweenCurAngAndEndAng.APASlotPCorDeltaAngZoneNum))) &&
        ((ObjDisIndex == 0) || (ObjDisIndex == (APA_SLOT_P_COR_SNS_DIS_DIV_NUM - 1)))) {
      CorSnsDisCompensationAng = APACal.APASlotPCorCorSnsCompensatAngByDeltaAngAndSnsDtObjDis[CorSnsIndex][DeltaAngIndex][ObjDisIndex];
    } else {
      if ((DeltaAngIndex == 0) || (DeltaAngIndex == APACal.APASlotPCorRROrRLDeltaAngBetweenCurAngAndEndAng.APASlotPCorDeltaAngZoneNum)) {
        Y_D1                     = APACal.APASlotPCorCorSnsCompensatAngByDeltaAngAndSnsDtObjDis[CorSnsIndex][DeltaAngIndex][ObjDisIndex - 1];
        Y_D2                     = APACal.APASlotPCorCorSnsCompensatAngByDeltaAngAndSnsDtObjDis[CorSnsIndex][DeltaAngIndex][ObjDisIndex];
        X1                       = APACal.APASlotPCorCorOrSideSnsDisArray[CorSnsIndex][ObjDisIndex - 1];
        X2                       = APACal.APASlotPCorCorOrSideSnsDisArray[CorSnsIndex][ObjDisIndex];
        CorSnsDisCompensationAng = APATrajCalTwoPointInterpolationCalculation(Y_D1, Y_D2, X1, X2, ObjDis);
      } else {
        if ((ObjDisIndex == 0) || (ObjDisIndex == (APA_SLOT_P_COR_SNS_DIS_DIV_NUM - 1))) {
          Y_D1 = APACal.APASlotPCorCorSnsCompensatAngByDeltaAngAndSnsDtObjDis[CorSnsIndex][DeltaAngIndex - 1][ObjDisIndex];
          Y_D2 = APACal.APASlotPCorCorSnsCompensatAngByDeltaAngAndSnsDtObjDis[CorSnsIndex][DeltaAngIndex][ObjDisIndex];
        } else {
          Y1   = APACal.APASlotPCorCorSnsCompensatAngByDeltaAngAndSnsDtObjDis[CorSnsIndex][DeltaAngIndex][ObjDisIndex - 1];
          Y2   = APACal.APASlotPCorCorSnsCompensatAngByDeltaAngAndSnsDtObjDis[CorSnsIndex][DeltaAngIndex][ObjDisIndex];
          X1   = APACal.APASlotPCorCorOrSideSnsDisArray[CorOrSideSnsIndex][ObjDisIndex - 1];
          X2   = APACal.APASlotPCorCorOrSideSnsDisArray[CorOrSideSnsIndex][ObjDisIndex];
          Y_D1 = APATrajCalTwoPointInterpolationCalculation(Y1, Y2, X1, X2, ObjDis);
          Y1   = APACal.APASlotPCorCorSnsCompensatAngByDeltaAngAndSnsDtObjDis[CorSnsIndex][DeltaAngIndex - 1][ObjDisIndex - 1];
          Y2   = APACal.APASlotPCorCorSnsCompensatAngByDeltaAngAndSnsDtObjDis[CorSnsIndex][DeltaAngIndex - 1][ObjDisIndex];
          Y_D2 = APATrajCalTwoPointInterpolationCalculation(Y1, Y2, X1, X2, ObjDis);
        }
        X1                       = APACal.APASlotPCorRROrRLDeltaAngBetweenCurAngAndEndAng.APASlotPCorDeltaAngArray[DeltaAngIndex - 1];
        X2                       = APACal.APASlotPCorRROrRLDeltaAngBetweenCurAngAndEndAng.APASlotPCorDeltaAngArray[DeltaAngIndex];
        CorSnsDisCompensationAng = APATrajCalTwoPointInterpolationCalculation(Y_D1, Y_D2, X1, X2, DeltaAng);
      }
    }
  } else {
    if ((DeltaAngIndex == 0) || (DeltaAngIndex == APACal.APASlotPCorRROrRLDeltaAngBetweenCurAngAndEndAng.APASlotPCorDeltaAngZoneNum)) {
      CorSnsDisCompensationAng = APACal.APASlotPCorRROrRLSnsCompensatAngByDeltaAng[CorSnsIndex][DeltaAngIndex];
    } else {
      Y1                       = APACal.APASlotPCorRROrRLSnsCompensatAngByDeltaAng[CorSnsIndex][DeltaAngIndex - 1];
      Y2                       = APACal.APASlotPCorRROrRLSnsCompensatAngByDeltaAng[CorSnsIndex][DeltaAngIndex];
      X1                       = APACal.APASlotPCorRROrRLDeltaAngBetweenCurAngAndEndAng.APASlotPCorDeltaAngArray[DeltaAngIndex - 1];
      X2                       = APACal.APASlotPCorRROrRLDeltaAngBetweenCurAngAndEndAng.APASlotPCorDeltaAngArray[DeltaAngIndex];
      CorSnsDisCompensationAng = APATrajCalTwoPointInterpolationCalculation(Y1, Y2, X1, X2, DeltaAng);
    }
  }

  return CorSnsDisCompensationAng;
}
/*************************************************************************************************************************************************
 ** Syntax :  void USS(void)                                                                                                                     **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-10-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
BOOLEAN APASlotProcPInSlotFitSlotBorderLineCheckIfPointIsWithinLineTol(
    APALineParameterABCType *pBorderLine,
    SDGObjPtBufType *pSDGObjPtBuf,
    APA_INDEX_TYPE *pValidObjPtIndexBuf,
    APA_INDEX_TYPE *pNewValidObjPtIndexBuf,
    APA_INDEX_TYPE *pNewValidObjPtCnt,
    APA_DISTANCE_TYPE AllowMinLineDeltaYTol,
    APA_INDEX_TYPE StartPtIndex,
    APA_INDEX_TYPE EndPtIndex,
    APA_DISTANCE_TYPE StopCheckObjPtWithinTolObjPtX, // Obj Pt.x < this value will not be checked.
    BOOLEAN bRightSideLine,
    BOOLEAN bSaveObjPtWithinTol,
    APA_INDEX_TYPE CheckMode) {

  // bSaveObjPtWithinTol:
  // FALSE: no save.
  // TRUE: save the obj pt within the tol into the pNewValidObjPtIndexBuf.

  // Check Mode:
  // 0 - within the -5cm ~ + 5cm tolerance. AllowMinLineDeltaYTol = +5cm.
  // 1 - great than -5cm. // check if it is convex shape. AllowMinLineDeltaYTol = -5cm.
  // 2 - less than +5cm. // check if it is concave shape. AllowMinLineDeltaYTol = +5cm.
  // 3 - within the -5cm ~ + 5cm tolerance. line with convex or concave at head, AllowMinLineDeltaYTol = +5cm.
  // 4 - within the -5cm ~ + 5cm tolerance. line with convex or concave at mid, AllowMinLineDeltaYTol = +5cm.
  // 5 - within the -5cm ~ + 5cm tolerance. line with convex or concave at tail, AllowMinLineDeltaYTol = +5cm.

  APA_DISTANCE_CAL_FLOAT_TYPE fDis1;
  APA_INDEX_TYPE g, k, ValidObjPtCnt;
  APA_DISTANCE_TYPE Dis1, Dis2, Dis3, ObjPtX, StartPtX, StartPtY, WithinTolLineLen;
  BOOLEAN bFlag, bFlag1, bFlag2;
  APA_INDEX_TYPE OutOfTolPtStartIndex, OutOfTolPtCheckSeq;
  APA_ANGLE_CAL_FLOAT_TYPE DeltaAng, AngTemp, LineEndPtCarAng, LineStartPtCarAng, DeltaLineAndEndPosAng;

  bFlag                = TRUE;
  bFlag1               = TRUE;
  bFlag2               = FALSE;
  OutOfTolPtCheckSeq   = 0;
  ValidObjPtCnt        = 0;
  OutOfTolPtStartIndex = 0;
  WithinTolLineLen     = 0;

  k                     = pValidObjPtIndexBuf[StartPtIndex];
  StartPtX              = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
  StartPtY              = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
  LineStartPtCarAng     = pSDGObjPtBuf->ObjPtBuf[k].CarPos.CarAng;
  k                     = pValidObjPtIndexBuf[EndPtIndex];
  LineEndPtCarAng       = pSDGObjPtBuf->ObjPtBuf[k].CarPos.CarAng;
  DeltaLineAndEndPosAng = MATH_ATAN(pBorderLine->A) + PI / 2.0;
  DeltaLineAndEndPosAng -= USSPar.TrajCalCarEndPos.CarAng;
  DeltaLineAndEndPosAng = MATH_FABS(DeltaLineAndEndPosAng);

  for (g = StartPtIndex; g <= EndPtIndex; g++) {
    k      = pValidObjPtIndexBuf[g];
    ObjPtX = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    fDis1  = ObjPtX;
    fDis1  = (pBorderLine->A) * fDis1 + pBorderLine->C; //  Obj Pt.x and the Start and Mid Line Cross Pt.Y
    Dis1   = (fDis1);
    Dis1   = pSDGObjPtBuf->ObjPtBuf[k].Pt.y - Dis1;
    if (CheckMode == 0) {
      if (Dis1 < 0) {
        Dis1 = -Dis1;
      }
      if (Dis1 > AllowMinLineDeltaYTol) {
        // It is an unknown shape??
        // just break;
        if (bSaveObjPtWithinTol == FALSE) {
          return FALSE;
        }
        bFlag = FALSE;
      } else {
        pNewValidObjPtIndexBuf[ValidObjPtCnt] = k;
        ValidObjPtCnt++;
      }
    } else if (CheckMode == 1) {
      if (Dis1 < AllowMinLineDeltaYTol) {
        // 1 - great than -5cm. // check if it is convex shape. AllowMinLineDeltaYTol = -5cm.
        return FALSE;
      }
    } else if (CheckMode == 2) {
      if (Dis1 > AllowMinLineDeltaYTol) {
        // 2 - less than +5cm. // check if it is concave shape. AllowMinLineDeltaYTol = +5cm.
        return FALSE;
      }
    } else if ((CheckMode == 3) || (CheckMode == 4) || (CheckMode == 5)) {
      // 3 - within the -5cm ~ + 5cm tolerance. line with convex or concave at head, AllowMinLineDeltaYTol = +5cm.
      // 4 - within the -5cm ~ + 5cm tolerance. line with convex or concave at mid, AllowMinLineDeltaYTol = +5cm.
      Dis2 = Dis1;
      if (Dis1 < 0) {
        Dis1 = -Dis1;
      }
      if ((Dis1) > AllowMinLineDeltaYTol) {
        // Out of tolerance.
        // It is an unknown shape??
        if (bFlag1 == TRUE) {
          // Check if the line length is large enough.
          if (CheckMode == 3) {
            // Convex or concave at head.
            WithinTolLineLen = (pSDGObjPtBuf->ObjPtBuf[pValidObjPtIndexBuf[StartPtIndex]].Pt.x - ObjPtX);
            if (WithinTolLineLen < APACal.APASlotCorPSlotBorderLineFitRegardAsValidLineMinObjPtDeltaXDis) {
              // line Start pt and end pt delta x < 70cm.
              return FALSE;
            }
          }
        }
        if (OutOfTolPtCheckSeq == 0) {
          OutOfTolPtStartIndex = g;
          OutOfTolPtCheckSeq++;
        }
        bFlag1 = FALSE;
        bFlag2 = TRUE;

        DeltaAng = pSDGObjPtBuf->ObjPtBuf[k].CarPos.CarAng;
        AngTemp  = MATH_FABS(DeltaAng - LineEndPtCarAng);
        DeltaAng = MATH_FABS(DeltaAng - LineStartPtCarAng);
        if (DeltaAng < AngTemp) {
          DeltaAng = AngTemp;
        }

        if (Dis2 > 0) {
          // the bd line is under of the obj pt.

          if (bRightSideLine == FALSE) {
            // Left side line. convex point.
            if (((WithinTolLineLen / AllowMinLineDeltaYTol) > APACal.APASlotCorPSlotBorderLineFitRegardAsWihinTolBigLineLenRatio) ||
                (DeltaLineAndEndPosAng < APACal.APASlotCorPSlotBorderLineFitUseBigTolMaxDeltaLineAndEndPosAng)) {
              // within tol line length is very big. or delta fitted line and end pos angle is small.
              // use big tolerance. 70cm.
              Dis2 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineConvexDeltaYTol2;
            } else {
              // Use small tolerance. 40cm.
              Dis2 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineConvexDeltaYTol1;
            }
            if (Dis1 > Dis2) {
              // > 40cm,
              return FALSE;
            }
          } else {
            // Right side line. concave point.
            if (ObjPtX > StopCheckObjPtWithinTolObjPtX) {
              // > Obj1 or Obj2.X + 100cm,
              if (DeltaAng > (15.0 * PI / 180.0)) {
                if (Dis1 > (APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineConcaveDeltaYTol2)) {
                  // > 30cm,
                  return FALSE;
                }
              } else {
                if (Dis1 > APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineConcaveDeltaYTol1) {
                  // > 20cm,
                  return FALSE;
                }
              }
            }
          }
        } else {
          // the bd line is at the above of the obj pt.
          if (bRightSideLine == FALSE) {
            // Left side line. concave point
            if (ObjPtX > StopCheckObjPtWithinTolObjPtX) {
              // > Obj1 or Obj2.X + 100cm,
              if (Dis1 > APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineConcaveDeltaYTol1) {
                // > 20cm,
                return FALSE;
              }
            }
          } else {
            // Right side line. convex point

            if (((WithinTolLineLen / AllowMinLineDeltaYTol) > APACal.APASlotCorPSlotBorderLineFitRegardAsWihinTolBigLineLenRatio) ||
                (DeltaLineAndEndPosAng < APACal.APASlotCorPSlotBorderLineFitUseBigTolMaxDeltaLineAndEndPosAng)) {
              // within tol line length is very big. or delta fitted line and end pos angle is small.
              // use big tolerance. 70cm.
              Dis2 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineConvexDeltaYTol2;
            } else {
              // Use small tolerance. 40cm.
              Dis2 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineConvexDeltaYTol1;
            }

            if (DeltaAng > (15.0 * PI / 180.0)) {
              if (Dis1 > APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineConvexDeltaYTol2) {
                // > 70cm,
                return FALSE;
              }
            } else {
              if (Dis1 > Dis2) {
                // > 40cm,
                return FALSE;
              }
            }
          }
        }
      } else {
        // within tolerance.
        if (CheckMode == 3) {
          if (bFlag1 == TRUE) {
            Dis3 = MATH_ABS(pSDGObjPtBuf->ObjPtBuf[k].Pt.x - StartPtX);
            if (Dis3 < APACal.APASlotCorPSlotBorderLineFitLineWithConvexAtHeadAllowMaxLineLen) {
              Dis2 = MATH_ABS(pSDGObjPtBuf->ObjPtBuf[k].Pt.y - StartPtY);
              if (Dis2 < APACal.APASlotCorPSlotBorderLineFitLineWithConvexAtHeadAllowMaxLineLen) {
                Dis3 += Dis2;
                Dis3 *= 7;
                Dis3 /= 10; // => (X + Y) * 0.7 = sqrt(X*X + Y*Y) line len
                if (Dis3 < APACal.APASlotCorPSlotBorderLineFitLineWithConvexAtHeadAllowMaxLineLen) {
                  pNewValidObjPtIndexBuf[ValidObjPtCnt] = k;
                  ValidObjPtCnt++;
                }
              }
            }
          }
        } else {
          if (OutOfTolPtCheckSeq == 1) {
            // Check the convex or concave width.
            OutOfTolPtCheckSeq = 0;
            Dis1               = APATrajCalGetTwoPointDisInt(pSDGObjPtBuf->ObjPtBuf[pValidObjPtIndexBuf[OutOfTolPtStartIndex]].Pt.x,
                                               pSDGObjPtBuf->ObjPtBuf[pValidObjPtIndexBuf[OutOfTolPtStartIndex]].Pt.y,
                                               pSDGObjPtBuf->ObjPtBuf[k].Pt.x,
                                               pSDGObjPtBuf->ObjPtBuf[k].Pt.y);
            if (Dis1 > APACal.APASlotCorPSlotBorderLineFitAllowMaxConvexWidthAtMidOfLine) {
              // The convex or concave width at mid is great than the allow len: 80cm,
              return FALSE;
            }
          }
          if (CheckMode == 4) {
            pNewValidObjPtIndexBuf[ValidObjPtCnt] = k;
            ValidObjPtCnt++;
          } else {
            if (bFlag2 == TRUE) {
              pNewValidObjPtIndexBuf[ValidObjPtCnt] = k;
              ValidObjPtCnt++;
            }
          }
        }
      }
    }
  }

  (*pNewValidObjPtCnt) = ValidObjPtCnt;
  return bFlag;
}
/*************************************************************************************************************************************************
 ** Syntax :  void USS(void)                                                                                                                     **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-10-2-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

APA_ENUM_TYPE APASlotProcPInSlotFitSlotBorderLineCheckIfLineEndPtToCarPosEndIsWithinTol(
    SDGObjPtBufType *pSDGObjPtBuf,
    APA_DISTANCE_TYPE *pLineLen,
    APA_DISTANCE_TYPE AllowWithoutDtdObjToCarDrvMaxPosXDis,
    APA_DISTANCE_TYPE RegardAsCarMinObjBdWidth,
    APA_INDEX_TYPE ObjBdStartIndex,
    APA_INDEX_TYPE ObjBdEndIndex,
    APA_INDEX_TYPE ObjPtStartIndex, // from car end pos, the first valid obj point index.
    APA_INDEX_TYPE CarPosEndIndex   // Include no obj point index.
) {
  //
  // return value:
  // 0 - Out of tolerance.
  // 1 - Obj border line length is big: eg. > 3.5m
  // 2 - Obj border line length is not big but Line End Pt to car pos max (end) is not big:
  // eg. < 80cm,

  APA_DISTANCE_TYPE Dis1;

  // 1. check obj bd width
  Dis1 = APATrajCalGetTwoPointDisInt(pSDGObjPtBuf->ObjPtBuf[ObjBdStartIndex].Pt.x,
                                     pSDGObjPtBuf->ObjPtBuf[ObjBdStartIndex].Pt.y,
                                     pSDGObjPtBuf->ObjPtBuf[ObjBdEndIndex].Pt.x,
                                     pSDGObjPtBuf->ObjPtBuf[ObjBdEndIndex].Pt.y);

  if (Dis1 > RegardAsCarMinObjBdWidth) {
    // LineLen is OK.
    return 1;
  }
  (*pLineLen) = Dis1;

  if (CarPosEndIndex == ObjPtStartIndex) {
    return 2;
  }

  Dis1 = APATrajCalGetTwoPointDisInt(pSDGObjPtBuf->ObjPtBuf[CarPosEndIndex].CarPos.Coordinate.x,
                                     pSDGObjPtBuf->ObjPtBuf[CarPosEndIndex].CarPos.Coordinate.y,
                                     pSDGObjPtBuf->ObjPtBuf[ObjPtStartIndex].CarPos.Coordinate.x,
                                     pSDGObjPtBuf->ObjPtBuf[ObjPtStartIndex].CarPos.Coordinate.y);

  if (Dis1 < AllowWithoutDtdObjToCarDrvMaxPosXDis) {
    // LineLen is OK.
    return 2;
  }

  return 0;
}
/*************************************************************************************************************************************************
 ** Syntax : APA_ANGLE_CAL_FLOAT_TYPE APASlotProcInSlotCalculateSlotBorderLineGetSnsAndBorderLineDeltaAng(
 APA_ANGLE_CAL_FLOAT_TYPE CarAng, APA_ANGLE_CAL_FLOAT_TYPE BorderLineAng, // > -90 and < 90.
 APA_ENUM_TYPE APASnsIndex)                                                                                                                     **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-10-2-2-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
APA_ANGLE_CAL_FLOAT_TYPE
APASlotProcInSlotCalculateSlotBorderLineGetSnsAndBorderLineDeltaAng(APA_ANGLE_CAL_FLOAT_TYPE CarAng,
                                                                    APA_ANGLE_CAL_FLOAT_TYPE BorderLineAng, // > -90 and < 90.
                                                                    APA_ENUM_TYPE APASnsIndex) {
  // Delta Ang :

  /*
   RRS, RRC Sns:
   / \
                        / /  \
                      /   /   \
                            /     /    \ Slot border line
   Border line alpha line  /  '-'  /     \
                          |
   Sns center line.

   / \
                     / /    \
                 /   /       \
                     /     /          \ Slot border line
   Sns center line / '+'  /             \
                         |
   Border line alpha line

   RLS, RLC Sns:
   \Slot border line
   \                   / Border line alpha line
   \               /
   \           /
   \      /
   \ /  '-'
   \----------------
   \          |
   \	   Sns center line.

   \Slot border line
   \      Sns center line.
   \     |              / Border line alpha line
   \    | '+'       /
   \   |        /
   \  |     /
   \ |  /
   \|/
   */

  APA_ANGLE_CAL_FLOAT_TYPE DeltaAng;

  if ((APASnsIndex == APA_RRS_SNS_INDEX) || (APASnsIndex == APA_RR_SNS_INDEX)) {
    DeltaAng = 2.5 * PI - CarAng - APACal.SnsAng[APASnsIndex] + BorderLineAng;
  } else {
    DeltaAng = CarAng + APACal.SnsAng[APASnsIndex] - 1.5 * PI - BorderLineAng;
  }
  return DeltaAng;
}

/*************************************************************************************************************************************************
 ** Syntax :  void USS(void)                                                                                                                     **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-10-2-2 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

BOOLEAN APASlotProcPInSlotFitSlotBorderLineByValidObjStartPtAndEndPt(APALineParameterABCType *pBorderLine,
                                                                     SDGObjPtBufType *pSDGObjPtBuf,
                                                                     APA_INDEX_TYPE *pValidObjPtIndexBuf,
                                                                     APA_DISTANCE_TYPE AllowMinLineLen,
                                                                     APA_INDEX_TYPE StartPtIndex,
                                                                     APA_INDEX_TYPE EndPtIndex,
                                                                     BOOLEAN bCompensateBdLineK,
                                                                     BOOLEAN bRightSideBorderLine,
                                                                     APA_INDEX_TYPE APASnsIndex,
                                                                     APA_INDEX_TYPE BdLineDtSnsIndex) {

  APA_DISTANCE_CAL_FLOAT_TYPE mX, mY, mXX, mXY, fTemp, fDis1, fDis2;
  APA_INDEX_TYPE g, k, d, h, m, i;
  APA_DISTANCE_TYPE Dis1;
  APA_DISTANCE_CAL_FLOAT_TYPE DeltaAngBtSnsAngAndBorderLineAngEnd, DeltaAngBtSnsAngAndBorderLineAngSt;
  APA_DISTANCE_CAL_FLOAT_TYPE CompensateLineParCDis;
  APA_ANGLE_CAL_FLOAT_TYPE BorderLineAng, DeltaAng, AngTemp, AngTemp2;
  BOOLEAN bCompensateLineAng;

  d = (EndPtIndex - StartPtIndex) + 1;
  if (d < 3) {
    // At least 3 points.
    // def: 3 // or 4, 5, .... need to be debug in the real car test.
    return FALSE;
  }

  h    = pValidObjPtIndexBuf[StartPtIndex];
  m    = pValidObjPtIndexBuf[EndPtIndex];
  k    = h;
  g    = m;
  Dis1 = APATrajCalGetTwoPointDisInt(
      pSDGObjPtBuf->ObjPtBuf[k].Pt.x, pSDGObjPtBuf->ObjPtBuf[k].Pt.y, pSDGObjPtBuf->ObjPtBuf[g].Pt.x, pSDGObjPtBuf->ObjPtBuf[g].Pt.y);

  if (Dis1 < AllowMinLineLen) {
    // LineLen is too short.
    return FALSE;
  }

  //
  // Y=kX+b)
  // Algorithm Start:

  mX  = 0;
  mY  = 0;
  mXX = 0;
  mXY = 0;
  for (g = StartPtIndex; g <= EndPtIndex; g++) {
    k     = pValidObjPtIndexBuf[g];
    fDis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    fDis2 = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
    mX += fDis1;
    mY += fDis2;
    mXX += fDis1 * fDis1;
    mXY += fDis1 * fDis2;
  }

  // We assume that the line should be constructed by at least 3 points (object points).

  fTemp = d;
  fDis1 = mX * mX - mXX * fTemp;
  if (fDis1 == 0) {
    // data error, just go to next line.
    // Is it a vertical line ???, do we need to check it ????????
    return FALSE;
  }

  fDis2 = (mY * mX - mXY * fTemp) / fDis1; // Line: Y = KX + B => K,

  if ((fDis2 > APACal.APASlotCorPSlotBorderLineFitMaxBdLineAng[BdLineDtSnsIndex]) ||
      (fDis2 < APACal.APASlotCorPSlotBorderLineFitMinBdLineAng[BdLineDtSnsIndex])) {
    return FALSE;
  }

  pBorderLine->A = fDis2;
  pBorderLine->C = (mY - mX * fDis2) / fTemp; // Line: Y = KX + B => B,
  pBorderLine->B = 1.0;

  if (bCompensateBdLineK == TRUE) {
    // According to the debug result, the border line angle is a little big than the
    // Actual value, use the following algorithm to correct:
    // According to the difference between the car ang and the border line angle,
    // Compensate the border line angle, reduce the border line angle.
    //
    BorderLineAng = MATH_ATAN(fDis2);
    DeltaAng      = MATH_FABS(pSDGObjPtBuf->ObjPtBuf[h].CarPos.CarAng - PI / 2.0 - BorderLineAng);
    if (DeltaAng > APACal.APASlotCorPSlotBorderLineFitMaxDeltaCarAngAndBdLineAng) {
      // Data error??
      return FALSE;
    }

#if 1
    i = h;
    for (g = h; g < m; g++) {
      AngTemp = MATH_FABS(pSDGObjPtBuf->ObjPtBuf[g].CarPos.CarAng - PI / 2.0 - BorderLineAng);
      if (AngTemp > DeltaAng) {
        DeltaAng = AngTemp;
        i        = g;
      }
    }
    DeltaAngBtSnsAngAndBorderLineAngEnd = APASlotProcInSlotCalculateSlotBorderLineGetSnsAndBorderLineDeltaAng(
        // pSDGObjPtBuf->ObjPtBuf[m].CarPos.CarAng, BorderLineAng, APASnsIndex); // End Pt Delta Ang.
        pSDGObjPtBuf->ObjPtBuf[i].CarPos.CarAng,
        BorderLineAng,
        APASnsIndex); // End Pt Delta Ang.

    DeltaAngBtSnsAngAndBorderLineAngSt = APASlotProcInSlotCalculateSlotBorderLineGetSnsAndBorderLineDeltaAng(pSDGObjPtBuf->ObjPtBuf[h].CarPos.CarAng,
                                                                                                             BorderLineAng,
                                                                                                             APASnsIndex); // Start Pt Delta Ang.

    bCompensateLineAng = FALSE;

    if ((pSDGObjPtBuf->ObjPtBuf[h].CarPos.Coordinate.x < (USSPar.TrajCalCarEndPos.Coordinate.x - 800)) &&
        (DeltaAng > APACal.APASlotCorPSlotBorderLineFitCompMinStCarAngAndBdLineAng)) {
      bCompensateLineAng = TRUE;
#if 0
			AngTemp = 0;
			for(g = h; g < m; g ++) {
				AngTemp += MATH_FABS(pSDGObjPtBuf->ObjPtBuf[m].CarPos.CarAng - pSDGObjPtBuf->ObjPtBuf[g].CarPos.CarAng);
			}

			AngTemp = AngTemp / ((APA_DISTANCE_CAL_FLOAT_TYPE)(ValidObjCnt - 1));

#else

      AngTemp  = MATH_FABS(DeltaAngBtSnsAngAndBorderLineAngSt);
      AngTemp2 = MATH_FABS(DeltaAngBtSnsAngAndBorderLineAngEnd);
      if (AngTemp > AngTemp2) {
        // Car tail has a great angle than the head.
        AngTemp = AngTemp2;
        if (APASnsIndex == APA_RRS_SNS_INDEX) {
          AngTemp *= APACal.APASlotCorPSlotBorderLineFitCompAngPerDeltaRSideSnsAndBdLineAng;
        } else if (APASnsIndex == APA_RR_SNS_INDEX) {
          AngTemp *= APACal.APASlotCorPSlotBorderLineFitCompAngPerDeltaRCornerSnsAndBdLineAng;
        } else if (APASnsIndex == APA_RLS_SNS_INDEX) {
          AngTemp *= APACal.APASlotCorPSlotBorderLineFitCompAngPerDeltaLSideSnsAndBdLineAng;
        } else {
          AngTemp *= APACal.APASlotCorPSlotBorderLineFitCompAngPerDeltaLCornerSnsAndBdLineAng;
        }
      } else {
        if (APASnsIndex == APA_RRS_SNS_INDEX) {
          AngTemp *= APACal.APASlotCorPSlotBorderLineFitCompAngPerDeltaRSideSnsAndBdLineAng2;
        } else if (APASnsIndex == APA_RR_SNS_INDEX) {
          AngTemp *= APACal.APASlotCorPSlotBorderLineFitCompAngPerDeltaRCornerSnsAndBdLineAng2;
        } else if (APASnsIndex == APA_RLS_SNS_INDEX) {
          AngTemp *= APACal.APASlotCorPSlotBorderLineFitCompAngPerDeltaLSideSnsAndBdLineAng2;
        } else {
          AngTemp *= APACal.APASlotCorPSlotBorderLineFitCompAngPerDeltaLCornerSnsAndBdLineAng2;
        }
      }

#endif

    } else {
      if (bRightSideBorderLine == FALSE) {
        // Left side line
        if (BorderLineAng < 0) {
          bCompensateLineAng = TRUE;
          if (APASnsIndex == APA_RLS_SNS_INDEX) {
            AngTemp = APACal.APASlotCorPSlotBorderLineFitCompAngPerBdLineAngLSideSns;
          } else {
            AngTemp = APACal.APASlotCorPSlotBorderLineFitCompAngPerBdLineAngLCornerSns;
          }
          AngTemp = BorderLineAng * AngTemp;
        } else {
          // AngTemp = - AngTemp;
        }
      } else {
        // Right side line
      }
    }
    if (bCompensateLineAng == TRUE) {
      if (AngTemp > 20.0 * PI / 180.0) {
        AngTemp = 20.0 * PI / 180.0;
      }
      BorderLineAng += AngTemp;

      fDis2 = MATH_TAN(BorderLineAng); // Compensated: K.
    }

    if ((fDis2 > APACal.APASlotCorPSlotBorderLineFitMaxBdLineAng[BdLineDtSnsIndex]) ||
        (fDis2 < APACal.APASlotCorPSlotBorderLineFitMinBdLineAng[BdLineDtSnsIndex])) {
      return FALSE;
    }

    pBorderLine->A = fDis2;

#endif

#if 0
		DeltaAng = MATH_FABS(pSDGObjPtBuf->ObjPtBuf[m].CarPos.CarAng
				- pSDGObjPtBuf->ObjPtBuf[h].CarPos.CarAng);

		// DeltaAng = MATH_FABS(CarAng - PI / 2.0 - BorderLineAng);

		if(DeltaAng > APACal.APASlotCorPSlotBorderLineFitCompMinDeltaCarAngAndBdLineAng) {

			DeltaAng /= 3.0; // Just compensate the 1/3 of the delta angle. ???? Should be debuged in the real car.

			AngTemp = BorderLineAng + DeltaAng;
			if(BorderLineAng > 0.0) {
				if(AngTemp > (70.0 * PI / 180.0)) {
					// It seems compensate too much. do not compensate.
				} else {
					BorderLineAng = AngTemp;
				}
			} else {
				if(AngTemp > 0) {
					// It seems compensate too much.
					BorderLineAng /= 2.0;// Just use half angle.
				} else {
					BorderLineAng = AngTemp;
				}
			}
			fDis2 = MATH_TAN(BorderLineAng); // Compensated: K.
		}
#endif

    // fDis1 = (mY - mX * fDis2) / fTemp; // Line: Y = KX + B => B,
    fDis1 = pBorderLine->C;

    // Step 1.3.2.2: Offset the fit border line.
    /*
     \	   \ *
     \    \
                                            \    \*
     \    \
    Offset border line -> \    \
                                               \  * \ <------- fitted border line.
     \    \
                                                 \   *\
                                                  \    \
                            ^ 		       \    \
                            | 		        \    \
                            | 		         *    \
    Car driving direction	      \	   \*<---- Object Point.

     */

#ifdef APA_SLOT_SUPPORT_SLOT_BORDER_LINE_OFFSET_CAL
    d   = 0x7f; // Invalid index. Indicate the point which the offset line cross.
    mXX = 1000; // 1m,
    for (g = h; g <= m; g++) {
      if ((pSDGObjPtBuf->ObjPtBuf[g].ObjDis < APA_SLOT_PER_OBJ1Y_OBJ2Y_CORRECT_RANGE_OBJ_DIS_MAX1) &&
          (pSDGObjPtBuf->ObjPtBuf[g].ObjDis < MinObjDis)) {
        mX  = pSDGObjPtBuf->ObjPtBuf[g].Pt.x;
        mY  = pSDGObjPtBuf->ObjPtBuf[g].Pt.y;
        mXY = fDis2 * mX + fDis1; // Y = K * X + B;
        if (bRightSideBorderLine == FALSE) {
          // Left side. the offset border line should be above of the fit line.
          mXY = mXY - mY;
        } else {
          // Right side. the offset border line should be under of the fit line.
          mXY = mY - mXY;
        }
        if (mXX > mXY) {
          mXX = mXY;
          d   = g;
        }
      }
    }
    if (d != 0x7f)
#endif
    {
#ifdef APA_SLOT_SUPPORT_SLOT_BORDER_LINE_OFFSET_CAL

      // OK, a valid offset border line is found.
      // Calculate the offset line:
      // Y = KX + B1:
      mX       = pSDGObjPtBuf->ObjPtBuf[d].Pt.x;
      mY       = pSDGObjPtBuf->ObjPtBuf[d].Pt.y;
      LineParB = mY - fDis2 * mX; // B1: New B1.

      fDis1 = (fDis1 + LineParB) / 2.0; // Mid of Offset line and fit border line.
#endif

      CompensateLineParCDis = 0;

      if (APASnsIndex == APA_RRS_SNS_INDEX) {
        fDis2 = USSPar.TrajCalCarEndPos.Coordinate.x - pSDGObjPtBuf->ObjPtBuf[h].CarPos.Coordinate.x;
        if (fDis2 > 1000) {

          CompensateLineParCDis = MATH_FABS(DeltaAngBtSnsAngAndBorderLineAngEnd) + MATH_FABS(DeltaAngBtSnsAngAndBorderLineAngSt);
          CompensateLineParCDis /= 2.0;
          CompensateLineParCDis *= APACal.APASlotCorPSlotBorderLineFitCompDisPerDeltaSideSnsAndBdLineAng;
        }
        CompensateLineParCDis += APACal.APASlotCorPSlotBorderLineFitCompDisRSideSns;
      } else if (APASnsIndex == APA_RR_SNS_INDEX) {
        CompensateLineParCDis = APACal.APASlotCorPSlotBorderLineFitCompDisRRCornerSns;
      } else if (APASnsIndex == APA_RL_SNS_INDEX) {
        CompensateLineParCDis = APACal.APASlotCorPSlotBorderLineFitCompDisRLCornerSns;
      } else {
        CompensateLineParCDis = APACal.APASlotCorPSlotBorderLineFitCompDisLSideSns;
      }

      fDis1 += CompensateLineParCDis; // Line.C
      pBorderLine->C = fDis1;
    }
  }

  if ((MATH_FABS(pBorderLine->A)) < APACal.APATrajCalLineIsHMinK) {
    // Horizontal
    pBorderLine->A        = 0;
    pBorderLine->LineType = APALineIsHorizontal;
  } else {
    pBorderLine->LineType = APALineIsIncline;
  }

  return TRUE;
}
/*************************************************************************************************************************************************
 ** Syntax :  APA_DISTANCE_TYPE APASlotProcPInSlotFitSlotBorderLineGetAllowWithoutDtdObjToCarDrvMaxPosXDis(
 APA_ANGLE_CAL_FLOAT_TYPE CarAng, APA_ANGLE_CAL_FLOAT_TYPE BorderLineAng,
 BOOLEAN bRightSideBorderLine, APA_INDEX_TYPE BdLineSnsIndex,
 // APA_ANGLE_CAL_FLOAT_TYPE *pDeltaCarAndBdLineAg,
 APA_DISTANCE_TYPE *pAllowMinLineLen, APA_INDEX_TYPE LineLenCheckMode) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-10-2-3 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
APA_DISTANCE_TYPE
APASlotProcPInSlotFitSlotBorderLineGetAllowWithoutDtdObjToCarDrvMaxPosXDis(APA_ANGLE_CAL_FLOAT_TYPE CarAng,
                                                                           APA_ANGLE_CAL_FLOAT_TYPE BorderLineAng,
                                                                           BOOLEAN bRightSideBorderLine,
                                                                           APA_INDEX_TYPE BdLineSnsIndex,
                                                                           // APA_ANGLE_CAL_FLOAT_TYPE *pDeltaCarAndBdLineAg,
                                                                           APA_DISTANCE_TYPE *pAllowMinLineLen,
                                                                           APA_INDEX_TYPE LineLenCheckMode) {
  // LineLenCheckMode:
  // 0 - line with convex at head.
  // 1 - line with convex at mid.
  // 2 - line with covex at tail.

  APA_ANGLE_CAL_FLOAT_TYPE DeltaAng;

  DeltaAng = (CarAng - PI / 2.0 - BorderLineAng);
  if (MATH_FABS(DeltaAng) > APACal.APASlotCorPSlotBorderLineFitMaxDeltaCarAngAndBdLineAng) {
    // Data error??
    return FALSE;
  }

  //(*pDeltaCarAndBdLineAg) = DeltaAng;

  if (bRightSideBorderLine == FALSE) {
    // left side line
    if (DeltaAng < -APACal.APASlotCorPSlotBorderLineFitMinLineLenDevidedDeltaCarAngAndBdLineAng1) {
      // Delta angle is great than
      (*pAllowMinLineLen) = APACal.APASlotCorPSlotBorderLineFitRegardAsValidOKLineMinLineLenAtHead[BdLineSnsIndex]; // 80cm
      return APACal.APASlotCorPSlotBorderLineFitMaxWithoutDtdObjToCarDrvMaxPosXDis1;                                // 30cm.
    } else if (DeltaAng < APACal.APASlotCorPSlotBorderLineFitMinLineLenDevidedDeltaCarAngAndBdLineAng2) {
      (*pAllowMinLineLen) = APACal.APASlotCorPSlotBorderLineFitMinLineLen1[LineLenCheckMode][BdLineSnsIndex]; // 100cm
      return APACal.APASlotCorPSlotBorderLineFitMaxWithoutDtdObjToCarDrvMaxPosXDis2;                          // 80cm.
    } else {
      (*pAllowMinLineLen) = APACal.APASlotCorPSlotBorderLineFitMinLineLen2[LineLenCheckMode][BdLineSnsIndex]; // 140cm.
      return APACal.APASlotCorPSlotBorderLineFitMaxWithoutDtdObjToCarDrvMaxPosXDis3;                          // 140cm.
    }
  } else {
    if (DeltaAng > APACal.APASlotCorPSlotBorderLineFitMinLineLenDevidedDeltaCarAngAndBdLineAng1) {
      // Delta angle is great than
      (*pAllowMinLineLen) = APACal.APASlotCorPSlotBorderLineFitRegardAsValidOKLineMinLineLenAtHead[BdLineSnsIndex];
      return APACal.APASlotCorPSlotBorderLineFitMaxWithoutDtdObjToCarDrvMaxPosXDis1; // 30cm.
    } else if (DeltaAng > -APACal.APASlotCorPSlotBorderLineFitMinLineLenDevidedDeltaCarAngAndBdLineAng2) {
      (*pAllowMinLineLen) = APACal.APASlotCorPSlotBorderLineFitMinLineLen1[LineLenCheckMode][BdLineSnsIndex]; // 100cm
      return APACal.APASlotCorPSlotBorderLineFitMaxWithoutDtdObjToCarDrvMaxPosXDis2;                          // 80cm.
    } else {
      (*pAllowMinLineLen) = APACal.APASlotCorPSlotBorderLineFitMinLineLen2[LineLenCheckMode][BdLineSnsIndex]; // 140cm.
      return APACal.APASlotCorPSlotBorderLineFitMaxWithoutDtdObjToCarDrvMaxPosXDis3;                          // 140cm.
    }
  }
}
/*************************************************************************************************************************************************
 ** Syntax :  void USS(void)                                                                                                                     **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-10-2 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
BOOLEAN APASlotProcPInSlotFitSlotBorderLineAndCheckIfLineIsValid(APA_CAL_FLOAT_TYPE BorderLineK,
                                                                 APASlotBorderLineParameterType *pBorderLine,
                                                                 SDGObjPtBufType *pSDGObjPtBuf,
                                                                 APA_INDEX_TYPE *pValidObjPtIndexBuf,
                                                                 APA_INDEX_TYPE StartPtIndex,
                                                                 APA_INDEX_TYPE EndPtIndex,
                                                                 BOOLEAN bRightSideBorderLine,
                                                                 APA_INDEX_TYPE BdLineDtSnsIndex,
                                                                 APA_INDEX_TYPE ObjPtStartIndex, // from car end pos, the first valid obj point index.
                                                                 APA_INDEX_TYPE CarPosEndIndex,  // Include no obj point.
                                                                 APA_DISTANCE_TYPE Obj12PtX,
                                                                 BOOLEAN bCompensateBdLineK,
                                                                 APA_INDEX_TYPE APASnsIndex,
                                                                 APA_INDEX_TYPE LineLenCheckMode) {
  // LineLenCheckMode:
  // 0 - line with convex at head.
  // 1 - line with convex at mid.
  // 2 - line with covex at tail.

  APA_ANGLE_CAL_FLOAT_TYPE BorderLineAng; //, DeltaAng;
  APA_DISTANCE_TYPE Dis1, AllowWithoutDtdObjToCarDrvMaxPosXDis, AllowMinLineLen, LineLen;
  APA_INDEX_TYPE CalResult;
  BOOLEAN bCalResult;
  APALineParameterABCType BdLinePar;

  // 1. get the allow min line length and AllowWithoutDtdObjToCarDrvMaxPosXDis

  BorderLineAng = MATH_ATAN(BorderLineK);
  AllowWithoutDtdObjToCarDrvMaxPosXDis =
      APASlotProcPInSlotFitSlotBorderLineGetAllowWithoutDtdObjToCarDrvMaxPosXDis(pSDGObjPtBuf->ObjPtBuf[CarPosEndIndex].CarPos.CarAng,
                                                                                 BorderLineAng,
                                                                                 bRightSideBorderLine,
                                                                                 BdLineDtSnsIndex,
                                                                                 //&DeltaAng,
                                                                                 &AllowMinLineLen, // allow min line len.
                                                                                 LineLenCheckMode);

  if ((APASnsIndex == APA_RRS_SNS_INDEX) || (APASnsIndex == APA_RLS_SNS_INDEX)) {
    Dis1 = APACal.APASlotCorPSlotBorderLineFitStopCheckWithoutDtdObjMinSideObjDis;
  } else {
    Dis1 = APACal.APASlotCorPSlotBorderLineFitStopCheckWithoutDtdObjMinCornerObjDis;
  }
  if (pSDGObjPtBuf->ObjPtBuf[pValidObjPtIndexBuf[StartPtIndex]].ObjDis > Dis1) {
    if (bRightSideBorderLine == FALSE) {
      if (APASlotCorrectionFlag.Bits.ResetLeftSideSlotBorderLineCheck == FALSE) {
        AllowWithoutDtdObjToCarDrvMaxPosXDis = 4000;
      }
    } else {
      if (APASlotCorrectionFlag.Bits.ResetRightSideSlotBorderLineCheck == FALSE) {
        AllowWithoutDtdObjToCarDrvMaxPosXDis = 4000;
      }
    }
  }

  // 2. check if the line end pt to car pos end is within tol.

  CalResult = APASlotProcPInSlotFitSlotBorderLineCheckIfLineEndPtToCarPosEndIsWithinTol(
      pSDGObjPtBuf,
      (&LineLen), // Line len
      AllowWithoutDtdObjToCarDrvMaxPosXDis,
      APACal.APASlotCorPSlotBorderLineFitRegardAsCarValidObjBdLineMinLen[BdLineDtSnsIndex],
      pValidObjPtIndexBuf[StartPtIndex],
      pValidObjPtIndexBuf[EndPtIndex],
      ObjPtStartIndex,
      CarPosEndIndex);
  if (CalResult == 0) {
    // Invalid obj
    return FALSE;
  }
  if (LineLen > AllowMinLineLen) {
    // Line len > 80cm, or 1.2m.
    if ((CalResult == 2)) {
      Dis1 = Obj12PtX;
      Dis1 = pSDGObjPtBuf->ObjPtBuf[pValidObjPtIndexBuf[0]].Pt.x - Dis1;
      if (Dis1 > APACal.APASlotCorPSlotBorderLineFitRegardAsValidOKLineMinObjWidth[BdLineDtSnsIndex]) {
        // It is a valid obj width. > 1.8m.
      } else {
        // It is not a valid object width.
        //
        return FALSE;
      }
    }
    // OK line is confirmed.

    bCalResult = APASlotProcPInSlotFitSlotBorderLineByValidObjStartPtAndEndPt(&BdLinePar,
                                                                              pSDGObjPtBuf,
                                                                              pValidObjPtIndexBuf,
                                                                              AllowMinLineLen, // allow min line len
                                                                              StartPtIndex,
                                                                              EndPtIndex,
                                                                              bCompensateBdLineK,
                                                                              bRightSideBorderLine,
                                                                              APASnsIndex,
                                                                              BdLineDtSnsIndex);

    if (bCalResult == TRUE) {
      // OK,
      pBorderLine->LinePar.K    = BdLinePar.A;
      pBorderLine->LinePar.B    = BdLinePar.C;
      pBorderLine->StartPtIndex = pValidObjPtIndexBuf[StartPtIndex]; // the inflextion point
      pBorderLine->EndPtIndex   = pValidObjPtIndexBuf[EndPtIndex];   // the inflextion point
      // pBorderLine->NearestPointToCar.x = mX;
      // pBorderLine->NearestPointToCar.y = mY;
      // pBorderLine->LineDepth = fTemp;
      return TRUE;
    } else {
    }
  }

  // NG
  return FALSE;
}
/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcInSlotCalculateSlotBorderLineWithSDGObjBuf(
 APASlotBorderLineParameterType *pBorderLine,
 SDGObjPtBufType *pSDGObjPtBuf, APA_ENUM_TYPE SDGSnsIndex) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-10-3 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

void APASlotProcPInSlotFitSlotBorderLineCheckAndOffsetBorderLine(APALineParameterKBType *pBorderLine,
                                                                 SDGObjPtBufType *pSDGObjPtBuf,
                                                                 APA_INDEX_TYPE *pValidObjPtIndexBuf,
                                                                 APA_INDEX_TYPE StartPtIndex,
                                                                 APA_INDEX_TYPE EndPtIndex,
                                                                 BOOLEAN bRightSideBorderLine,
                                                                 APA_DISTANCE_TYPE *pLineBOffsetDis) {
  APA_DISTANCE_CAL_FLOAT_TYPE fDis1, fDis2, fDis3, fTol;
  APA_INDEX_TYPE g, k, ObjPtCnt;
  APA_ANGLE_CAL_FLOAT_TYPE DeltaAng;
  APA_DISTANCE_TYPE Dis1, Dis2, Obj12PtX;

  // 1. get the allow min line length and AllowWithoutDtdObjToCarDrvMaxPosXDis
  fDis3 = 0;

  ObjPtCnt = pSDGObjPtBuf->ObjPtCnt;
  if (ObjPtCnt < 3) {
    // Data error ?? remain the last state.
    return;
  }

  if (bRightSideBorderLine == TRUE) {
    // right sensor.
    Obj12PtX = USSPar.TrajCalObj2Pos.x;
  } else {
    // left sensor.
    Obj12PtX = USSPar.TrajCalObj1Pos.x;
  }

  for (g = pValidObjPtIndexBuf[EndPtIndex] + 1; g < ObjPtCnt; g++) {
    if ((pSDGObjPtBuf->ObjPtBuf[g].Pt.x < Obj12PtX)) {
      break;
    }
    if (pSDGObjPtBuf->ObjPtBuf[g].ObjDis < APACal.APASlotCorPSlotBorderLineFitMaxSnsDtDis) {
      EndPtIndex++;
      pValidObjPtIndexBuf[EndPtIndex] = g;
    }
  }

  for (g = StartPtIndex; g <= EndPtIndex; g++) {
    k        = pValidObjPtIndexBuf[g];
    DeltaAng = MATH_FABS(pSDGObjPtBuf->ObjPtBuf[k].CarPos.CarAng - USSPar.TrajCalCarEndPos.CarAng);
    if (DeltaAng < APACal.APASlotCorPSlotBorderLineFitConsiderConvexPtMaxDeltaCarAng) { // 25deg.
      fDis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
      fDis2 = pBorderLine->K * fDis1 + pBorderLine->B; // cross pt.y
      if (bRightSideBorderLine == FALSE) {
        // left
        fDis2 = pSDGObjPtBuf->ObjPtBuf[k].Pt.y - fDis2;
        if (fDis2 > fDis3) {
          fDis3 = fDis2;
        }
      } else {
        // right
        fDis2 = fDis2 - pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
        if (fDis2 > fDis3) {
          fDis3 = fDis2;
        }
      }
    }
  }
  Dis1 = fDis3;
  if ((*pLineBOffsetDis) == 0) {
    // Previous there is no offset.
    // Just use big tolerance. 35cm.
    if (Dis1 > APACal.APASlotCorPSlotBorderLineFitConsiderConvexPtMinDeltaYTol2) {
      // Out of tolerance.
      fDis3 *= APACal.APASlotCorPSlotBorderLineFitConsiderConvexPtLineOffsetFactor;
      Dis1 = fDis3;
      if (Dis1 < APACal.APASlotCorPSlotBorderLineFitConsiderConvexPtAllowOffsetMaxDis) {
        // 80cm,
        // It is not allow to compensate too much.
        if (bRightSideBorderLine == FALSE) {
          pBorderLine->B += fDis3;
        } else {
          pBorderLine->B -= fDis3;
        }
        (*pLineBOffsetDis) = Dis1;
      }
    } else {
      // ?? do not compensate.
      //(*pLineBOffsetDis) = 0;
    }
  } else {
    // There is already a offset compensate, just use small tol. 20cm
    if (Dis1 > APACal.APASlotCorPSlotBorderLineFitConsiderConvexPtMinDeltaYTol1) {
      // Out of tolerance.
      fDis3 *= APACal.APASlotCorPSlotBorderLineFitConsiderConvexPtLineOffsetFactor;
      Dis1 = fDis3;
      if (Dis1 < APACal.APASlotCorPSlotBorderLineFitConsiderConvexPtAllowOffsetMaxDis) {
        // 80cm,
        // It is not allow to compensate too much.
        Dis1 = Dis1 - (*pLineBOffsetDis);
        Dis2 = APACal.APASlotCorPSlotBorderLineFitConsiderConvexPtMinDeltaYTol2 -
               APACal.APASlotCorPSlotBorderLineFitConsiderConvexPtMinDeltaYTol1; // 35cm - 15cm = 20cm.
        if ((Dis1 < -Dis2) || (Dis1 > Dis2)) {
          Dis1  = Dis1 / 2; // If the current is 10cm and prev is 30cm, half of delta (Dis1) will be -10cm,
          fDis3 = fDis3 - Dis1;
        } else {
          // within 20cm tolerance.
          // just use the new one.
        }
        if (bRightSideBorderLine == FALSE) {
          pBorderLine->B += fDis3;
        } else {
          pBorderLine->B -= fDis3;
        }
        (*pLineBOffsetDis) = (APA_DISTANCE_TYPE)fDis3; // it is always great than 0.

      } else {
        // ?? do not compensate.
        (*pLineBOffsetDis) = 0;
      }
    } else {
      // ?? do not compensate.
      (*pLineBOffsetDis) = 0;
    }
  }
}
/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcInSlotCalculateSlotBorderLineWithSDGObjBuf(
 APASlotBorderLineParameterType *pBorderLine,
 SDGObjPtBufType *pSDGObjPtBuf, APA_ENUM_TYPE SDGSnsIndex) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-10 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
BOOLEAN APASlotProcInSlotCalculateSlotBorderLineWithSDGObjBuf(APASlotBorderLineParameterType *pBorderLine,
                                                              SDGObjPtBufType *pSDGObjPtBuf,
                                                              APA_ENUM_TYPE SDGSnsIndex) {
  // Input Par: pSDGObjPtBuf
  // SDGSnsIndex: SDG_RRS_SNS_INDEX: = RRS Right side
  //              SDG_FRS_SNS_INDEX: = RRC right side
  //              SDG_RLS_SNS_INDEX: = RLS left side
  //              SDG_FLS_SNS_INDEX: = RLC left side

  // Output par: pBorderLine
  // return value:
  // FALSE = Line does not exist.
  // TRUE = OK.
  // pBorderLine->EndPtIndex = 0; Invalid border line.

  APA_INDEX_TYPE ObjPtCnt, i, g, m, k, CalCnt, BdLineDtSnsIndex;
  APA_DISTANCE_CAL_FLOAT_TYPE fDis1;
  APA_DISTANCE_TYPE CarPosMaxX, CarPosMinX, Dis1, Dis2, Dis3, ObjPtMinX, ObjPtMaxX;
  APA_ANGLE_CAL_FLOAT_TYPE CarAngTemp1, CarAngTemp2;
  BOOLEAN bRightSideBorderLine;
  APA_ENUM_TYPE APASnsIndex;
  APA_DISTANCE_TYPE ObjPtMinY, ObjPtMaxY;
  // BOOLEAN bBorderLineHasBeenCorrected;

  APA_INDEX_TYPE LineFitObjMidPtIndex, LineFitObjEndPtIndex, LineFitObjStartPtIndex;
  APACoordinateDataCalFloatType LineStartPt, LineEndPt, LineMidPt, Obj12Pt;
  APA_INDEX_TYPE CarPosEndIndex, ObjPtStartIndex; // include the no_obj_dis point.
  APA_INDEX_TYPE ValidObjPtIndexBuf[SDG_MAX_SUPPORT_OBJ_POINT_BUF_SIZE], ValidObjCnt, ValidObjPtEndIndex;
  APA_INDEX_TYPE ValidObjPtIndexBufNew[SDG_MAX_SUPPORT_OBJ_POINT_BUF_SIZE], ValidObjCntNew;
  // APA_DISTANCE_TYPE ObjPtDeltaDisY[SDG_MAX_SUPPORT_OBJ_POINT_BUF_SIZE];
  // APA_INDEX_TYPE ObjPtMinYIndex, ObjPtMaxYIndex;
  APA_INDEX_TYPE MaxObjPtDeltaYIndex1, MaxObjPtDeltaYIndex2;
  APA_DISTANCE_TYPE MaxObjPtDeltaY1, MaxObjPtDeltaY2, ObjWidthX, Obj12PtX;
  APA_INDEX_TYPE ObjShapeIndex;
  APALineParameterABCType StAndEndPtLine, StAndMidPtLine, MidAndEndPtLine;
  APALineParameterABCType BdLinePar;
  BOOLEAN bCalResult;
  APA_INDEX_TYPE LineFitValidObjEndIndex;
  APA_DISTANCE_TYPE StopCheckObjPtWithinTolObjPtX; // Obj Pt.x < this value will not be checked.

  /*
   Obj shape index:
   0: Unknown, invalid shape, do not fit.
   1: Convex: left side object (obj1)
   2: Concave: right side object (obj2)
   3: OK Line
   4: line with convex at head
   5: line with convex at mid
   6: line with convex at tail
   7: line with concave at head.
   8: line with concave at mid
   9: line with concave at tail
   */

  // Step 1: Identify the angular border line of the object and save it into a buffer.
  // Algorithm:
  // Step 1.3.2: Calculate the appropriate border line.
  // BOOL APAGetTheLineWithTheLeatSquareMethod()
  //
  // Y=kX+b)
  // Algorithm Start:
  ObjPtCnt = pSDGObjPtBuf->ObjPtCnt;
  if (ObjPtCnt < 5) {
    return FALSE;
  }

  /*if(APASlotProcInSlotSlotCheckIfBorderLineCanBeFittedWithSDGObjBuf(pSDGObjPtBuf, SDGSnsIndex) == FALSE){
   return FALSE;
   }*/

  if (SDGSnsIndex == SDG_RRS_SNS_INDEX) {
    APASnsIndex      = APA_RRS_SNS_INDEX;
    BdLineDtSnsIndex = 0;
  } else if (SDGSnsIndex == SDG_FRS_SNS_INDEX) {
    APASnsIndex      = APA_RR_SNS_INDEX;
    BdLineDtSnsIndex = 1;
  } else if (SDGSnsIndex == SDG_RLS_SNS_INDEX) {
    APASnsIndex      = APA_RLS_SNS_INDEX;
    BdLineDtSnsIndex = 2;
  } else {
    APASnsIndex      = APA_RL_SNS_INDEX;
    BdLineDtSnsIndex = 3;
  }

  if ((SDGSnsIndex == SDG_RRS_SNS_INDEX) || (SDGSnsIndex == SDG_FRS_SNS_INDEX)) {
    // right sensor.
    // bBorderLineHasBeenCorrected = APASlotCorrectionFlag.Bits.RightSideLineHasBeenCorrected;
    if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == FALSE) {
      return FALSE;
    }
    bRightSideBorderLine = TRUE;
    Obj12PtX             = USSPar.TrajCalObj2Pos.x;
    Obj12Pt              = USSPar.TrajCalObj2Pos;
  } else {
    // left sensor.
    // bBorderLineHasBeenCorrected = APASlotCorrectionFlag.Bits.LeftSideLineHasBeenCorrected;
    if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == FALSE) {
      return FALSE;
    }
    bRightSideBorderLine = FALSE;
    Obj12PtX             = USSPar.TrajCalObj1Pos.x;
    Obj12Pt              = USSPar.TrajCalObj1Pos;
  }

  CarPosMinX     = Obj12PtX - APACal.LenBetweenRAxisAndRBumper - 1000;
  CarPosEndIndex = ObjPtCnt;
  ObjPtMinX      = 5000; // ObjPtMinX
  ObjPtMaxX      = -5000;
  ValidObjCnt    = 0;
  for (g = 0; g < ObjPtCnt; g++) {
    Dis1 = pSDGObjPtBuf->ObjPtBuf[g].Pt.x - Obj12PtX;
    if ((pSDGObjPtBuf->ObjPtBuf[g].CarPos.Coordinate.x < CarPosMinX) || (Dis1 < APACal.APASlotCorPSlotBorderLineFitStartDeltaObjX)) {
      // < -40cm.
      break;
    }
    CarPosMaxX = APASlotProcInSlotCalculateSlotBorderLineGetMaxCarPosXWithCarAng(pSDGObjPtBuf->ObjPtBuf[g].CarPos.CarAng, APASnsIndex);
    if (pSDGObjPtBuf->ObjPtBuf[g].CarPos.Coordinate.x < CarPosMaxX) {
      if (CarPosEndIndex == ObjPtCnt) {
        CarPosEndIndex = g;
      }
      if (pSDGObjPtBuf->ObjPtBuf[g].ObjDis < APACal.APASlotCorPSlotBorderLineFitMaxSnsDtDis) {
        ValidObjPtIndexBuf[ValidObjCnt] = g;
        ValidObjCnt++;
        if (ObjPtMinX > pSDGObjPtBuf->ObjPtBuf[g].Pt.x) {
          ObjPtMinX = pSDGObjPtBuf->ObjPtBuf[g].Pt.x;
          // ObjPtMinXIndex = g;
        }
        if (ObjPtMaxX < pSDGObjPtBuf->ObjPtBuf[g].Pt.x) {
          ObjPtMaxX = pSDGObjPtBuf->ObjPtBuf[g].Pt.x;
          // ObjPtMaxXIndex = g;
        }
      }
    }
  }

  if (ValidObjCnt < 4) {
    return FALSE;
  }
  ObjPtStartIndex = ValidObjPtIndexBuf[0];
  ObjWidthX       = ObjPtMaxX - ObjPtMinX;

  if (ObjWidthX < APACal.APASlotCorPSlotBorderLineFitRegardAsValidObjMinWidth[BdLineDtSnsIndex]) {

#if 0
		if(bRightSideBorderLine == TRUE) {
			Dis1 = pSDGObjPtBuf->ObjPtBuf[ValidObjPtEndIndex].Pt.y
			- pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[0]].Pt.y;

			if(Dis1 < APACal.APASlotCorPSlotBorderLineFitRegardAsValidObjMinWidth[BdLineDtSnsIndex]) {
				// small object
				return FALSE;
			}
		} else {
			// Small object
			return FALSE;
		}
#endif

    // Small object
    return FALSE;
  }

  if (pBorderLine->FitLineShapeType <= APASlotPObjShape_LineWithCovexAtHead) {

    m = pSDGObjPtBuf->WrIndex; // check the start point and end point to fit the bd line.

    if ((m > 0) && (m < (ObjPtCnt - 1))) {
      for (g = 0; g < ValidObjCnt; g++) {
        k = ValidObjPtIndexBuf[g];
        if (k >= m) {
          break;
        }
      }
      // g is the end point
      // k is the end valid point index.
      CarPosMaxX = (APA_DISTANCE_TYPE)USSPar.TrajCalCarEndPos.Coordinate.x;
      Dis1       = (CarPosMaxX - pSDGObjPtBuf->ObjPtBuf[m].CarPos.Coordinate.x);
      if (Dis1 < (APACal.APASlotCorPSlotBorderLineFitUseObjPtWrIndexMaxDeltaCarPosX1)) {
        // < 80cm.
        // Ok, just use wrindex.
      } else if (Dis1 > (APACal.APASlotCorPSlotBorderLineFitUseObjPtWrIndexMaxDeltaCarPosX2)) {
        // < 80cm.
        // Ok, just use 0 index.
        m = 0;
      } else {
        CarAngTemp1 = MATH_FABS(USSPar.TrajCalCarEndPos.CarAng - pSDGObjPtBuf->ObjPtBuf[m - 1].CarPos.CarAng);
        CarAngTemp2 = MATH_FABS(USSPar.TrajCalCarEndPos.CarAng - pSDGObjPtBuf->ObjPtBuf[m + 1].CarPos.CarAng);

        if (CarAngTemp1 < CarAngTemp2) {
          CarAngTemp1 = CarAngTemp2;
        }
        if (CarAngTemp1 < (APACal.APASlotCorPSlotBorderLineFitNotUseObjPtWrIndexMaxDeltaCarAng)) {
          // delta car ang < 5deg.
          m = 0;
        } else {
          if (g == ValidObjCnt) {
            // ??Data error ??
            // Just use 0.
            m = 0;
          } else {
            Dis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.x - ObjPtMinX;
            if (Dis1 > APACal.APASlotCorPSlotBorderLineFitUseObjPtWrIndexMinObjXWidthHead) {
              // OK, use wr index.

            } else {
              Dis1 = ObjPtMaxX - pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
              if (Dis1 > APACal.APASlotCorPSlotBorderLineFitNotUseObjPtWrIndexMinObjXWidthTail) {
                // Ok, use 0 index.
                // Max valid index is k.
                m = 0;
              } else {
                // NG. it is not good to use these points to fit line.
                // Just return false ??
                return FALSE;
              }
            }
          }
        }
      }
      // determine the start point and end valid pt.
      if (m == 0) {
        // Use the first point as the start point. and wr index as the end point.
        ValidObjCnt = g; //  0 ~ g - 1;
      } else {
        // Use the wr index point as the start point. and valid obj cnt - 1 as the end point.
        k = 0;
        for (; g < ValidObjCnt; g++) {
          ValidObjPtIndexBuf[k] = ValidObjPtIndexBuf[g];
          k++;
        }
        ValidObjCnt = k;
      }
    } else {
      // m = 0;
    }
  }

  m = 0;
  for (g = 1; g < ValidObjCnt; g++) {
    Dis1 = pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[m]].Pt.x - pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[g]].Pt.x;
    if (Dis1 < APACal.APASlotCorPSlotBorderLineFitAllowMinDeltaObjXBtTwoObjPt) {
      // < -15cm.
      ValidObjCnt = g;
      break;
    }
    m++;
  }

  // 2. valid Obj point should great than 3.
  if (ValidObjCnt < 4) {
    return FALSE;
  }

  // 3. Check valid obj width X or Y should great than valid obj width. //Side sns: 1.2m, corner sns: 1.8m.

  ValidObjPtEndIndex = ValidObjPtIndexBuf[ValidObjCnt - 1];

  // 4. Check obj shape:
  /*
   Obj shape index:
   0: Unknown, invalid shape, do not fit.
   1: Convex: left side object (obj1)
   2: Concave: right side object (obj2)
   3: OK Line
   4: line with convex at head
   5: line with convex at mid
   6: line with convex at tail
   7: line with concave at head.
   8: line with concave at mid
   9: line with concave at tail
   */

  ObjShapeIndex = APASlotPObjShape_Unknown;

  if ((APASlotPSlotBorderLineFitConvexShapeCheckSequence < 3) && ((pSDGObjPtBuf->WrIndex <= 1) || (pSDGObjPtBuf->WrIndex >= (ObjPtCnt - 2)))) {
    // 4.1. cal point delta y with min obj pt.y and save into the valid obj point delta y buf.
    /*
     *
     *        *
     *	            *
     *
     */

    // 1. Search the valid obj pt:
    // scope: obj Dis < 1.8m. Car pos.x < given X (related to sns and car angle).
    // Obj pt.x > obj1.x - 40cm.
    //
    // ObjPtMinYIndex = ValidObjCnt;
    // ObjPtMaxYIndex = ValidObjCnt;
    ObjPtMinY = 10000;
    ObjPtMaxY = -10000;

    for (g = 0; g < ValidObjCnt; g++) {
      k = ValidObjPtIndexBuf[g];
      if (ObjPtMinY > pSDGObjPtBuf->ObjPtBuf[k].Pt.y) {
        ObjPtMinY = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
        // ObjPtMinYIndex = k;
      }
      if (ObjPtMaxY < pSDGObjPtBuf->ObjPtBuf[k].Pt.y) {
        ObjPtMaxY = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
        // ObjPtMaxYIndex = k;
      }
    }

    k             = ValidObjPtIndexBuf[0];
    LineStartPt.x = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    LineStartPt.y = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;

    MaxObjPtDeltaY1      = 0;
    MaxObjPtDeltaYIndex1 = 0;
    MaxObjPtDeltaY2      = 0;
    MaxObjPtDeltaYIndex2 = 0;
    for (g = 0; g < ValidObjCnt; g++) {
      k    = ValidObjPtIndexBuf[g];
      Dis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.y - ObjPtMinY;
      // ObjPtDeltaDisY[g] = Dis1;
      if (MaxObjPtDeltaY1 < Dis1) {
        MaxObjPtDeltaY1      = Dis1;
        MaxObjPtDeltaYIndex1 = g;
      }
      Dis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.y - ObjPtMaxY;
      // ObjPtDeltaDisY[g] = Dis1;
      if (MaxObjPtDeltaY2 > Dis1) {
        MaxObjPtDeltaY2      = Dis1;
        MaxObjPtDeltaYIndex2 = g;
      }
    }
    LineEndPt.x = pSDGObjPtBuf->ObjPtBuf[ValidObjPtEndIndex].Pt.x;
    LineEndPt.y = pSDGObjPtBuf->ObjPtBuf[ValidObjPtEndIndex].Pt.y;

    bCalResult = APATrajCalLineParABCbyTwoPoints(LineStartPt, LineEndPt, &StAndEndPtLine);

    if ((bCalResult == FALSE) || (StAndEndPtLine.LineType == APALineIsInvalidLineType) || (StAndEndPtLine.LineType == APALineIsVertical)) {
      // Data error ??
      return FALSE;
    }

    // 4.2. Check if the line shape is OK line "---------------------"

    Dis2 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol1; // 5cm,
    for (g = 1; g < (ValidObjCnt - 1); g++) {
      k     = ValidObjPtIndexBuf[g];
      fDis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
      fDis1 = StAndEndPtLine.A * fDis1 + StAndEndPtLine.C; //  Obj Pt.x and the Start and Mid Line Cross Pt.Y
      Dis1  = (fDis1);
      Dis1  = pSDGObjPtBuf->ObjPtBuf[k].Pt.y - Dis1;
      if (Dis1 < 0) {
        Dis1 = -Dis1;
      }
      if (Dis1 > Dis2) {
        // It is an unknown shape??
        // just break;
        bCalResult = FALSE;
        break;
      }
    }
    if (bCalResult == TRUE) {
      bCalResult = APASlotProcPInSlotFitSlotBorderLineCheckIfPointIsWithinLineTol(&StAndEndPtLine,
                                                                                  pSDGObjPtBuf,
                                                                                  ValidObjPtIndexBuf,
                                                                                  ValidObjPtIndexBufNew,
                                                                                  &ValidObjCntNew,
                                                                                  APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol1,
                                                                                  1,
                                                                                  (ValidObjCnt - 2),
                                                                                  0,
                                                                                  bRightSideBorderLine,
                                                                                  FALSE,
                                                                                  0);
      if (bCalResult == TRUE) {
        // All points is within a valid small tolerance 5cm.
        // Check the start point pos.
        bCalResult = APASlotProcPInSlotFitSlotBorderLineAndCheckIfLineIsValid(StAndEndPtLine.A,
                                                                              pBorderLine,
                                                                              pSDGObjPtBuf,
                                                                              ValidObjPtIndexBuf,
                                                                              0,
                                                                              ValidObjCnt - 1,
                                                                              bRightSideBorderLine,
                                                                              BdLineDtSnsIndex,
                                                                              ObjPtStartIndex,
                                                                              CarPosEndIndex,
                                                                              Obj12PtX,
                                                                              FALSE,
                                                                              APASnsIndex,
                                                                              0);

        if (bCalResult == TRUE) {
          // OK,
          pBorderLine->FitLineShapeType = APASlotPObjShape_OKLine;
          pBorderLine->LineBOffsetDis   = 0;
          return TRUE;
        } else {
          // NG
        }
      }
    }

    // 4.3. check the pos.x of the max point y. if it is out of check mid range(1/4 ~ 3/4 delta X), do not search again. Just check if it is the left
    // red shape?
    if (ObjWidthX < APACal.APASlotCorPSlotBorderLineFitRegardAsValidObjMaxWidth[BdLineDtSnsIndex]) {
      // Ok, within the small shape checking width
      Dis1 = pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[MaxObjPtDeltaYIndex1]].Pt.x - pSDGObjPtBuf->ObjPtBuf[ValidObjPtEndIndex].Pt.x;

      if ((Dis1 > ObjWidthX / 4) && (Dis1 < ((ObjWidthX * 3) / 4))) {
        // OK, within the range. (1/4 ~ 3/4).
        // Check if the shape is convex

        k           = ValidObjPtIndexBuf[MaxObjPtDeltaYIndex1];
        LineMidPt.x = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
        LineMidPt.y = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
        fDis1       = StAndEndPtLine.A * LineMidPt.x + StAndEndPtLine.C; // Max Obj Pt Delta Y and the Start and End Line Cross Pt.Y
        Dis1        = fDis1;
        if ((pSDGObjPtBuf->ObjPtBuf[k].Pt.y - Dis1) > APACal.APASlotCorPSlotBorderLineFitRegardAsConvexOrConcaveLineMinDeltaY[BdLineDtSnsIndex]) {
          // Ok, out of the straight line tolerance.
          // Check the start pt and mid pt line

          bCalResult = APATrajCalLineParABCbyTwoPoints(LineStartPt, LineMidPt, &StAndMidPtLine);

          if ((bCalResult == FALSE) || (StAndMidPtLine.LineType == APALineIsVertical)) {
            // Data error ??
            return FALSE;
          }
          bCalResult =
              APASlotProcPInSlotFitSlotBorderLineCheckIfPointIsWithinLineTol(&StAndMidPtLine,
                                                                             pSDGObjPtBuf,
                                                                             ValidObjPtIndexBuf,
                                                                             ValidObjPtIndexBufNew,
                                                                             &ValidObjCntNew,
                                                                             -APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol1,
                                                                             1,
                                                                             (MaxObjPtDeltaYIndex1 - 1),
                                                                             0,
                                                                             bRightSideBorderLine,
                                                                             FALSE,
                                                                             1);

          if ((bCalResult == TRUE) && (MaxObjPtDeltaYIndex1 > 3)) {
            // the shape from start pt to the max obj pt delta Y is convex.
            // Check the shape from the max obj pt delta Y to the end pt.
            bCalResult = APATrajCalLineParABCbyTwoPoints(LineEndPt, LineMidPt, &MidAndEndPtLine);

            if ((bCalResult == FALSE) || (MidAndEndPtLine.LineType == APALineIsVertical)) {
              // Data error ??
              return FALSE;
            }

            bCalResult =
                APASlotProcPInSlotFitSlotBorderLineCheckIfPointIsWithinLineTol(&MidAndEndPtLine,
                                                                               pSDGObjPtBuf,
                                                                               ValidObjPtIndexBuf,
                                                                               ValidObjPtIndexBufNew,
                                                                               &ValidObjCntNew,
                                                                               -APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol1,
                                                                               MaxObjPtDeltaYIndex1 + 1,
                                                                               (ValidObjCnt - 2),
                                                                               0,
                                                                               bRightSideBorderLine,
                                                                               FALSE,
                                                                               1);
            if ((bCalResult == TRUE) && (ValidObjCnt > (MaxObjPtDeltaYIndex1 + 3))) {
              // Ok the shape is convex.
              ObjShapeIndex = APASlotPObjShape_Convex;
              if ((bRightSideBorderLine == TRUE) || (MaxObjPtDeltaYIndex1 < 5)) {
                // Invalid object shape for right side bd line
                return FALSE;
              }
              g = MaxObjPtDeltaYIndex1;
              if (g > 4) {
                g--;
              }
              bCalResult = APASlotProcPInSlotFitSlotBorderLineByValidObjStartPtAndEndPt(
                  &BdLinePar,
                  pSDGObjPtBuf,
                  ValidObjPtIndexBuf,
                  APACal.APASlotCorPSlotBorderLineFitRegardAsConvexOrConcaveLineMinLineLen[BdLineDtSnsIndex],
                  0,
                  g, // or MaxObjPtDeltaYIndex1 - 1 ??
                  FALSE,
                  bRightSideBorderLine,
                  APASnsIndex,
                  BdLineDtSnsIndex);

              if (bCalResult == FALSE) {
                if (g >= 4) {
                  g++;
                  bCalResult = APASlotProcPInSlotFitSlotBorderLineByValidObjStartPtAndEndPt(
                      &BdLinePar,
                      pSDGObjPtBuf,
                      ValidObjPtIndexBuf,
                      APACal.APASlotCorPSlotBorderLineFitRegardAsConvexOrConcaveLineMinLineLen[BdLineDtSnsIndex],
                      0,
                      g, // or MaxObjPtDeltaYIndex1 - 1 ??
                      FALSE,
                      bRightSideBorderLine,
                      APASnsIndex,
                      BdLineDtSnsIndex);
                }
              }
              if (bCalResult == TRUE) {
                // OK,
                pBorderLine->LinePar.K        = BdLinePar.A;
                pBorderLine->LinePar.B        = BdLinePar.C;
                pBorderLine->StartPtIndex     = ValidObjPtIndexBuf[0]; // the inflextion point
                pBorderLine->EndPtIndex       = ValidObjPtIndexBuf[g]; // the inflextion point
                pBorderLine->FitLineShapeType = APASlotPObjShape_Convex;
                pBorderLine->LineBOffsetDis   = 0;
                // pBorderLine->NearestPointToCar.x = mX;
                // pBorderLine->NearestPointToCar.y = mY;
                // pBorderLine->LineDepth = fTemp;
                return TRUE;
              }
              return FALSE;
            } else {
              // It is an invalid line curve
              // just return false ??
            }
          }
        } else {
          // regarded as straight line ??
        }

      } else {
        // Out of scope ??
      }

      if (ObjShapeIndex == APASlotPObjShape_Unknown) {
        Dis1 = pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[MaxObjPtDeltaYIndex2]].Pt.x - pSDGObjPtBuf->ObjPtBuf[ValidObjPtEndIndex].Pt.x;
        if ((Dis1 > ObjWidthX / 4) && (Dis1 < ((ObjWidthX * 3) / 4))) {
          // OK, within the range. (1/4 ~ 3/4).
          // Check if the shape is concave.

          k           = ValidObjPtIndexBuf[MaxObjPtDeltaYIndex2];
          LineMidPt.x = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
          LineMidPt.y = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
          fDis1       = StAndEndPtLine.A * LineMidPt.x + StAndEndPtLine.C; // Max Obj Pt Delta Y and the Start and End Line Cross Pt.Y
          Dis1        = fDis1;
          if ((Dis1 - pSDGObjPtBuf->ObjPtBuf[k].Pt.y) > APACal.APASlotCorPSlotBorderLineFitRegardAsConvexOrConcaveLineMinDeltaY[BdLineDtSnsIndex]) {
            // Ok, out of the straight line tolerance.
            // Check the start pt and mid pt line

            bCalResult = APATrajCalLineParABCbyTwoPoints(LineStartPt, LineMidPt, &StAndMidPtLine);

            if ((bCalResult == FALSE) || (StAndMidPtLine.LineType == APALineIsVertical)) {
              // Data error ??
              return FALSE;
            }

            bCalResult =
                APASlotProcPInSlotFitSlotBorderLineCheckIfPointIsWithinLineTol(&StAndMidPtLine,
                                                                               pSDGObjPtBuf,
                                                                               ValidObjPtIndexBuf,
                                                                               ValidObjPtIndexBufNew,
                                                                               &ValidObjCntNew,
                                                                               APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol1,
                                                                               1,
                                                                               (MaxObjPtDeltaYIndex2 - 1),
                                                                               0,
                                                                               bRightSideBorderLine,
                                                                               FALSE,
                                                                               2);
            if ((bCalResult == TRUE) && (MaxObjPtDeltaYIndex2 > 3)) {
              // the shape from start pt to the max obj pt delta Y is convex.
              // Check the shape from the max obj pt delta Y to the end pt.
              bCalResult = APATrajCalLineParABCbyTwoPoints(LineEndPt, LineMidPt, &MidAndEndPtLine);

              if ((bCalResult == FALSE) || (MidAndEndPtLine.LineType == APALineIsVertical)) {
                // Data error ??
                return FALSE;
              }

              bCalResult =
                  APASlotProcPInSlotFitSlotBorderLineCheckIfPointIsWithinLineTol(&MidAndEndPtLine,
                                                                                 pSDGObjPtBuf,
                                                                                 ValidObjPtIndexBuf,
                                                                                 ValidObjPtIndexBufNew,
                                                                                 &ValidObjCntNew,
                                                                                 APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol1,
                                                                                 MaxObjPtDeltaYIndex2 + 1,
                                                                                 (ValidObjCnt - 2),
                                                                                 0,
                                                                                 bRightSideBorderLine,
                                                                                 FALSE,
                                                                                 2);

              if ((bCalResult == TRUE) && (ValidObjCnt > (MaxObjPtDeltaYIndex2 + 3))) {
                // Ok the shape is convex.
                ObjShapeIndex = APASlotPObjShape_Concave;
                if ((bRightSideBorderLine == FALSE) || (MaxObjPtDeltaYIndex2 < 5)) {
                  // Invalid object shape for Left side bd line
                  return FALSE;
                }
                g = MaxObjPtDeltaYIndex2;
                if (g > 6) {
                  g--;
                }
                bCalResult = APASlotProcPInSlotFitSlotBorderLineByValidObjStartPtAndEndPt(
                    &BdLinePar,
                    pSDGObjPtBuf,
                    ValidObjPtIndexBuf,
                    APACal.APASlotCorPSlotBorderLineFitRegardAsConvexOrConcaveLineMinLineLen[BdLineDtSnsIndex],
                    0,
                    g, // or MaxObjPtDeltaYIndex1 - 1 ??
                    FALSE,
                    bRightSideBorderLine,
                    APASnsIndex,
                    BdLineDtSnsIndex);

                if (bCalResult == FALSE) {
                  if (g >= 4) {
                    g++;
                    bCalResult = APASlotProcPInSlotFitSlotBorderLineByValidObjStartPtAndEndPt(
                        &BdLinePar,
                        pSDGObjPtBuf,
                        ValidObjPtIndexBuf,
                        APACal.APASlotCorPSlotBorderLineFitRegardAsConvexOrConcaveLineMinLineLen[BdLineDtSnsIndex],
                        0,
                        g, // or MaxObjPtDeltaYIndex1 - 1 ??
                        FALSE,
                        bRightSideBorderLine,
                        APASnsIndex,
                        BdLineDtSnsIndex);
                  }
                }
                if (bCalResult == TRUE) {
                  // OK,
                  pBorderLine->LinePar.K        = BdLinePar.A;
                  pBorderLine->LinePar.B        = BdLinePar.C;
                  pBorderLine->StartPtIndex     = ValidObjPtIndexBuf[0]; // the inflextion point
                  pBorderLine->EndPtIndex       = ValidObjPtIndexBuf[g]; // the inflextion point
                  pBorderLine->FitLineShapeType = APASlotPObjShape_Concave;
                  pBorderLine->LineBOffsetDis   = 0;
                  // pBorderLine->NearestPointToCar.x = mX;
                  // pBorderLine->NearestPointToCar.y = mY;
                  // pBorderLine->LineDepth = fTemp;
                  return TRUE;
                }
                return FALSE;
              } else {
                // It is an invalid line curve
                // just return false ??
              }
            }
          } else {
            // regarded as straight line ??
          }

        } else {
          // Out of scope ??
        }
      }
    } else {
      // It is a big shape.
    }
  }

  // 4.4 get rid of the points at head. (remove the points which close to obj1.x or obj2.x)
  if (ObjWidthX < APACal.APASlotCorPSlotBorderLineFitStartToCheckLineShapeMinObjXWidth) {
    // < 1.5m,
    return FALSE;
  }

  // Check if the car angle is almost reach

  if (APASlotPSlotBorderLineFitConvexShapeCheckSequence < 2) {

    if ((pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[0]].ObjDis < APACal.APASlotCorPSlotBorderLineFitFirstBkStepFitLineMaxObjDis)) {
    } else {
      for (g = 0; g < ValidObjCnt; g++) {
        k           = ValidObjPtIndexBuf[g];
        CarAngTemp1 = MATH_FABS(pSDGObjPtBuf->ObjPtBuf[k].CarPos.CarAng - USSPar.TrajCalCarEndPos.CarAng);
        if (CarAngTemp1 > (25.0 * PI / 180.0)) { // def: 15deg. it is too small.
          break;
        }
      }
      Dis1 = pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[0]].Pt.x - pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
      if ((Dis1 > 1500) && (g > 3)) {
        // Check the line.
        ValidObjCnt = g;
      } else {
        // Do not fit the object.
        return FALSE;
      }
    }
  }

  Dis2 = Obj12PtX + APACal.APASlotCorPSlotBorderLineFitDeltaObjXOffset1; // 50cm.
  i    = ValidObjCnt - 1;
  for (LineFitValidObjEndIndex = i; LineFitValidObjEndIndex > 0; LineFitValidObjEndIndex--) {
    k    = ValidObjPtIndexBuf[LineFitValidObjEndIndex];
    Dis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    if (Dis1 > Dis2) {
      break;
    }
  }
  Dis2 = pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[0]].Pt.x;
  if (LineFitValidObjEndIndex < i) {
    Dis1 = Dis2 - pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    if (Dis1 < 800) {
      // < 80cm
      LineFitValidObjEndIndex++;
    }
  }

  // LineFitValidObjEndIndex is the last valid obj index.

  // 4.5 check the shape of the line: Line with convex or concave at head

  // 4.5.1 use the start pt and half mid pt to fit the bd line:
  Dis2 -= (Dis2 - pSDGObjPtBuf->ObjPtBuf[k].Pt.x) / 2; // Half mid point.x
  for (g = 1; g < LineFitValidObjEndIndex; g++) {
    k    = ValidObjPtIndexBuf[g];
    Dis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    if (Dis1 < Dis2) {
      break;
    }
  }

  LineFitObjMidPtIndex = g; // Mid point.
  Dis1                 = USSPar.TrajCalCarEndPos.Coordinate.x;
  i                    = ValidObjPtIndexBuf[0];
  if (pSDGObjPtBuf->ObjPtBuf[i].CarPos.Coordinate.x < (Dis1 - 1200)) {
  } else {
    Dis3 = pSDGObjPtBuf->ObjPtBuf[i].CarPos.Coordinate.x - 500;
    for (i = 1; i < LineFitValidObjEndIndex; i++) {
      k    = ValidObjPtIndexBuf[i];
      Dis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
      if (Dis1 < Dis3) {
        break;
      }
    }
    if ((i + 3) < LineFitObjMidPtIndex) {
      i = k; // line fit Start Pt.
    } else {
      i--;
      i = ValidObjPtIndexBuf[i];
    }
  }
  LineStartPt.x = pSDGObjPtBuf->ObjPtBuf[i].Pt.x;
  LineStartPt.y = pSDGObjPtBuf->ObjPtBuf[i].Pt.y;
  LineMidPt.x   = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
  LineMidPt.y   = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
  bCalResult    = APATrajCalLineParABCbyTwoPoints(LineStartPt, // start pt. ValidObjPtIndexBuf[0]
                                               LineMidPt,   // Half mid pt.
                                               &StAndMidPtLine);

  if ((bCalResult == FALSE) || (StAndMidPtLine.LineType == APALineIsVertical)) {
    // Data error ??
    return FALSE;
  }

  // 4.5.2 check the point within the +/- 5cm tolerance.
  // LineLenCheckMode:
  // 0 - line with convex at head.
  // 1 - line with convex at mid.
  // 2 - line with covex at tail.

  StopCheckObjPtWithinTolObjPtX = Obj12PtX + APACal.APASlotCorPSlotBorderLineFitDeltaObjXOffset2; // 100cm.
  Dis1                          = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol2;
  for (CalCnt = 0; CalCnt < 2; CalCnt++) {
    if (CalCnt == 1) {
      Dis1 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol3;
      //} else if(CalCnt == 2){
      //	Dis1 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol3;
    }
    bCalResult = APASlotProcPInSlotFitSlotBorderLineCheckIfPointIsWithinLineTol(&StAndMidPtLine,
                                                                                pSDGObjPtBuf,
                                                                                ValidObjPtIndexBuf,
                                                                                ValidObjPtIndexBufNew,
                                                                                &ValidObjCntNew,
                                                                                Dis1,
                                                                                0,
                                                                                LineFitValidObjEndIndex,
                                                                                StopCheckObjPtWithinTolObjPtX,
                                                                                bRightSideBorderLine,
                                                                                TRUE,
                                                                                3);

    if (bCalResult == TRUE) {
      bCalResult = APASlotProcPInSlotFitSlotBorderLineAndCheckIfLineIsValid(StAndMidPtLine.A,
                                                                            pBorderLine,
                                                                            pSDGObjPtBuf,
                                                                            ValidObjPtIndexBufNew,
                                                                            0,
                                                                            (ValidObjCntNew - 1),
                                                                            bRightSideBorderLine,
                                                                            BdLineDtSnsIndex,
                                                                            ObjPtStartIndex,
                                                                            CarPosEndIndex,
                                                                            Obj12PtX,
                                                                            TRUE,
                                                                            APASnsIndex,
                                                                            0);

      if (bCalResult == TRUE) {
        // OK,
        APASlotProcPInSlotFitSlotBorderLineCheckAndOffsetBorderLine(
            &(pBorderLine->LinePar), pSDGObjPtBuf, ValidObjPtIndexBuf, 0, (ValidObjCnt - 1), bRightSideBorderLine, &(pBorderLine->LineBOffsetDis));
        pBorderLine->FitLineShapeType = APASlotPObjShape_LineWithCovexAtHead;

        return TRUE;
      } else {
        // NG
      }
    }
  }
  // 4.6 check the shape of the line: Line with convex or concave at mid

  // 4.6.1 use the half of the start and mid pt and half of end and mid pt to fit the bd line:

  Dis2 = (pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[0]].Pt.x - pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[LineFitValidObjEndIndex]].Pt.x) /
         APACal.APASlotCorPSlotBorderLineFitGetRidOffLineEndPtDisCalFactor; // 1/4 point.x
  Dis3 = pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[0]].Pt.x - Dis2;
  for (g = 1; g < LineFitValidObjEndIndex; g++) {
    k    = ValidObjPtIndexBuf[g];
    Dis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    if (Dis1 < Dis3) {
      break;
    }
  }
  LineFitObjStartPtIndex = g - 1; // line fit Start Pt.

  Dis3 = pSDGObjPtBuf->ObjPtBuf[ValidObjPtIndexBuf[LineFitValidObjEndIndex]].Pt.x + Dis2;
  for (g = LineFitValidObjEndIndex - 1; g > 0; g--) {
    k    = ValidObjPtIndexBuf[g];
    Dis1 = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    if (Dis1 > Dis3) {
      break;
    }
  }
  LineFitObjEndPtIndex = g + 1; // line fit end Pt.

  if ((LineFitObjStartPtIndex + 4) > LineFitObjEndPtIndex) {
    // NG. do not need to check the line.
  } else {
    k             = ValidObjPtIndexBuf[LineFitObjStartPtIndex];
    LineStartPt.x = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    LineStartPt.y = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
    k             = ValidObjPtIndexBuf[LineFitObjEndPtIndex];
    LineEndPt.x   = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    LineEndPt.y   = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
    bCalResult    = APATrajCalLineParABCbyTwoPoints(LineStartPt, // start pt. ValidObjPtIndexBuf[LineFitObjStartPtIndex]
                                                 LineEndPt,   // line end pt.
                                                 &StAndEndPtLine);

    if ((bCalResult == FALSE) || (StAndEndPtLine.LineType == APALineIsVertical)) {
      // Data error ??
      return FALSE;
    }

    // 4.6.2 check the point within the +/- 5cm tolerance.
    Dis1 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol2;
    for (CalCnt = 0; CalCnt < 2; CalCnt++) {
      if (CalCnt == 1) {
        //	Dis1 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol3;
        //} else if(CalCnt == 2){
        Dis1 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol3;
      }

      bCalResult = APASlotProcPInSlotFitSlotBorderLineCheckIfPointIsWithinLineTol(&StAndEndPtLine,
                                                                                  pSDGObjPtBuf,
                                                                                  ValidObjPtIndexBuf,
                                                                                  ValidObjPtIndexBufNew,
                                                                                  &ValidObjCntNew,
                                                                                  Dis1,
                                                                                  0,
                                                                                  LineFitValidObjEndIndex,
                                                                                  StopCheckObjPtWithinTolObjPtX,
                                                                                  bRightSideBorderLine,
                                                                                  TRUE,
                                                                                  4);

      if (bCalResult == TRUE) {
        bCalResult = APASlotProcPInSlotFitSlotBorderLineAndCheckIfLineIsValid(StAndEndPtLine.A,
                                                                              pBorderLine,
                                                                              pSDGObjPtBuf,
                                                                              ValidObjPtIndexBufNew,
                                                                              0,
                                                                              (ValidObjCntNew - 1),
                                                                              bRightSideBorderLine,
                                                                              BdLineDtSnsIndex,
                                                                              ObjPtStartIndex,
                                                                              CarPosEndIndex,
                                                                              Obj12PtX,
                                                                              TRUE,
                                                                              APASnsIndex,
                                                                              1);

        if (bCalResult == TRUE) {
          // OK,
          APASlotProcPInSlotFitSlotBorderLineCheckAndOffsetBorderLine(
              &(pBorderLine->LinePar), pSDGObjPtBuf, ValidObjPtIndexBuf, 0, (ValidObjCnt - 1), bRightSideBorderLine, &(pBorderLine->LineBOffsetDis));
          pBorderLine->FitLineShapeType = APASlotPObjShape_LineWithCovexAtMid;
          return TRUE;
        } else {
          // NG
        }
      }
    }
  }

  // 4.7 check the shape of the line: Line with convex or concave at tail

  // 4.7.1 use the half of the start and end pt and half of end and mid pt to fit the bd line:

  if (LineFitObjMidPtIndex > 3) {
    LineFitObjMidPtIndex--; // LineFitObjMidPtIndex: line fit Start Pt.
  } else {
    // NG.
    return FALSE;
  }

  // LineFitObjEndPtIndex: line fit end Pt.

  if ((LineFitObjMidPtIndex + 2) > LineFitObjEndPtIndex) {
    // NG. do not need to check the line.
  } else {
    k             = ValidObjPtIndexBuf[LineFitObjMidPtIndex];
    LineStartPt.x = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    LineStartPt.y = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
    k             = ValidObjPtIndexBuf[LineFitObjEndPtIndex];
    LineEndPt.x   = pSDGObjPtBuf->ObjPtBuf[k].Pt.x;
    LineEndPt.y   = pSDGObjPtBuf->ObjPtBuf[k].Pt.y;
    bCalResult    = APATrajCalLineParABCbyTwoPoints(LineStartPt, // start pt. ValidObjPtIndexBuf[LineFitObjMidPtIndex]
                                                 LineEndPt,   // line end pt.
                                                 &StAndEndPtLine);

    if ((bCalResult == FALSE) || (StAndEndPtLine.LineType == APALineIsVertical)) {
      // Data error ??
      return FALSE;
    }

    // 4.6.2 check the point within the +/- 5cm tolerance.
    Dis1 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol2;
    for (CalCnt = 0; CalCnt < 2; CalCnt++) {
      if (CalCnt == 1) {
        Dis1 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol3;
        //} else if(CalCnt == 2){
        //	Dis1 = APACal.APASlotCorPSlotBorderLineFitRegardAsStraightLineDeltaYTol3;
      }

      bCalResult = APASlotProcPInSlotFitSlotBorderLineCheckIfPointIsWithinLineTol(&StAndEndPtLine,
                                                                                  pSDGObjPtBuf,
                                                                                  ValidObjPtIndexBuf,
                                                                                  ValidObjPtIndexBufNew,
                                                                                  &ValidObjCntNew,
                                                                                  Dis1,
                                                                                  0,
                                                                                  LineFitValidObjEndIndex,
                                                                                  StopCheckObjPtWithinTolObjPtX,
                                                                                  bRightSideBorderLine,
                                                                                  TRUE,
                                                                                  5);

      if (bCalResult == TRUE) {
        bCalResult = APASlotProcPInSlotFitSlotBorderLineAndCheckIfLineIsValid(StAndEndPtLine.A,
                                                                              pBorderLine,
                                                                              pSDGObjPtBuf,
                                                                              ValidObjPtIndexBufNew,
                                                                              0,
                                                                              (ValidObjCntNew - 1),
                                                                              bRightSideBorderLine,
                                                                              BdLineDtSnsIndex,
                                                                              ObjPtStartIndex,
                                                                              CarPosEndIndex,
                                                                              Obj12PtX,
                                                                              TRUE,
                                                                              APASnsIndex,
                                                                              2);

        if (bCalResult == TRUE) {
          // OK,
          APASlotProcPInSlotFitSlotBorderLineCheckAndOffsetBorderLine(
              &(pBorderLine->LinePar), pSDGObjPtBuf, ValidObjPtIndexBuf, 0, (ValidObjCnt - 1), bRightSideBorderLine, &(pBorderLine->LineBOffsetDis));
          pBorderLine->FitLineShapeType = APASlotPObjShape_LineWithCovexAtTail;
          return TRUE;
        } else {
          // NG
        }
      }
    }
  }

#if 0
	if(BdLinePar.A > APACal.APASlotCorPSlotBorderLineFitCarNeedToReachAlmostEndPosMinBdLineAng) {
		if(BdLineLenWithMinTol < APACal.APASlotCorPSlotBorderLineFitRegardAsValidBdLineMinLen2) {
			return FALSE;
		}
		// Check the valid border line length.
		if(BdLineLenWithMinTol < APACal.APASlotCorPSlotBorderLineFitRegardAsValidBdLineMinLen1) {
			if(pSDGObjPtBuf->ObjPtBuf[0].CarPos.Coordinate.x <
					(USSPar.TrajCalCarEndPos.Coordinate.x - 1300)) {
				return FALSE;
			}
			Dis2 = AllowedMinBdLineLen;
			Dis2 += 300;
			if(Dis2 > 3000) {
				Dis2 = 3000;
			}
			if(BdLineLen < Dis2) {
				return FALSE;
			}
		}
	}
#endif

  return FALSE;
}
/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcInSlotSlotCheckIfBorderLineCanBeFittedWithSDGObjBuf(
 SDGObjPtBufType *pSDGObjPtBuf, APA_ENUM_TYPE SDGSnsIndex) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2-11 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

BOOLEAN APASlotProcInSlotSlotCheckIfBorderLineCanBeFittedWithSDGObjBuf(SDGObjPtBufType *pSDGObjPtBuf, APA_ENUM_TYPE SDGSnsIndex) {
  APA_INDEX_TYPE ObjPtCnt, g, m, MaxObjIndex, APASnsIndex;
  APA_DISTANCE_TYPE MinObjDis, CarPosMaxX, Dis1, Dis2, ObjPtX;
  APA_DISTANCE_CAL_FLOAT_TYPE mX;
  APA_DISTANCE_TYPE RegardSlotBorderLineExistMaxDeltaCarPosX;

  ObjPtCnt = pSDGObjPtBuf->ObjPtCnt;

  if (ObjPtCnt == 0) {
    return FALSE;
  }

  mX = USSPar.APACarCenterPt.Coordinate.x;

  if (mX > USSPar.TrajCalCarEndPos.Coordinate.x) {
    mX = USSPar.TrajCalCarEndPos.Coordinate.x;
  }

  Dis1 = mX;
  Dis2 = Dis1 - pSDGObjPtBuf->ObjPtBuf[0].CarPos.Coordinate.x;
  if (Dis2 > APACal.APASlotPRegardSlotBorderLineExistMaxDeltaCarPosX) {
    // Obj Pt may not be fitted ??
    return FALSE;
  }

  if ((SDGSnsIndex == SDG_RRS_SNS_INDEX) || (SDGSnsIndex == SDG_FRS_SNS_INDEX)) {
    // right sensor.
    /*if(USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == FALSE){
     return FALSE;
     }*/
    ObjPtX = USSPar.TrajCalObj2Pos.x;
  } else {
    // left sensor.
    /*
     if(USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == FALSE){
     return FALSE;
     }*/
    ObjPtX = USSPar.TrajCalObj1Pos.x;
  }

  if (SDGSnsIndex == SDG_RRS_SNS_INDEX) {
    APASnsIndex = APA_RRS_SNS_INDEX;
  } else if (SDGSnsIndex == SDG_FRS_SNS_INDEX) {
    APASnsIndex = APA_RR_SNS_INDEX;
  } else if (SDGSnsIndex == SDG_RLS_SNS_INDEX) {
    APASnsIndex = APA_RLS_SNS_INDEX;
  } else {
    APASnsIndex = APA_RL_SNS_INDEX;
  }

  MaxObjIndex = ObjPtCnt;
  MinObjDis   = NO_OBJ_DISTANCE;
  for (g = 0; g < ObjPtCnt; g++) {
    Dis1 = pSDGObjPtBuf->ObjPtBuf[g].Pt.x - ObjPtX;
    if (Dis1 < APACal.APASlotCorPSlotBorderLineFitStartDeltaObjX) {
      // < -40cm.
      break;
    }
    CarPosMaxX = APASlotProcInSlotCalculateSlotBorderLineGetMaxCarPosXWithCarAng(pSDGObjPtBuf->ObjPtBuf[g].CarPos.CarAng, APASnsIndex);
    if (pSDGObjPtBuf->ObjPtBuf[g].CarPos.Coordinate.x < CarPosMaxX) {
      if (pSDGObjPtBuf->ObjPtBuf[g].ObjDis < MinObjDis) {
        MinObjDis = pSDGObjPtBuf->ObjPtBuf[g].ObjDis;
        // MinDisObjIndex = g;
      }
      if (MaxObjIndex == ObjPtCnt) {
        MaxObjIndex = g;
      }
    }
  }

  for (m = MaxObjIndex; m < g; m++) {
    if ((pSDGObjPtBuf->ObjPtBuf[m].ObjDis - MinObjDis) < APACal.APASlotPRegardSlotBorderLineExistMaxDeltaObjDis) {
      break;
    }
  }

  if ((USSPar.TrajCalCarEndPos.CarAng - pSDGObjPtBuf->ObjPtBuf[MaxObjIndex].CarPos.CarAng) <
      APACal.APASlotPRegardSlotBorderLineExistCheckMinDeltaCarAng) {
    RegardSlotBorderLineExistMaxDeltaCarPosX = APACal.APASlotPRegardSlotBorderLineExistMaxDeltaCarPosXCarAngAchieved;
  } else {
    RegardSlotBorderLineExistMaxDeltaCarPosX = APACal.APASlotPRegardSlotBorderLineExistMaxDeltaCarPosX;
  }

  if ((pSDGObjPtBuf->ObjPtBuf[MaxObjIndex].CarPos.Coordinate.x - pSDGObjPtBuf->ObjPtBuf[m].CarPos.Coordinate.x) >
      RegardSlotBorderLineExistMaxDeltaCarPosX) {
    return FALSE;
  }

  return TRUE;
}
/*************************************************************************************************************************************************
 ** Syntax :  void APASlotProcCorrectSlotDuringParkingIn(void) **
 **                                                                                                                                              **
 ** Service ID:   : NO.2                                                                                                                           **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
#if Debug_SW_PARKINFUNC
void APASlotProcCorrectSlotDuringParkingIn(void) {
  // Notes:
  // For the USSPar.APASnsDtdObjDisInfoBuf[], it can contain up to 25 points (1s).
  APACarCoordinateDataCalFloatType CarCenterPt;
  APA_ENUM_TYPE ObjPtCnt, ObjIndex, ObjIndex2, ObjIndex3, CalResult;
  APA_DISTANCE_TYPE ObjPt1Y, ObjPt2X, SlotLen, Dis1, Dis2, Dis3, Dis4;
  BOOLEAN bFlag, bFlag2, bRightSideLineExist, bLeftSideLineExist;
  BOOLEAN bCarHitFObj, bCarHitRObj, bCarCloseToRObj, bObjDtdBySns, bObjCorBySns;
  BOOLEAN bLeftAndRightSideLineDeltaAngIsBig;
  BOOLEAN bInhibitObj1YUpdate, bInhibitObj2YUpdate;
  APA_DISTANCE_TYPE RearSnsDtMinDis, RRSSnsDtDis, RRSnsDtDis, RRMSnsDtDis;
  APA_DISTANCE_TYPE RLSnsDtDis, RLMSnsDtDis, RRMRLMSnsDtDis;
  // tDtObjSnsDtObjNearestDisInfoType RearSnsDtNearestDisTemp;
  APASlotCoordinateDataCalFloatType SlotPt;
  APASlotCoordinateDataCalFloatType RRCSnsPt;
  APASlotCoordinateDataCalFloatType RLCSnsPt;
  APACoordinateDataCalFloatType ObjPt, CarCornerPt, CarRCornerPt, CarLCornerPt;
  APA_DISTANCE_CAL_FLOAT_TYPE fDis1, fDis2, fDis3;
  APA_ENUM_TYPE Obj1YCorMethod, Obj2YCorMethod;
  SDGObjPointType SDGRObjPt;
  APALineParameterKBType RightSideLine, LeftSideLine, EndPosLine;
  APA_ANGLE_CAL_FLOAT_TYPE LineAng, CarAngTemp, DeltaCarAngTol;
  BOOLEAN bAPACarIsRunningBackwards, bAPACarPrevDrvDirIsBackwards, bRRCSnsDisUpdated, bRLCSnsDisUpdated;
  APACoordinateDataType CarPosMax1, CarPosMin1;
  APALineParameterABCType LineParTemp;
  SDGObjPtBufType *pSDGObjPtBuf;
  APA_DISTANCE_TYPE EndPosToCurCarPosDeltaX;
  APA_ANGLE_CAL_FLOAT_TYPE EndPosToCurCarPosDeltaAng, CurCarAngAbs;
  APA_INDEX_TYPE DeltaAngIndex;
  APA_INDEX_TYPE RRCDisIndex;
  APA_INDEX_TYPE RLCDisIndex;
  APA_INDEX_TYPE SDGBufDisIndex;
  APA_INDEX_TYPE CorSnsXDisBiggerThanThresholdCnt;
  APA_ANGLE_CAL_FLOAT_TYPE APASlotCorPCarMayHitObj2CorRRCSnsMaxCompensateAng;
  APA_ANGLE_CAL_FLOAT_TYPE APASlotCorPCarMayHitObj1CorRLCSnsMaxCompensateAng;
  APA_DISTANCE_TYPE SlotObj1X, SlotObj1Y, SlotObj2X, SlotObj2Y, EndPosLineUpdateCTol;
  BOOLEAN bCompDisMethodFlag, bCarHitObj2;
  APA_ENUM_TYPE CarInTheSlotEndPosAngAchievedDriveForwardAndBackwardCnt;

#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
  BOOLEAN bCarEndPosChanged     = FALSE;
  BOOLEAN bCarEndPosLineChanged = FALSE;
#endif

  // zp
  APA_ENUM_TYPE SubSlotCaled;
  APA_ANGLE_CAL_FLOAT_TYPE NewCarAngToBeTransfered;
  NewCarAngToBeTransfered = USSPar.ParkProcAPATargetSteeringWheelAngle;
  APACoordinateDataCalFloatType NewCarCenterPtToBeTransfered;
  if (USSPar.APACarParkingMode == APA_PARKPROC_PARKING_MODE_PARALLEL) {
    CalResult                               = 0;
    SubSlotCaled                            = 0x7f;
    USSPar.TrajCalAPATrajectoryCalResult = APATrajCalParallelSetupSystemCoordinateAccordingToSlotData(
        &CalResult, 0, &SubSlotCaled, &NewCarAngToBeTransfered, &NewCarCenterPtToBeTransfered);
    // Setup system coordinate twice because for the curve road, it can get more acurate end pos angle.
    USSPar.TrajCalAPATrajectoryCalResult = APATrajCalParallelSetupSystemCoordinateAccordingToSlotData(
        &CalResult, 2, &SubSlotCaled, &NewCarAngToBeTransfered, &NewCarCenterPtToBeTransfered);
    if (SubSlotCaled == 0) {
      APATrajCalParallelSetupSystemCoordinateAccordingToSlotData(
          &CalResult, 1, &SubSlotCaled, &NewCarAngToBeTransfered, &NewCarCenterPtToBeTransfered);
    }
    if (USSPar.TrajCalAPATrajectoryCalResult == TRUE) {
      APATrajCalParallelSetupSystemCoordinateAccordingToSlotDataCheckObj2StartEdge();
      APATrajCalDistanceBetweenOriginalPtAndObj2(0);
    }
  } else if (USSPar.APACarParkingMode == APA_PARKPROC_PARKING_MODE_PERPENDICULAR) {
    USSPar.TrajCalAPATrajectoryCalResult = APATrajCalPerpendSetupSystemCoordinateAccordingToSlotData();
  } else if (USSPar.APACarParkingMode == APA_PARKPROC_PARKING_MODE_PARKEXIT) {
    //#ifdef SUPPORT_PARK_EXIT_FUNCTION
    //		USSPar.TrajCalAPATrajectoryCalResult = APATrajCalParkExitSetupSystemCoordinateAccordingToSlotData();
    //#endif
    //} else if(USSPar.APACarParkingMode == APA_PARKPROC_PARKING_MODE_ANGULAR) {
    // USSPar.TrajCalAPATrajectoryCalResult =  APATrajCalAngularSetupSystemCoordinateAccordingToSlotData();
  }
  // zp

  CarCenterPt.Coordinate.x  = USSPar.APACarCenterPt.Coordinate.x;
  CarCenterPt.Coordinate.y  = USSPar.APACarCenterPt.Coordinate.y;
  CarCenterPt.CarAng        = USSPar.APACarCenterPt.CarAng;
  bAPACarIsRunningBackwards = USSPar.APACommonFlags.Bits.bCarIsDrivingBackwards;
  EndPosToCurCarPosDeltaX   = USSPar.TrajCalCarEndPos.Coordinate.x - CarCenterPt.Coordinate.x;
  EndPosToCurCarPosDeltaAng = USSPar.TrajCalCarEndPos.CarAng - CarCenterPt.CarAng;
  SlotObj1X                 = USSPar.TrajCalObj1Pos.x;
  SlotObj1Y                 = USSPar.TrajCalObj1Pos.y;
  SlotObj2X                 = USSPar.TrajCalObj2Pos.x;
  SlotObj2Y                 = USSPar.TrajCalObj2Pos.y;

  CurCarAngAbs = MATH_FABS(CarCenterPt.CarAng);

  bAPACarPrevDrvDirIsBackwards                         = APASlotCorrectionFlag.Bits.bCarPrevDrvDirIsBackwards;
  APASlotCorrectionFlag.Bits.bCarPrevDrvDirIsBackwards = bAPACarIsRunningBackwards;

#if 1
  if (APASlotCorrectionFlag.Bits.APAEndterActiveState == FALSE) {
    // First time enter active state.
    // Init all necessary flag here.
    for (ObjIndex = 0; ObjIndex < APA_SLOT_SUPPORT_SLOT_BORDER_LINE_NUM; ObjIndex++) {
      USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[ObjIndex].StartPtIndex     = 0;
      USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[ObjIndex].EndPtIndex       = 0;
      USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[ObjIndex].FitLineShapeType = APASlotPObjShape_Unknown;
      USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[ObjIndex].LineBOffsetDis   = 0;
    }
    APASlotCorrectionFlag.Bits.APAEndterActiveState                          = TRUE;
    APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[PARearSys]      = 0;
    APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsStatic[PAFrontSys]     = 0;
    APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[PARearSys]  = 0;
    APASlotCorrectionObj12ExistCheckTimerWhenVehicleIsMovingAway[PAFrontSys] = 0;
    APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[PARearSys]        = 0;
    APASlotCorrectionObj12ExistCheckSeqWhenVehicleIsMoving[PAFrontSys]       = 0;
    APASlotCorrectionObj12ExistCheckFlag[PARearSys]                          = 0;
    APASlotCorrectionObj12ExistCheckFlag[PAFrontSys]                         = 0;
    APASlotCorrectionOriginalObj1Y                                           = SlotObj1Y;
    APASlotCorrectionOriginalObj2Y                                           = SlotObj2Y;
    APASlotCorrectionTimer                                                   = 0;
    APASlotPObj2NotExistObj1BorderLineFitSequence                            = 0;
    APASlotPSlotBorderLineFitSequence                                        = 0;
    APASlotPSlotBorderLineFitConvexShapeCheckSequence                        = 0;
    APASlotPObj1Obj2CorSequence                                              = 0;
    APASlotPrevCarAngForEndPosCarAngCor                                      = CarCenterPt.CarAng;
    bAPASlotPrevCarDrvDirForEndPosCarAngCor1                                 = bAPACarIsRunningBackwards;
    APASlotCarDrvFwBkCntForEndPosCarAngCor                                   = 0;
    APASlotPObj2XCorSequenceWithNoObj2Exist                                  = 0;
    SDGResetDetectedObj();
    // Out of slot parameter.
    SDGKeepObjPtDis                    = APACal.APASlotCorSDGKeepObjPtDis;
    SDGKeepNoObjPtDis                  = APACal.APASlotCorSDGKeepNoObjPtDis;
    SDGKeepObjPtMinDeltaDtdDis         = APACal.APASlotCorSDGKeepObjPtMinDeltaDtDis;
    SDGSnsDtObjRegionWidth             = APACal.APASlotCorSDGSnsDtObjReagionWidth;
    SDGSnsDtObjRegardedAsSameObjTolDis = APACal.APASlotCorSDGSnsDtObjRegardedAsSameObjTolDis;
    SDGSnsDtObjProbalilityPercentage   = APACal.APASlotCorSDGSnsDtObjProbalilityPercentage;

    // for perpendicular parking slot correction filter 2014 08 21
    SDGPointCanBeRemovedContiguousPointMinDisP                = APACal.APASlotCorSDGPointCanBeRemovedContiguousPointMinDisP;
    SDGPointCanBeRemovedContiguousPointMinDisP2               = APACal.APASlotCorSDGPointCanBeRemovedContiguousPointMinDisP2;
    SDGSamplePointUpdateSmallDeltaLen                         = APACal.APASlotCorSDGSamplePointUpdateSmallDeltaLen;
    SDGSamplePointUpdateSmallDeltaLen2                        = APACal.APASlotCorSDGSamplePointUpdateSmallDeltaLen2;
    SDGSamplePointCanBeRemovedMaxObjPtDeltaSlope              = APACal.APASlotCorSDGSamplePointCanBeRemovedMaxObjPtDeltaSlope;
    SDGSamplePointNoisePtCanBeRemovedRegardAsNoiseMinObjWidth = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedRegardAsNoiseMinObjWidth;
    SDGSamplePointNoisePtStartCheckBkObjWidth                 = APACal.APASlotCorSDGSamplePointNoisePtStartCheckBkObjWidth;
    SDGSamplePointNoisePtCanBeRemovedCheckMinNoObjWidth       = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedCheckMinNoObjWidth;
    SDGSamplePointNoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis;
    SDGSamplePointNoisePtCanBeRemovedHeadOrTailMaxSlope       = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedHeadOrTailMaxSlope;
    SDGSamplePointNoisePtCanBeRemovedHeadOrTailMinSlope       = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedHeadOrTailMinSlope;
    SDGSamplePointAllowedMaxDeltaSlope                        = APACal.APASlotCorSDGSamplePointAllowedMaxDeltaSlope;
    SDGSamplePointNoisePtCanBeRemovedCheckStartHeadWidth      = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedCheckStartHeadWidth;
    SDGSamplePointNoisePtCanBeRemovedCheckNoiseWidth          = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedCheckNoiseWidth;
    SDGSamplePointNoisePtCanBeRemovedMaxDis                   = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedMaxDis;
    SDGSamplePointNoisePtCanBeRemovedSameObjTol               = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedSameObjTol;
    SDGSamplePointNoisePtCanBeRemovedCheckNoiseToObjWidth     = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedCheckNoiseToObjWidth;
    SDGSamplePointNoisePtCanBeRemovedMinSameObjPtNum          = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedMinSameObjPtNum;
    SDGSamplePointNoisePtCanBeRemovedMinObjWidth              = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedMinObjWidth;
    SDGSamplePointNoisePtCanBeRemovedMaxNoiseWidthPercentage  = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedMaxNoiseWidthPercentage;
    SDGSamplePointNoisePtRegardedAsSameObjMaxDeltaObjDis      = APACal.APASlotCorSDGSamplePointNoisePtRegardedAsSameObjMaxDeltaObjDis;
    SDGSamplePointNoisePtRegardedAsSameObjMinObjWidth         = APACal.APASlotCorSDGSamplePointNoisePtRegardedAsSameObjMinObjWidth;
    SDGSamplePointUpdateLongDeltaLen                          = APACal.APASlotCorSDGSamplePointUpdateLongDeltaLen;
    SDGSamplePointCanBeRemovedMaxObjDis                       = APACal.APASlotCorSDGSamplePointCanBeRemovedMaxObjDis;
    SDGSamplePointNoisePtCanBeRemovedMinObjPtOutOfTolNum      = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedMinObjPtOutOfTolNum;
    SDGSamplePointNoisePtCanBeRemovedMinNoObjPtWitinNoiseNum  = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedMinNoObjPtWitinNoiseNum;
    SDGSamplePointNoisePtCanBeRemovedMinNoObjPtTotalNum       = APACal.APASlotCorSDGSamplePointNoisePtCanBeRemovedMinNoObjPtTotalNum;

    if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
      APASlotCorrectionFlag.Bits.Obj2XHasbeenCorrectedWhenObj2DoesNotExist = TRUE;
    }
    APASlotPObj2CorAtTurnAroundObj2WithCarMayHitObj2SnsDtDis = NO_OBJ_DISTANCE;
    APASlotPObjExistCheckSequence                            = 0;

#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
    APASlotCorrectionCaledCarEndPosIndex     = 0;
    APASlotCorrectionCaledCarEndPosLineIndex = 0;
#endif
  } else {

    if ((USSPar.APACarParkingMode == APA_PARKPROC_PARKING_MODE_PERPENDICULAR) &&
        (bAPASlotPrevCarDrvDirForEndPosCarAngCor1 != bAPACarIsRunningBackwards)) {
      if (MATH_FABS(APASlotPrevCarAngForEndPosCarAngCor - CarCenterPt.CarAng) > 10.0 * PI / 180.0) {
        if (APASlotCarDrvFwBkCntForEndPosCarAngCor < 5) {
          APASlotCarDrvFwBkCntForEndPosCarAngCor++;
        }
        bAPASlotPrevCarDrvDirForEndPosCarAngCor1 = bAPACarIsRunningBackwards;
        APASlotPrevCarAngForEndPosCarAngCor      = CarCenterPt.CarAng;
        if (APASlotCarDrvFwBkCntForEndPosCarAngCor > 2) {
          // Corrent the car end pos angle.
          if (APASlotCorrectionFlag.Bits.SlotBorderLineHasBeenCorrected == FALSE) {
            CarAngTemp = PI / 2.0;
            LineAng    = APASlotCarDrvFwBkCntForEndPosCarAngCor - 2;
            LineAng *= APACal.APASlotCorPCarEndPosAngCompensateAngPerFrwAndBk;
            CarAngTemp += LineAng;
            LineAng = MATH_TAN(LineAng);
            fDis1   = LineAng * USSPar.TrajCalCarEndPos.Coordinate.x + USSPar.TrajCalCarEndPosLine.C;

            USSPar.TrajCalCarEndPos.CarAng       = CarAngTemp;
            USSPar.TrajCalCarEndPos.Coordinate.y = fDis1;
            USSPar.TrajCalCarEndPosLine.LineType = APALineIsIncline;
            USSPar.TrajCalCarEndPosLine.A        = LineAng;
            USSPar.TrajCalCarEndPosLine.B        = 1.0;
            USSPar.TrajCalSlotLeftSideLine.K     = LineAng;
            // USSPar.TrajCalSlotLeftSideLine.B = USSPar.TrajCalObj1Pos.y;
            USSPar.TrajCalSlotRightSideLine.K = LineAng;
            // USSPar.TrajCalSlotRightSideLine.B = USSPar.TrajCalObj2Pos.y;
          } else {
          }
        }
      }
    }
  }

#ifdef APA_SLOT_SIDE_OBJ12_COR_DEBUG

  RRSSnsDtDis = APASideSnsDtObjDis[PARearSys][0];
  RLSSnsDtDis = APASideSnsDtObjDis[PARearSys][1];

  RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX];
  RLSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX];

  // if(RRSnsDtDis != NO_OBJ_DISTANCE){
  // RRSnsDtDis *= 10; // cm -> mm.
  //}

  // if(RLSnsDtDis != NO_OBJ_DISTANCE){
  // RLSnsDtDis *= 10; // cm -> mm.
  //}

  // if(Obj1YCorMethod == 0) {
  // Use RLS to correct.
  SlotPt                   = APASlotProcCalSlotRelativeToCarCoordinateBySnsDtdDis(RLSSnsDtDis, APA_RLS_SNS_INDEX);
  SlotPt.Coordinate        = APATrajCalPointPosWithAngAndCenterPt(SlotPt.Coordinate, CarCenterPt.CarAng, CarCenterPt.Coordinate);
  ObjPt1Y                  = SlotPt.Coordinate.y;
  USSPar.TrajCalObj1Pos = SlotPt.Coordinate;
  /*} else if(Obj1YCorMethod == 1) {
   // Use RL to correct.
   ObjPt = APASlotProcCalObjPtCoordinateBySnsDtdDis(RLSnsDtDis,
   - APA_SLOT_PER_OBJ1Y_OBJ2Y_CORRECT_ANG_BT_SIDE_WALL_AND_SNS_CENTER_LINE,
   APA_RL_SNS_INDEX);
   ObjPt = APATrajCalPointPosWithAngAndCenterPt(ObjPt,
   CarCenterPt.CarAng,
   CarCenterPt.Coordinate);
   ObjPt1Y = ObjPt.y;
   }*/

  SlotPt            = APASlotProcCalSlotRelativeToCarCoordinateBySnsDtdDis(RRSSnsDtDis, APA_RRS_SNS_INDEX);
  SlotPt.Coordinate = APATrajCalPointPosWithAngAndCenterPt(SlotPt.Coordinate, CarCenterPt.CarAng, CarCenterPt.Coordinate);

  // fDis1 = MATH_FABS(CarCenterPt.CarAng - USSPar.TrajCalCarEndPos.CarAng);
  // fDis1 = fDis1 / (40.0 * PI / 180.0) * 800.0;
  ObjPt2Y = SlotPt.Coordinate.y; // + fDis1;

  ObjPt =
      APASlotProcCalObjPtCoordinateBySnsDtdDis(RRSnsDtDis, APA_SLOT_PER_OBJ1Y_OBJ2Y_CORRECT_ANG_BT_SIDE_WALL_AND_SNS_CENTER_LINE, APA_RR_SNS_INDEX);
  ObjPt = APATrajCalPointPosWithAngAndCenterPt(ObjPt, CarCenterPt.CarAng, CarCenterPt.Coordinate);

  USSPar.TrajCalObj2Pos = ObjPt;

  // fDis1 = MATH_FABS(CarCenterPt.CarAng - USSPar.TrajCalCarEndPos.CarAng);
  // fDis1 = fDis1 / (40.0 * PI / 180.0) * 800.0;

  ObjPt2Y = ObjPt.y; // + fDis1;

#endif

  // Just for PC Demo we mask it. kjy 2012 10 06
  // if((PACal.cPASnsMask[PARearSys] & RS_SNS_MASK) != 0)
  {
    // 12 CH. with rear RS and LS sns.
    // if(CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_Y_MAX) {

    SDGSensorDtdObjectDisProcessTask(2);

    /*} else {
     USSPar.APASnsDtdObjDisInfoBufReadIndex = 0;
     USSPar.APASnsDtdObjDisInfoBufWriteIndex = 0;
     }*/
  }
  if (USSPar.APACarParkingMode == APA_PARKPROC_PARKING_MODE_PARALLEL) {
    // Parallel parking in

    bCarHitFObj = FALSE; // Indicate if the front bumper will hit the obj2?

    bFlag = USSPar.APACommonFlags.Bits.bParkProcCarEndPosAngleAchieved;

    // Check if the car may hit obj2.
    bCarHitObj2 = FALSE;
    if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
      if ((CarCenterPt.Coordinate.y < (USSPar.TrajCalObj2Pos.y + APACal.APASlotCarMayHitObj2CheckDeltaDisYMax)) &&
          (CarCenterPt.Coordinate.y > (USSPar.TrajCalObj2Pos.y + APACal.APASlotCarMayHitObj2CheckDeltaDisYMin)) &&
          (CarCenterPt.Coordinate.x > (USSPar.TrajCalObj2Pos.x - APACal.HalfWidthOfCar - 700)) // 70cm tolerance.
          && (CarCenterPt.Coordinate.x < (USSPar.TrajCalObj2Pos.x))) {
        RRSSnsDtDis = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.RSObjDis;
        RRSnsDtDis  = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.RObjDis;
        // RRMSnsDtDis = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.MidObjDis;
        RLMSnsDtDis = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.LObjDis;
        RLSnsDtDis  = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.LSObjDis;

        if (((RRSSnsDtDis < APACal.APAParkProcCarMayHitFrontCornerObjStopCorRRSDis) ||
             (RRSnsDtDis < APACal.APAParkProcCarMayHitFrontCornerObjStopCorRRDis))
            //&& (RRMSnsDtDis == NO_OBJ_DISTANCE)
            && (RLMSnsDtDis > 1000) && (RLSnsDtDis > 1000)) {
          // OK. meet the rear right corner may hit obj2 criteria.
          bCarHitObj2 = TRUE;
        }
      }
    }

    // 1. Correct Obj2.y
    // Check if the current car pos is within the correct range.
    bFlag2 = FALSE;
    if ((CarCenterPt.Coordinate.y > APA_SLOT_PAL_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MIN1) &&
        (EndPosToCurCarPosDeltaX > (-APACal.APASlotCorObj2YStCorMinDeltaCarPosToEndPosX)) &&
        (EndPosToCurCarPosDeltaX < (APACal.APASlotCorObj2YStCorMinDeltaCarPosToEndPosX)) &&
        (CarCenterPt.CarAng > APA_SLOT_PAL_OBJ2Y_CORRECT_RANGE_CAR_POS_ANG_MIN1) &&
        (((CarCenterPt.CarAng < APA_SLOT_PAL_OBJ2Y_CORRECT_RANGE_CAR_POS_ANG_MAX2) &&
          (CarCenterPt.Coordinate.y < APA_SLOT_PAL_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MAX2)) ||
         ((CarCenterPt.CarAng < APA_SLOT_PAL_OBJ2Y_CORRECT_RANGE_CAR_POS_ANG_MAX1) &&
          (CarCenterPt.Coordinate.y < APA_SLOT_PAL_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MAX1)))) {
      bObjDtdBySns = FALSE;
      bObjCorBySns = FALSE;

      // cal front corner point position. including the safety at front.
      CarAngTemp = CurCarAngAbs;

      Dis1 = USSPar.ParkProcSafetyDisToObjAtFront;

      if (CarAngTemp < (3.0 * PI / 180.0)) {
        // Just check front bumper will hit obj2 or not??

        Dis1 = APACal.LenBetweenRAxisAndFBumper + Dis1;

        CarCornerPt.y = CarCenterPt.Coordinate.y + Dis1;
      } else {
        if (CarCenterPt.CarAng > 0) {
          // Front right corner.
          CarCornerPt.x = APACal.HalfWidthOfCar;
        } else {
          CarCornerPt.x = -APACal.HalfWidthOfCar;
        }
        CarCornerPt.y = APACal.LenBetweenRAxisAndFBumper;

        CarCornerPt = APATrajCalPointPosWithAngAndCenterPt(CarCornerPt, CarCenterPt.CarAng, CarCenterPt.Coordinate);

        // Compensate the curve of the front bumper.
        fDis1 = APACal.LenBetweenFrontRectCornerToFrontBumperCornerCurve;
        if (CarAngTemp > (PI / 4.0)) {
          CarAngTemp = PI / 2.0 - CarAngTemp;
        }
        if (CarAngTemp < (20.0 * PI / 180.0)) {
          fDis1 *= (CarAngTemp / (20.0 * PI / 180.0));
        }
        CarCornerPt.y -= fDis1;

        CarCornerPt.y += Dis1;
      }

      for (CalResult = 0; CalResult < 2; CalResult++) {
        if (bFlag == FALSE) {

          // OK car pos within range.
          // Check the current RRC / RRS dt obj dis.

          if (bAPACarIsRunningBackwards == FALSE) {

            if (USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
              // Actually RRSSnsDtDis : left side sns
              RRSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_L_RX_OBJ_INDEX];
              }
              RRMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX];
              }

              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wY[LM_RM_TRIANGLE_OBJ_INDEX];
              }

              RLMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX];
              }

              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wY[RM_LM_TRIANGLE_OBJ_INDEX];
              }
            } else {
              RRSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_R_RX_OBJ_INDEX];
              }
              RRMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX];
              }
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wY[RM_LM_TRIANGLE_OBJ_INDEX];
              }

              RLMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX];
              }
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = SnsDtObjNearestDisInfo[PAFrontSys].wY[LM_RM_TRIANGLE_OBJ_INDEX];
              }
            }
          } else {

            if (USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
              // Actually RRSSnsDtDis : left side sns
              RRSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_L_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }

              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wY[LM_RM_TRIANGLE_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }

              RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }

              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wY[RM_LM_TRIANGLE_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
            } else {
              RRSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_R_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wY[RM_LM_TRIANGLE_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }

              RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PAFrontSys].wY[LM_RM_TRIANGLE_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
            }
          }
          /*if(RRSnsDtDis != NO_OBJ_DISTANCE){
           RRSnsDtDis *= 10; // cm -> mm.
           }
           if(RRMSnsDtDis != NO_OBJ_DISTANCE){
           RRMSnsDtDis *= 10; // cm -> mm.
           }
           if(RLMSnsDtDis != NO_OBJ_DISTANCE){
           RLMSnsDtDis *= 10; // cm -> mm.
           }*/

          if ((RRSnsDtDis <= (APACal.APASlotCorObj2YStCorMaxCornerSnsDtDis1 + 400)) || (RRMSnsDtDis != NO_OBJ_DISTANCE) ||
              (RLMSnsDtDis != NO_OBJ_DISTANCE)) {
            bObjDtdBySns = TRUE;
          }

          Obj2YCorMethod  = APA_SUPPORT_APA_SNS_NUM; // no correction. sns index.
          RearSnsDtMinDis = NO_OBJ_DISTANCE;

#if 0 // debug the front sns detect dis accuracy and calibration value.
					RearSnsDtMinDis = RLMSnsDtDis;
					Obj2YCorMethod = APA_FLM_SNS_INDEX;
					fDis2 = APACal.APASlotCorObj2YCompensateDisByCarAng[2]; // FLM sns.

#else
          if ((CurCarAngAbs < APA_SLOT_PAL_OBJ2Y_COR_USE_MID_SNS_CAR_POS_ANG_MAX1) && (APASlotCorrectionFlag.Bits.Obj2YHasBeenCorrected == TRUE)) {
            // Use mid sns
            if (RRMSnsDtDis < RLMSnsDtDis) {
              RearSnsDtMinDis = RRMSnsDtDis;
              Obj2YCorMethod  = APA_FRM_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj2YCompensateDisByCarAng[2]; // FRM sns.

            } else {
              RearSnsDtMinDis = RLMSnsDtDis;
              Obj2YCorMethod  = APA_FLM_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj2YCompensateDisByCarAng[1]; // FLM sns.
            }
          } else {
            // use min dis sns.
            fDis1 = APA_SLOT_PAL_OBJ2Y_COR_USE_COR_SNS_COR_MAX_SNS_TO_SIDE_DIS;
            fDis2 = APACal.SnsAng[APA_FR_SNS_INDEX] + CarCenterPt.CarAng;
            fDis1 = fDis1 / MATH_COS(fDis2);
            Dis1  = (APA_DISTANCE_TYPE)fDis1;
            if (Dis1 < 0) {
              Dis1 = -Dis1;
            }
            if (Dis1 > APACal.APASlotCorObj2YStCorMaxCornerSnsDtDis1) {
              Dis1 = APACal.APASlotCorObj2YStCorMaxCornerSnsDtDis1;
            } else {
            }

            Dis3 = APACal.APASlotCorObj2YStCorMaxMidSnsDtDis1;
            Dis4 = APACal.APASlotCorObj2YStCorMaxMidSnsDtDis2;
            if (MATH_FABS(EndPosToCurCarPosDeltaAng) < (4.0 / 180.0 * PI)) {
            } else {
              Dis3 -= 200;
              Dis4 -= 300;
            }

            if ((RRSnsDtDis <= Dis1) && (RRSnsDtDis <= RRMSnsDtDis) && (RRSnsDtDis <= RLMSnsDtDis)) {
              RearSnsDtMinDis = RRSnsDtDis;
              Obj2YCorMethod  = APA_FR_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj2YCompensateDisByCarAng[0]; // FR sns.

            } else if (((RRMSnsDtDis <= Dis3) || ((CalResult == 1) && (RRMSnsDtDis <= Dis4))) && ((RRMSnsDtDis - 300) <= RLMSnsDtDis)) {
              // FRM has high priority.
              RearSnsDtMinDis = RRMSnsDtDis;
              Obj2YCorMethod  = APA_FRM_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj2YCompensateDisByCarAng[1]; // FRM sns.

            } else if (((RLMSnsDtDis <= Dis3) || ((CalResult == 1) && (RLMSnsDtDis <= Dis4))) && (RLMSnsDtDis <= RRMSnsDtDis)) {
              RearSnsDtMinDis = RLMSnsDtDis;
              Obj2YCorMethod  = APA_FLM_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj2YCompensateDisByCarAng[2]; // FLM sns.

            } else if ((CalResult == 1) && (RRSnsDtDis <= APACal.APASlotCorObj2YStCorMaxCornerSnsDtDis2)) {
              RearSnsDtMinDis = RRSnsDtDis;
              Obj2YCorMethod  = APA_FR_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj2YCompensateDisByCarAng[0]; // FR sns.
            }
          }

          if (bFlag2 == TRUE) {
            Obj2YCorMethod  = APA_FRM_SNS_INDEX;
            RearSnsDtMinDis = APACal.APASlotCorObj2YResetObj2YRegardAsFSnsDtObjDis;
            fDis2           = APACal.APASlotCorObj2YCompensateDisByCarAng[1]; // FRM sns.
          }

#endif
          if ((Obj2YCorMethod != APA_SUPPORT_APA_SNS_NUM) && (RearSnsDtMinDis != NO_OBJ_DISTANCE)) {
            CalResult = 2;

#if 0 // kjy changed 2014 06 07
						SlotPt = APASlotProcCalSlotRelativeToCarCoordinateBySnsDtdDis(RearSnsDtMinDis,
								Obj2YCorMethod); // sns index
#else
            SlotPt.Coordinate.x = APACal.SnsPos[Obj2YCorMethod].x;
            SlotPt.Coordinate.y = APACal.SnsPos[Obj2YCorMethod].y;
#endif

            ObjPt = APATrajCalPointPosWithAngAndCenterPt(SlotPt.Coordinate, CarCenterPt.CarAng, CarCenterPt.Coordinate);

#ifdef APA_PARKPROC_DRIVE_DIRECTION_DEBUG
            APASlotProcFrontSnsDtMinDisDebug = RearSnsDtMinDis;
#endif

            fDis1 = RearSnsDtMinDis;

            fDis2 *= CurCarAngAbs * fDis1;
            fDis2 += RearSnsDtMinDis;

            ObjPt.y += fDis2;

            if ((ObjPt.y < APA_SLOT_PAL_OBJ2Y_COR_OBJ2Y_MAX1) && (ObjPt.y > APA_SLOT_PAL_OBJ2Y_COR_OBJ2Y_MIN1)) {
              // Obj2Y is corrected.
              SlotLen      = ObjPt.y - USSPar.TrajCalObj1Pos.y;
              bObjCorBySns = APASlotProcCorrectSlotReCalculateTheSlotObj2YEndPosY(ObjPt.y, SlotLen);
            }
          }
        }

        // 3. Check if the car will hit obj1 or obj2 in the slot ??
        // 3.1 Front bumper
        if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
          if (CarCornerPt.y > USSPar.TrajCalObj2Pos.y) {
            // Car will hit front obj2.
            bCarHitFObj = TRUE;
            if (EndPosToCurCarPosDeltaX > APACal.APASlotCorObj2YResetObj2YEndPosToCurCarPosDeltaX) {
              if (CarCornerPt.y > (USSPar.TrajCalObj2Pos.y + APACal.APASlotCorObj2YResetObj2YCarFBumperOverObj2YDis)) {
                // Just reset obj2.
                if (bFlag2 == FALSE) {
                  CalResult = 0;
                  bFlag2    = TRUE;
                }
                bCarHitFObj = FALSE;
              }
            }
          } else {
            CalResult = 2;
          }
        } else {
          // CalResult = 2; ??? do we need to recal obj2 with big sns dt dis ???
        }
      }

      Dis1 = (APA_DISTANCE_TYPE)CarCornerPt.y;
      APASlotProcCorrectObj12YDuringParallelParkingInCheckResetOfObjY(
          bObjDtdBySns, bObjCorBySns, PAFrontSys, Dis1, SlotObj1Y, SlotObj2Y, EndPosToCurCarPosDeltaX);
    }

    // 2. Correct Obj1.Y
    // Check if the current car pos is within the correct range.
    bCarHitRObj = FALSE; // Indicate if the rear bumper will hit the obj2?
    bFlag2      = FALSE;
    if ((CarCenterPt.Coordinate.y > APA_SLOT_PAL_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MIN1) && (EndPosToCurCarPosDeltaX > (-APACal.HalfWidthOfCar)) &&
        (EndPosToCurCarPosDeltaX < APACal.APASlotCorObj1YStCorMinDeltaCarPosToEndPosX) &&
        (CarCenterPt.CarAng > APA_SLOT_PAL_OBJ1Y_CORRECT_RANGE_CAR_POS_ANG_MIN1) &&
        (((CarCenterPt.CarAng < APA_SLOT_PAL_OBJ1Y_CORRECT_RANGE_CAR_POS_ANG_MAX2) &&
          (CarCenterPt.Coordinate.y < APA_SLOT_PAL_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MAX1)) ||
         ((CarCenterPt.CarAng < APA_SLOT_PAL_OBJ1Y_CORRECT_RANGE_CAR_POS_ANG_MAX1) &&
          (CarCenterPt.Coordinate.y < APA_SLOT_PAL_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MAX2)))) {
      bObjDtdBySns = FALSE;
      bObjCorBySns = FALSE;

      CarAngTemp = CurCarAngAbs;

      Dis1 = USSPar.ParkProcSafetyDisToObjAtRear;

      if (CarAngTemp < (3.0 * PI / 180.0)) {
        // Just check front bumper will hit obj2 or not??

        Dis1          = APACal.LenBetweenRAxisAndRBumper + Dis1;
        CarCornerPt.y = CarCenterPt.Coordinate.y - Dis1;
      } else {
        if (CarCenterPt.CarAng > 0) {
          // rear left corner.
          CarCornerPt.x = -APACal.HalfWidthOfCar;
        } else {
          CarCornerPt.x = APACal.HalfWidthOfCar;
        }
        CarCornerPt.y = -APACal.LenBetweenRAxisAndRBumper;

        CarCornerPt = APATrajCalPointPosWithAngAndCenterPt(CarCornerPt, CarCenterPt.CarAng, CarCenterPt.Coordinate);

        // Compensate the curve of the front bumper.
        fDis1 = APACal.LenBetweenRearRectCornerToRearBumperCornerCurve;
        if (CarAngTemp > (PI / 4.0)) {
          CarAngTemp = PI / 2.0 - CarAngTemp;
        }
        if (CarAngTemp < (20.0 * PI / 180.0)) {
          fDis1 *= (CarAngTemp / (20.0 * PI / 180.0));
        }
        CarCornerPt.y += fDis1;
        CarCornerPt.y -= Dis1;
      }

      for (CalResult = 0; CalResult < 2; CalResult++) {
        if (bFlag == FALSE) {
          // OK car pos within range.
          // Check the current RRC / RRS dt obj dis.

          CarInTheSlotEndPosAngAchievedDriveForwardAndBackwardCnt = USSPar.ParkProcCarInTheSlotEndPosAngAchievedDriveForwardAndBackwardCnt;

          if (bAPACarIsRunningBackwards == FALSE) {
            if (USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
              // Actually RRSSnsDtDis : left side sns
              RRSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_R_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wY[RM_LM_TRIANGLE_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }

              RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }

              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wY[LM_RM_TRIANGLE_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }

            } else {
              RRSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_L_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wY[LM_RM_TRIANGLE_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = DtObjUPASnsDtObjDisInfo[PARearSys].wY[RM_LM_TRIANGLE_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
              }
            }
          } else {
            if (USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
              // Actually RRSSnsDtDis : left side sns
              RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_R_RX_OBJ_INDEX];
              }
              RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX];
              }
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wY[RM_LM_TRIANGLE_OBJ_INDEX];
              }

              RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX];
              }

              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wY[LM_RM_TRIANGLE_OBJ_INDEX];
              }

            } else {
              RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_L_RX_OBJ_INDEX];
              }
              RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX];
              }
              if (RLMSnsDtDis == NO_OBJ_DISTANCE) {
                RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wY[LM_RM_TRIANGLE_OBJ_INDEX];
              }
              RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX];
              }
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wY[RM_LM_TRIANGLE_OBJ_INDEX];
              }
            }
          }

          /*if(RRSnsDtDis != NO_OBJ_DISTANCE){
           RRSnsDtDis *= 10; // cm -> mm.
           }
           if(RRMSnsDtDis != NO_OBJ_DISTANCE){
           RRMSnsDtDis *= 10; // cm -> mm.
           }
           if(RLMSnsDtDis != NO_OBJ_DISTANCE){
           RLMSnsDtDis *= 10; // cm -> mm.
           }*/

          if ((RRSnsDtDis <= (APACal.APASlotCorObj1YStCorMaxCornerSnsDtDis + 400)) ||
              (RRMSnsDtDis <= (APACal.APASlotCorObj1YStCorMaxMidSnsDtDis2 + 400)) ||
              (RLMSnsDtDis <= (APACal.APASlotCorObj1YStCorMaxMidSnsDtDis2 + 400))) {
            bObjDtdBySns = TRUE;
          }

#if 0 // debug the rear sns detect dis accuracy and calibration value.

					RearSnsDtMinDis = RRMSnsDtDis;
					Obj2YCorMethod = APA_RRM_SNS_INDEX;
					fDis2 = APACal.APASlotCorObj1YCompensateDisByCarAng[2]; // RM sns.

#else

          Obj2YCorMethod  = APA_SUPPORT_APA_SNS_NUM; // no correction. sns index.
          RearSnsDtMinDis = NO_OBJ_DISTANCE;
          if ((CurCarAngAbs < APA_SLOT_PAL_OBJ1Y_COR_USE_MID_SNS_CAR_POS_ANG_MAX1) && (APASlotCorrectionFlag.Bits.Obj1YHasBeenCorrected == TRUE)) {
            // Use mid sns
            if (RRMSnsDtDis < RLMSnsDtDis) {
              RearSnsDtMinDis = RRMSnsDtDis;
              Obj2YCorMethod  = APA_RRM_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj1YCompensateDisByCarAng[2]; // RRM sns.
            } else {
              RearSnsDtMinDis = RLMSnsDtDis;
              Obj2YCorMethod  = APA_RLM_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj1YCompensateDisByCarAng[1]; // RLM sns.
            }
          } else {
            // use min dis sns.
            fDis1 = APA_SLOT_PAL_OBJ1Y_COR_USE_COR_SNS_COR_MAX_SNS_TO_SIDE_DIS;
            fDis2 = APACal.SnsAng[APA_RL_SNS_INDEX] - PI + CarCenterPt.CarAng;
            fDis1 = fDis1 / MATH_COS(fDis2);
            Dis1  = (APA_DISTANCE_TYPE)fDis1;
            if (Dis1 < 0) {
              Dis1 = -Dis1;
            }
            if (Dis1 > APACal.APASlotCorObj1YStCorMaxCornerSnsDtDis) {
              Dis1 = APACal.APASlotCorObj1YStCorMaxCornerSnsDtDis;
            } else {
            }

            Dis4 = APACal.APASlotCorObj1YStCorMaxMidSnsDtDis;
            if (CarInTheSlotEndPosAngAchievedDriveForwardAndBackwardCnt == 0) {
              if (MATH_FABS(EndPosToCurCarPosDeltaAng) < (4.0 / 180.0 * PI)) {
                Dis4 = APACal.APASlotCorObj1YStCorMaxMidSnsDtDis3;
              }
            }

            if ((RRSnsDtDis < Dis1) && (RRSnsDtDis <= RRMSnsDtDis) && (RRSnsDtDis <= RLMSnsDtDis)) {
              RearSnsDtMinDis = RRSnsDtDis;
              Obj2YCorMethod  = APA_RL_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj1YCompensateDisByCarAng[0]; // RL sns.
            } else if (((RLMSnsDtDis <= Dis4) || ((CalResult == 1) && (RLMSnsDtDis <= (APACal.APASlotCorObj1YStCorMaxMidSnsDtDis2)))) &&
                       ((RLMSnsDtDis - 300) <= RRMSnsDtDis)) {
              // Use LM sns as high priority.
              RearSnsDtMinDis = RLMSnsDtDis;
              Obj2YCorMethod  = APA_RLM_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj1YCompensateDisByCarAng[1]; // RLM sns.

            } else if (((RRMSnsDtDis <= Dis4) || ((CalResult == 1) && (RRMSnsDtDis <= (APACal.APASlotCorObj1YStCorMaxMidSnsDtDis2)))) &&
                       (RRMSnsDtDis <= RLMSnsDtDis)) {
              RearSnsDtMinDis = RRMSnsDtDis;
              Obj2YCorMethod  = APA_RRM_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj1YCompensateDisByCarAng[2]; // RM sns.

            } else if ((CalResult == 1) && (RRSnsDtDis <= (Dis1 + 1000))) {
              RearSnsDtMinDis = RRSnsDtDis;
              Obj2YCorMethod  = APA_RL_SNS_INDEX;
              fDis2           = APACal.APASlotCorObj1YCompensateDisByCarAng[0]; // RL sns.
            }
          }

          if (bFlag2 == TRUE) {
            fDis2           = APACal.APASlotCorObj1YCompensateDisByCarAng[1]; // RLM sns.
            Obj2YCorMethod  = APA_RLM_SNS_INDEX;
            RearSnsDtMinDis = APACal.APASlotCorObj1YResetObj1YRegardAsRSnsDtObjDis;
          }

#endif

          if ((Obj2YCorMethod != APA_SUPPORT_APA_SNS_NUM) && (RearSnsDtMinDis != NO_OBJ_DISTANCE)) {
            CalResult = 2;

#if 0 // kjy changed 2014 06 07
						SlotPt = APASlotProcCalSlotRelativeToCarCoordinateBySnsDtdDis(RearSnsDtMinDis,
								Obj2YCorMethod); // sns index
#else
            SlotPt.Coordinate.x = APACal.SnsPos[Obj2YCorMethod].x;
            SlotPt.Coordinate.y = APACal.SnsPos[Obj2YCorMethod].y;
#endif

            ObjPt = APATrajCalPointPosWithAngAndCenterPt(SlotPt.Coordinate, CarCenterPt.CarAng, CarCenterPt.Coordinate);

#ifdef APA_PARKPROC_DRIVE_DIRECTION_DEBUG
            APASlotProcRearSnsDtMinDisDebug = RearSnsDtMinDis;
#endif

            fDis1 = RearSnsDtMinDis;

            fDis2 *= CurCarAngAbs * fDis1;
            fDis2 += RearSnsDtMinDis;

            ObjPt.y -= fDis2;

            if ((ObjPt.y < APA_SLOT_PAL_OBJ1Y_COR_OBJ1Y_MAX1) && (ObjPt.y > APA_SLOT_PAL_OBJ1Y_COR_OBJ1Y_MIN1)) {
              // Obj1Y is corrected.
              SlotLen      = USSPar.TrajCalObj2Pos.y - ObjPt.y;
              bObjCorBySns = APASlotProcCorrectSlotReCalculateTheSlotObj1YEndPosY(ObjPt.y, SlotLen);
            }
          }
        }
        // 3. Check if the car will hit obj1 or obj2 in the slot ??
        // 3.2 rear bumper
        if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE) {
          if (CarCornerPt.y < USSPar.TrajCalObj1Pos.y) {
            // Car will hit rear obj1.
            bCarHitRObj = TRUE;
            if (EndPosToCurCarPosDeltaX > APACal.APASlotCorObj1YResetObj1YEndPosToCurCarPosDeltaX) {
              if (CarCornerPt.y < (USSPar.TrajCalObj1Pos.y - APACal.APASlotCorObj1YResetObj1YCarRBumperOverObj1YDis)) {
                // Just reset obj1.
                if (bFlag2 == FALSE) {
                  CalResult = 0;
                  bFlag2    = TRUE;
                }
                bCarHitRObj = FALSE;
              }
            }
          } else if (bFlag == FALSE) {
            RearSnsDtMinDis = RRMSnsDtDis;
            if (RearSnsDtMinDis > RLMSnsDtDis) {
              RearSnsDtMinDis = RLMSnsDtDis;
            }
            Dis1 = (CarCornerPt.y - USSPar.TrajCalObj1Pos.y);
            if ((RearSnsDtMinDis != NO_OBJ_DISTANCE) && (Dis1 < APACal.APASlotCorObj1YRecalObj1YMaxDeltaCarCornerYandObj1Y) &&
                (Dis1 < RearSnsDtMinDis)) {
              // recal the obj1.Y with allowed big sns dt dis.
            } else {
              CalResult = 2;
            }
          }
        } else {
          CalResult = 2;
        }
      }

      Dis1 = (APA_DISTANCE_TYPE)CarCornerPt.y;
      APASlotProcCorrectObj12YDuringParallelParkingInCheckResetOfObjY(
          bObjDtdBySns, bObjCorBySns, PARearSys, Dis1, SlotObj1Y, SlotObj2Y, EndPosToCurCarPosDeltaX);
    }

    APACarInSlotCarMayHitObj1Or2Flag.Bits.CarInSlotFrontBumperHitObj1Or2 = bCarHitFObj;
    APACarInSlotCarMayHitObj1Or2Flag.Bits.CarInSlotRearBumperHitObj1Or2  = bCarHitRObj;
    APASlotCorrectionFlag.Bits.Obj2YHasBeenCorrectedDueToRRCMayHitObj2   = bCarHitObj2;

    // 3. Check if the car will hit obj1 or obj2 in the slot ??
    // 3.1 Front bumper

  } else if (USSPar.APACarParkingMode == APA_PARKPROC_PARKING_MODE_PERPENDICULAR) {
    // Perpendicular parking in

    // Check if it is necessary to remove RRS, RRC the SDG buf header
    // RRS sns:

    if ((CarCenterPt.Coordinate.y < USSPar.TrajCalObj2Pos.y) && (CarCenterPt.Coordinate.x > 500)) {

      ObjIndex = SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtCnt;
      Dis1     = SlotObj2Y + 2000;
      bFlag2   = FALSE;
      while (ObjIndex > (SDG_MAX_SUPPORT_OBJ_POINT_BUF_SIZE / 3)) {
        ObjIndex--;
        if (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.y > Dis1) {
          if (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.CarAng < (USSPar.TrajCalCarEndPos.CarAng - 60.0 * PI / 180.0)) {
            // OK, point can be removed.
            bFlag2 = TRUE;
          } else {
            break;
          }
        } else {
          break;
        }
      }
      if (bFlag2 == TRUE) {
        // Remove the point from objIndex + 1 -> ObjPtCnt - 1;
        SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtCnt = ObjIndex + 1;
        if (ObjIndex < SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].WrIndex) {
          SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].WrIndex = ObjIndex;
        }
      }
    }
    // According to the car position and car angle to determine the corresponding
    // Slot correct method.
    //

    // 1. Obj2 and Obj1 correct condition check:
    // 1.1 gear has been changed.
    // 1.2 car drv delta X dis > 50cm
    // 1.3 slot correction timer > 600ms.

    Dis1 = CarCenterPt.Coordinate.x;

    if ((APASlotCorrectionFlag.Bits.ObjExistCheckCarHasDrvnOutOfSlotWithCarAngAlmostAch == FALSE) && (APASlotPSlotBorderLineFitSequence > 1)) {
      if ((CarCenterPt.Coordinate.x < APA_SLOT_PER_START_CHECK_OBJ_EXIST_REGARD_CAR_OUT_OF_SLOT_X_MIN) &&
          ((CarCenterPt.CarAng - USSPar.TrajCalCarEndPos.CarAng) < APA_SLOT_PER_START_CHECK_OBJ_EXIST_REGARD_END_POS_ALMOST_ACH_DELTA_CAR_ANG)) {
        APASlotCorrectionFlag.Bits.ObjExistCheckCarHasDrvnOutOfSlotWithCarAngAlmostAch = TRUE;
      }
    }

    CarLCornerPt.x = -APACal.HalfWidthOfCar;
    CarLCornerPt.y = -APACal.LenBetweenRAxisAndRBumper;

    CarLCornerPt = APATrajCalPointPosWithAngAndCenterPt(CarLCornerPt, CarCenterPt.CarAng, CarCenterPt.Coordinate);

    CarRCornerPt.x = APACal.HalfWidthOfCar;
    CarRCornerPt.y = -APACal.LenBetweenRAxisAndRBumper;

    CarRCornerPt = APATrajCalPointPosWithAngAndCenterPt(CarRCornerPt, CarCenterPt.CarAng, CarCenterPt.Coordinate);

    bFlag = FALSE;
    if ((bAPACarIsRunningBackwards != bAPACarPrevDrvDirIsBackwards) ||
        (MATH_ABS(Dis1 - APASlotPrevCarPosXForObj1Obj2Cor) > APACal.APASlotCorPSlotCorrectDeltaXDis)) {
      bFlag = TRUE;
    }
#ifdef Mike_Yi_Debug
    cCorrectPoint = 1;
#endif
    if ((bFlag == TRUE) || (APASlotCorrectionTimer > APACal.APASlotCorPSlotCorrectCycleTime)) {
#ifdef Mike_Yi_Debug
      cCorrectPoint = 2;
#endif

      if (bFlag == FALSE) {
        // Timer Overflow.
        if (bAPAVehicleIsStatic == FALSE) {
          bFlag = TRUE;
        }
      }
      if (bFlag == TRUE) {
        APASlotCorrectionFlag.Bits.ParkProcReqSlotBorderLineCorrect = TRUE;
        APASlotPrevCarPosXForObj1Obj2Cor                            = Dis1;
      }
      // APASlotCorrectionFlag.Bits.ParkProcReqSlotBorderLineCorrect = TRUE;

      APASlotCorrectionTimer = 0;

      //
      // 1. Obj2 (X, Y) correction:
      //
      // 1.1 Obj2.x correction:
      // 1.1.1 10 Channel System: Can not be corrected.
      // 1.1.2 12 Channel System: use the rear side sensor to correct.
      // When the car is driving backwards, and the car angle is less than TBD (10 Deg),
      // and the distance between the rear side sensor Y coordinate and
      // the Obj2.y is within the tollerance (+ 1.8m / - 20 cm),
      // and the car center pt. X coordinate is within a reasonable
      // range ( - 180cm - half width of car, - 30cm - half width of car),
      // use the rear side sensor to correct the Obj2.x value.
      // Use the SDG sensor detected object infor to correct the new Obj2.x.
      // Min distance to Car and check width will be the Obj2.y + 90cm (half width of a normal car).
      // Here we will not reset the system coordinate.

      // if((PACal.cPASnsMask[PARearSys] & RS_SNS_MASK) != 0)
      {
        // 12 CH. with rear RS and LS sns.
        if ((APASlotCorrectionFlag.Bits.RightSideLineHasBeenCorrected == FALSE) &&
            (CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_Y_MIN1) &&
            (CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_Y_MIN2)) {
          bFlag = FALSE;
          if (APASlotCorrectionFlag.Bits.Obj2XHasBeenCorrectedAtTurningAroundObj2 == FALSE) {
            // Process the RS slot data
            APASlotCorrectionFlag.Bits.Obj2XHasBeenCorrectedAtTurningAroundObj2 = TRUE;
            ObjPtCnt                                                            = SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtCnt;
            ObjPt2X                                                             = NO_OBJ_DISTANCE;

            CarPosMin1.x = APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_X_MIN;
            CarPosMin1.y = APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_Y_MIN1;
            CarPosMax1.x = APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_X_MAX;
            CarPosMax1.y = APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_Y_MAX;

            for (ObjIndex = ObjPtCnt - 1; ObjIndex > 0; ObjIndex--) {
              if ((SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].ObjDis < APA_SLOT_PER_OBJ2X_CORRECT_RANGE_OBJ_DIS_MAX)) {
                if ((SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.y > CarPosMin1.y) &&
                    (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.y < CarPosMax1.y) &&
                    (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.x > CarPosMin1.x) &&
                    (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.x < CarPosMax1.x) &&
                    (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.CarAng >
                     APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_ANG_MIN1) &&
                    (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.CarAng <
                     APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_ANG_MAX1)) {
                  // Check the Obj.x
                  if (ObjPt2X > SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].Pt.x) {
                    ObjPt2X = SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].Pt.x;
                  }
                }
              }
              if ((SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.y >
                   APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_Y_MAX)) {
                break;
              }
            }

            if ((ObjPt2X < APA_SLOT_PER_OBJ2X_CORRECT_OBJ_X_MAX) && (ObjPt2X > APA_SLOT_PER_OBJ2X_CORRECT_OBJ_X_MIN)) {
              bFlag = TRUE;
            }
          } else if (APASlotCorrectionFlag.Bits.Obj2XHasbeenCorrectedWhenObj2DoesNotExist == FALSE) {
            // check the car position. car angle.
            if (CarCenterPt.Coordinate.y < (USSPar.TrajCalObj2Pos.y - APACal.HalfWidthOfCar)) {
              // Check the obj2.x
              ObjPtCnt = SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtCnt;
              ObjPt2X  = NO_OBJ_DISTANCE;

              CarPosMin1.x = APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_X_MIN;
              CarPosMin1.y = APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_Y_MIN3;
              CarPosMax1.x = APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_X_MAX2;
              CarPosMax1.y = APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_Y_MAX;

              for (ObjIndex = 0; ObjIndex < ObjPtCnt; ObjIndex++) {
                if ((SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].ObjDis < APA_SLOT_PER_OBJ2X_CORRECT_RANGE_OBJ_DIS_MAX)) {
                  if ((SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.y > CarPosMin1.y) &&
                      (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.y < CarPosMax1.y) &&
                      (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.x > CarPosMin1.x) &&
                      (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.Coordinate.x < CarPosMax1.x) &&
                      (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.CarAng >
                       APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_ANG_MIN2) &&
                      (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].CarPos.CarAng <
                       APA_SLOT_PER_OBJ2X_CORRECT_RANGE_CAR_POS_ANG_MAX2)) {
                    // Check the Obj.x
                    if ((SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].Pt.x < APA_SLOT_PER_OBJ2X_CORRECT_OBJ_X_MAX) &&
                        (SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].Pt.x > APA_SLOT_PER_OBJ2X_CORRECT_OBJ_X_MIN)) {
                      ObjPt2X = SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX].ObjPtBuf[ObjIndex].Pt.x;
                      bFlag   = TRUE;
                      break;
                    }
                  }
                }
              }
            }
          }
          if (bFlag == TRUE) {
#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
            bCarEndPosChanged = TRUE;
#endif
            USSPar.TrajCalObj2Pos.x = ObjPt2X;
            // APASlotCorrectionIndicationFlag.Bits.Obj2XChanged = TRUE;
            APASlotCorrectionFlag.Bits.Obj2XHasbeenCorrectedWhenObj2DoesNotExist = TRUE;
            USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist                 = TRUE;

            // Actually it is hard to determine the exact obj.x, do not adjust the obj.x
#if 0
						// adjust the car end pos.x
						if((bAPATrajCalCarParkAlongCurb == FALSE)
								&& (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE)) {
							Dis1 = USSPar.TrajCalObj1Pos.x;
							Dis1 -= ObjPt2X;
							if(Dis1 < 0) {
								Dis1 = -Dis1;
							}
							if(Dis1 < APACal.APATrajCalPCalCarEndPosXWithMeanValueAllowObj1Obj2MaxOffsetDis) {
								USSPar.TrajCalCarEndPos.Coordinate.x =
								(USSPar.TrajCalObj1Pos.x + USSPar.TrajCalObj2Pos.x) / 2.0 + APACal.LenBetweenRAxisAndFBumper;
								APASlotCorrectionIndicationFlag.Bits.CarEndPosXChanged = TRUE;
								USSPar.SlotCarEndPosXPrevValue = USSPar.TrajCalCarEndPos.Coordinate.x;
							}

						}
#endif
          }
        }

        // 1.2.2 Correction when the car is turning around the Obj2.
        // 1.2.1 Correction at the car first start turning point:
        // 1.2.1.1 If car will hit obj2 during the start turning around obj2.
        // Considering the car pos.x = ( < Obj2.x)
        // car pos.y = (< Obj2.y + 1000, > Obj2.y - 800).
        // Correct Add a compensate value. With high priority.
        // Use RRC or RRS sensor to cal.

        // Check if it is necessary to inhibit using the car may hit obj2 cor method?
        if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
          // Obj2 exist.
          if (CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_MAY_HIT_OBJ2_CAR_POS_Y_MIN1) {
            APASlotCorrectionFlag.Bits.InhibitUsingCarMayHitObj2CorMethod = TRUE;
          }
        } else {
          if (CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_MAY_HIT_OBJ2_CAR_POS_Y_MIN2) {
            APASlotCorrectionFlag.Bits.InhibitUsingCarMayHitObj2CorMethod = TRUE;
          }
        }

        Obj2YCorMethod = 0; // no correction.
        if ((bAPACarIsRunningBackwards == FALSE) && (bAPACarIsRunningBackwards != bAPACarPrevDrvDirIsBackwards) &&
            (APASlotCorrectionFlag.Bits.InhibitUsingCarMayHitObj2CorMethod == FALSE) &&
            (APASlotCorrectionFlag.Bits.RightSideLineHasBeenCorrected == FALSE)) {
          // Car is now drv fw.
          // If the car may hit the obj2 the driver will drive forward. at this time correct the obj2.y
          // Check if the current car pos is within the correct range.
          if ((CarCenterPt.Coordinate.y > APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_MAY_HIT_OBJ2_CAR_POS_Y_MIN1) &&
              (CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_MAY_HIT_OBJ2_CAR_POS_Y_MAX1) &&
              (CarCenterPt.Coordinate.x > APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_MAY_HIT_OBJ2_CAR_POS_X_MIN1) &&
              (CarCenterPt.Coordinate.x < APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_MAY_HIT_OBJ2_CAR_POS_X_MAX1) &&
              (CarCenterPt.CarAng > APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_MAY_HIT_OBJ2_CAR_POS_ANG_MIN1) &&
              (CarCenterPt.CarAng < APA_SLOT_PER_OBJ2Y_CORRECT_RANGE_CAR_MAY_HIT_OBJ2_CAR_POS_ANG_MAX1)) {
            // OK car pos within range.
            // Check the current RRC / RRS dt obj dis.

            if (USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
              // Actually RRSSnsDtDis : left side sns
              // RRSSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LS_EMIT_LS_RX_OBJ_INDEX];
              RRSSnsDtDis = APASideSnsDtObjDis[PARearSys][1];
              RRSnsDtDis  = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX];
              // if(RRSnsDtDis == NO_OBJ_DISTANCE) {
              //	RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_L_RX_OBJ_INDEX];
              //}
              // RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
              // if(RRMSnsDtDis == NO_OBJ_DISTANCE) {
              //	RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_LM_RX_OBJ_INDEX];
              //}
              // RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
              RLSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX];
            } else {
              // RRSSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RS_EMIT_RS_RX_OBJ_INDEX];
              RRSSnsDtDis = APASideSnsDtObjDis[PARearSys][0];
              RRSnsDtDis  = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX];
              // if(RRSnsDtDis == NO_OBJ_DISTANCE) {
              //	RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_R_RX_OBJ_INDEX];
              //}
              // RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
              // if(RRMSnsDtDis == NO_OBJ_DISTANCE) {
              //	RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_RM_RX_OBJ_INDEX];
              //}
              // RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
              RLSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX];
            }
            // RRMRLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX];
            // if(RRMRLMSnsDtDis > SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX]) {
            //	RRMRLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX];
            //}

            if ((RLSnsDtDis < 800)
						/*|| (RLMSnsDtDis != NO_OBJ_DISTANCE)
						 || (RRMSnsDtDis != NO_OBJ_DISTANCE)
						 || (RRMRLMSnsDtDis != NO_OBJ_DISTANCE)*/) {
              // Don't correct obj2.
              RRSnsDtDis  = NO_OBJ_DISTANCE;
              RRSSnsDtDis = NO_OBJ_DISTANCE;
            }

            /*if(RRSnsDtDis != NO_OBJ_DISTANCE){
             RRSnsDtDis *= 10; // cm -> mm.
             }*/

            if (RRSnsDtDis < APACal.APASlotCorPCarMayHitObj2CorRRCSnsStartCalDis) {
              // Just use RRC to correct
              Obj2YCorMethod = 1; // Both obj2 X and Y should be correct. with RRC.

              // cal the compensate car angle.

              CarAngTemp = 2.0 * PI - APACal.SnsAng[APA_RR_SNS_INDEX] - CarCenterPt.CarAng;
              if (CarAngTemp > APACal.APASlotCorPCarMayHitObj2CorRRCSnsMaxCompensateAng) {
                CarAngTemp = APACal.APASlotCorPCarMayHitObj2CorRRCSnsMaxCompensateAng;
              }
              ObjPt = APASlotProcCalObjPtCoordinateBySnsDtdDis(RRSnsDtDis, CarAngTemp, APA_RR_SNS_INDEX);
              ObjPt = APATrajCalPointPosWithAngAndCenterPt(ObjPt, CarCenterPt.CarAng, CarCenterPt.Coordinate);
              ObjPt.y -= APACal.APASlotCorPCarMayHitObj2CorRRCSnsCalObj2YCompensateDis;

            } else {
              if (RRSSnsDtDis < APACal.APASlotCorPCarMayHitObj2CorRRSSnsStartCalDis) {
                // Just use RRS to correct
                Obj2YCorMethod = 2; // Both obj2 X and Y should be correct. with RRS. Compensate 600mm.
                SlotPt         = APASlotProcCalSlotRelativeToCarCoordinateBySnsDtdDis(RRSSnsDtDis, APA_RRS_SNS_INDEX);
                ObjPt          = APATrajCalPointPosWithAngAndCenterPt(SlotPt.Coordinate, CarCenterPt.CarAng, CarCenterPt.Coordinate);

                // fDis1 = MATH_FABS(CarCenterPt.CarAng - USSPar.TrajCalCarEndPos.CarAng);
                // fDis1 = fDis1 / (40.0 * PI / 180.0) * 800.0;
                // ObjPt2Y = ObjPt.y;// + fDis1;
                ObjPt.y -= APACal.APASlotCorPCarMayHitObj2CorRRSSnsCalObj2YCompensateDis;
              } else {
                // Do not correct.
              }
            }

            if (Obj2YCorMethod > 0) {
              // Obj2Y is corrected.
              SlotLen = ObjPt.y - USSPar.TrajCalObj1Pos.y;
              Dis1    = APACal.APASlotPMinSmallSlotLen - SlotLen;
              if (Dis1 > APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS) {
                // ?? Data error
                // ?? Actually code should never reach.
                // If yes. it may be the Obj2.y compensate to much.
                // Just ignore the current correction and return.
                Obj2YCorMethod = 0;
              } else if (Dis1 > 0) {
                if ((APASlotCorrectionOriginalObj2Y - ObjPt.y) > 250) {
                  // Over 25cm tol
                  // regarded as invalid.
                  Dis1 /= 3;
                  ObjPt.y = APACal.APASlotPMinSmallSlotLen + SlotObj1Y - Dis1;
                  if (ObjPt.y < APASlotCorrectionOriginalObj2Y) {
                    // OK. use the new objpt2y
                    SlotLen = APACal.APASlotPMinSmallSlotLen;
                    USSPar.TrajCalObj1Pos.y -= Dis1;
                  } else {
                    Obj2YCorMethod = 0;
                  }

                } else {
                  SlotLen = APACal.APASlotPMinSmallSlotLen;
                  // The Obj1.y and Obj2.y will be compensated with Dis1 / 2.
                  Dis1 /= 2;
                  ObjPt.y += Dis1;
                  USSPar.TrajCalObj1Pos.y -= Dis1;
                }
                //} else if(SlotLen > APACal.APASlotPMaxSlotLength) {
                // ?? Data error or the car has just run over the Obj1 and Obj1 has moved away.
                // Just treat as the bigest slot length.
                //	SlotLen = APACal.APASlotPMaxSlotLength;
                // ObjPt1Y = SlotObj2Y - SlotLen;
              } else {
                // The slot length is still within the min small slot len range.
                // OK.
              }
              // adjust the car end pos.y
              if (Obj2YCorMethod > 0) {
                // Recorrect the slot length.
                // Check if the Obj2.Y is reasonable.

                bFlag = APASlotProcCheckIfObjPt12IsValid(CarCenterPt, &ObjPt, 1);

                if (ObjPt.y > APASlotCorrectionOriginalObj2Y) {
                  // Data error ??
                  ObjPt.y = APASlotCorrectionOriginalObj2Y - 400;
                }

                USSPar.TrajCalObj2Pos                             = ObjPt; // Both Obj2.x and y has been corrected.
                USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist = TRUE;

                // APASlotCorrectionIndicationFlag.Bits.Obj2XChanged = TRUE;
                APASlotCorrectionFlag.Bits.Obj2XHasbeenCorrectedWhenObj2DoesNotExist = TRUE;
                APASlotCorrectionFlag.Bits.Obj2XHasBeenCorrectedAtTurningAroundObj2  = TRUE;
                APASlotCorrectionFlag.Bits.Obj2YHasBeenCorrectedDueToRRCMayHitObj2   = TRUE;

                // Actually it is hard to determine the exact obj.x, do not adjust the obj.x
#if 0

								// adjust the car end pos.x
								if((bAPATrajCalCarParkAlongCurb == FALSE)
										&& (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE)) {
									Dis1 = USSPar.TrajCalObj1Pos.x;
									Dis1 -= ObjPt.x;
									if(Dis1 < 0) {
										Dis1 = -Dis1;
									}
									if(Dis1 < APACal.APATrajCalPCalCarEndPosXWithMeanValueAllowObj1Obj2MaxOffsetDis) {

										USSPar.TrajCalCarEndPos.Coordinate.x =
										(USSPar.TrajCalObj1Pos.x + USSPar.TrajCalObj2Pos.x) / 2.0 + APACal.LenBetweenRAxisAndFBumper;
										APASlotCorrectionIndicationFlag.Bits.CarEndPosXChanged = TRUE;

										USSPar.SlotCarEndPosXPrevValue = USSPar.TrajCalCarEndPos.Coordinate.x;
									}

								}
#endif

                APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(SlotLen, 1);
#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
                bCarEndPosChanged = TRUE;
#endif

              } else {
                // It is an error.
                // Can not be corrected.
                // just remain the previous value.
              }
            }
          }
        }

        // Obj exist or not check sequence updating:
        if (APASlotPObjExistCheckSequence == 0) {
          if ((CarCenterPt.Coordinate.x > 0) && (CarCenterPt.Coordinate.y < 0)) {
            APASlotPObjExistCheckSequence = 1;
          }
        } else if (APASlotPObjExistCheckSequence == 1) {
          if (((EndPosToCurCarPosDeltaX < 1000) || (CarCenterPt.Coordinate.x > 2500)) && (CarCenterPt.Coordinate.y < 1000)) {
            APASlotPObjExistCheckSequence = 2;
          }
        }

        if ((CarCenterPt.Coordinate.y < 0) && (CarCenterPt.Coordinate.y < USSPar.TrajCalObj2Pos.y + (APACal.LenBetweenRAxisAndRBumper / 2))) {
          APASlotCorrectionFlag.Bits.Obj2UseSDGBufToCorIsEnalbed = TRUE;
        }

        /*bFlag = FALSE;

         if((APASlotPObjExistCheckSequence > 0)
         && (bAPACarIsRunningBackwards == TRUE)){
         if ((CarCenterPt.Coordinate.x > (1500))
         || (CarCenterPt.Coordinate.x > (USSPar.TrajCalObj2Pos.x + APACal.APASlotCorPObj2YCorStartUseSDGBufCorCarPosDeltaXDis))){
         // Ok
         } else {
         // inhibit the check of Obj2.y
         bFlag = TRUE;
         }
         }*/

        if (/*(bFlag == FALSE)
         &&*/
            (APASlotCorrectionFlag.Bits.Obj2YHasBeenCorrectedDueToRRCMayHitObj2 == FALSE) &&
            (APASlotCorrectionFlag.Bits.Obj2UseSDGBufToCorIsEnalbed == TRUE) &&
            ((APASlotCorrectionFlag.Bits.RightSideLineHasBeenCorrected == FALSE) ||
             ((USSPar.TrajCalObj2Pos.y - 1800) < USSPar.TrajCalObj1Pos.y))) {
          // Check if it is necessary to use SDG method to correct. Slot Right side line is not fitted
          // Check the RRS Sns first.
          // 1.2.2.1 10 CH: Can not be corrected.
          // 1.2.2.2 12 CH: use the rear side sensor to correct the Obj2.y
          // when the Obj2 is within the rear side sensor FOV.
          // Car angle is about from 10deg to 60deg.
          // Process the RS slot data
          bFlag = APASlotProcCorrectSlotPReCalObj2YWithSDGBuf(CarCenterPt, SDG_RRS_SNS_INDEX);
          if (bFlag == FALSE) {
            // Then check RRC Sns
            bFlag = APASlotProcCorrectSlotPReCalObj2YWithSDGBuf(CarCenterPt, SDG_FRS_SNS_INDEX);
            if ((APACal.APACalCommonFlags.Bits.bAPASlotCorPCheckObjExistOrNot == TRUE) && (bFlag == FALSE) && (APASlotPObjExistCheckSequence >= 2)) {
              // Check if the Obj2 exist?
              ObjIndex = APASlotProcCorrectSlotPCheckIfTheObj1Obj2Exist(CarCenterPt.Coordinate.x, SDG_RRS_SNS_INDEX);
              if (ObjIndex == 0) {
                // OK, obj2 does not exist.
                ObjIndex = APASlotProcCorrectSlotPCheckIfTheObj1Obj2Exist(CarCenterPt.Coordinate.x, SDG_FRS_SNS_INDEX);
                if (ObjIndex == 0) {
                  // OK, Obj2 really does not exist.

                  USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist = FALSE;
                  USSPar.TrajCalObj2Pos.x                           = USSPar.TrajCalCarEndPos.Coordinate.x + APACal.LenBetweenRAxisAndRBumper;
                  // APASlotCorrectionIndicationFlag.Bits.Obj2XChanged = TRUE;

                  if (APASlotCorrectionFlag.Bits.SlotBorderLineHasBeenCorrected == FALSE) {

                    // Actually it is hard to determine the exact obj.x, do not adjust the obj.x
#if 0

										// adjust the car end pos.x
										if((bAPATrajCalCarParkAlongCurb == FALSE)
												&& (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE)) {

											USSPar.TrajCalCarEndPos.Coordinate.x =
											USSPar.TrajCalObj1Pos.x + APACal.LenBetweenRAxisAndFBumper;
											APASlotCorrectionIndicationFlag.Bits.CarEndPosXChanged = TRUE;
											USSPar.SlotCarEndPosXPrevValue = USSPar.TrajCalCarEndPos.Coordinate.x;

										}
#endif

                    APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength, 1);
#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
                    bCarEndPosChanged = TRUE;
#endif
                  } else {
                    // Reqeust to recorrect end pos line and end pos

                    APASlotCorrectionFlag.Bits.ParkProcReqSlotBorderLineCorrect = TRUE;

                  }
                }
              }
            }
          }
        } else {
          if ((bAPACarIsRunningBackwards == TRUE) &&
              (CarCenterPt.Coordinate.x > (USSPar.TrajCalObj2Pos.x - APACal.APASlotCorPObj2YCorStartUseSDGBufCorCarPosDeltaObj2XDis))) {

            APASlotCorrectionFlag.Bits.Obj2YHasBeenCorrectedDueToRRCMayHitObj2 = FALSE;

          }
        }

        // Check if it is necessary to inhibit using the car may hit obj1 cor method?
        if ((CarCenterPt.Coordinate.x > APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_X_MAX2) &&
            (CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MAX1)) {
          APASlotCorrectionFlag.Bits.InhibitUsingCarMayHitObj1CorMethod = TRUE;
        }

        // 2. Obj1 (X, Y) correction:
        // 2.1 Correction at the car first turning point:
        //    Car angle is great than 30deg and less 70deg.
        //    Car Pos.x > TBD (-2m) and < TBD (Obj1.x - LenBetweenRearAxisAndRearBumper)
        //    Car Pos.y > TBD (Obj1.y +  LenBetweenRearAxisAndRearBumper) and Car Pos.y < TBD (0m).
        //    Obj1 is within the UPA FOV < TBD (150cm) and Triangle Calculation exisit (first priority) or ccording to which sensor has detected an
        //    object (Dis < TBD (60cm)) and the Obj1 has never been corrected.

        if ((bAPACarIsRunningBackwards == FALSE) && (bAPACarIsRunningBackwards != bAPACarPrevDrvDirIsBackwards) &&
            (APASlotCorrectionFlag.Bits.InhibitUsingCarMayHitObj1CorMethod == FALSE) &&
            (APASlotCorrectionFlag.Bits.LeftSideLineHasBeenCorrected == FALSE)) {
          if ((CarCenterPt.Coordinate.y > APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MIN1) &&
              (CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_Y_MAX1) &&
              (CarCenterPt.Coordinate.x > APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_X_MIN1) &&
              (CarCenterPt.Coordinate.x < APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_X_MAX2)) {
#ifdef Mike_Yi_Debug
            cCorrectPoint = 3;
#endif
            // Within the correction range of the first turning.

            // RearSnsDtMinDis = USSPar.ParkProcRearSnsDtdNearestDis;
            if (USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
              // RRSSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RS_EMIT_RS_RX_OBJ_INDEX];
              RRSSnsDtDis = APASideSnsDtObjDis[PARearSys][0];
              RRSnsDtDis  = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_R_RX_OBJ_INDEX];
              }
              RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_RM_RX_OBJ_INDEX];
              }
              RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
            } else {
              // Actually RRSSnsDtDis : left side sns
              // RRSSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LS_EMIT_LS_RX_OBJ_INDEX];
              RRSSnsDtDis = APASideSnsDtObjDis[PARearSys][1];
              RRSnsDtDis  = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX];
              if (RRSnsDtDis == NO_OBJ_DISTANCE) {
                RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_L_RX_OBJ_INDEX];
              }
              RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_LM_RX_OBJ_INDEX];
              if (RRMSnsDtDis == NO_OBJ_DISTANCE) {
                RRMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_LM_RX_OBJ_INDEX];
              }
              RLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_RM_RX_OBJ_INDEX];
            }
            RRMRLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RM_EMIT_LM_RX_OBJ_INDEX];
            if (RRMRLMSnsDtDis > SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX]) {
              RRMRLMSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LM_EMIT_RM_RX_OBJ_INDEX];
            }

            // if(RRSSnsDtDis != NO_OBJ_DISTANCE){
            //	RRSSnsDtDis *= 10; // cm -> mm.
            //}
            /*if(RRSnsDtDis != NO_OBJ_DISTANCE){
             RRSnsDtDis *= 10; // cm -> mm.
             }
             if(RRMSnsDtDis != NO_OBJ_DISTANCE){
             RRMSnsDtDis *= 10; // cm -> mm.
             }
             if(RLMSnsDtDis != NO_OBJ_DISTANCE){
             RLMSnsDtDis *= 10; // cm -> mm.
             }
             if(RRMRLMSnsDtDis != NO_OBJ_DISTANCE){
             RRMRLMSnsDtDis *= 10; // cm -> mm.
             }*/

            // Use the rear sensor detect object distance to correct.
            // The nearest dis has high priority.
            RearSnsDtMinDis = RRSSnsDtDis;
            ObjIndex        = APA_RLS_SNS_INDEX;
            if ((RRSnsDtDis != NO_OBJ_DISTANCE) &&
                ((EndPosToCurCarPosDeltaAng > (15.0 * PI / 180.0)) ||
                 (CarLCornerPt.x < (USSPar.TrajCalObj1Pos.x + APACal.LenBetweenRAxisAndRBumper))) &&
                (RearSnsDtMinDis >= (RRSnsDtDis - APACal.APASlotCorPCarMayHitObj1CorUseRLSnsAsHighPriorityDeltaDis))) {
              RearSnsDtMinDis = RRSnsDtDis;
              ObjIndex        = APA_RL_SNS_INDEX;
            }

            if (CarCenterPt.CarAng < APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_ANG_MIN1) {

            } else if (CarCenterPt.CarAng < APA_SLOT_PER_OBJ1Y_CORRECT_RANGE_CAR_POS_ANG_MAX1) {
              if (((CarLCornerPt.x < (USSPar.TrajCalObj1Pos.x + (APACal.LenBetweenRAxisAndRBumper / 2)))) &&
                  ((RRMSnsDtDis != NO_OBJ_DISTANCE) &&
                   (RearSnsDtMinDis > (RRMSnsDtDis - APACal.APASlotCorPCarMayHitObj1CorUseMidSnsAsHighPriorityDeltaDis)))) {
                RearSnsDtMinDis = RRMSnsDtDis;
                ObjIndex        = APA_RLM_SNS_INDEX;
              }
              if (RearSnsDtMinDis > APACal.APASlotCorPCarMayHitObj1CorSnsStartCalDis) {
                if (RearSnsDtMinDis > RLMSnsDtDis) {
                  RearSnsDtMinDis = RLMSnsDtDis;
                  ObjIndex        = APA_RRM_SNS_INDEX;
                }
                if (RearSnsDtMinDis > RRMRLMSnsDtDis) {
                  RearSnsDtMinDis = RRMRLMSnsDtDis;
                  ObjIndex        = APA_SUPPORT_APA_SNS_NUM;
                }
              }
              if (RearSnsDtMinDis < APACal.APASlotCorPCarMayHitObj1CorSnsStartCalDis) {
                // Sensor detected the nearest object distance is within the correction range.

                if (ObjIndex == APA_SUPPORT_APA_SNS_NUM) {
                  SlotPt.Coordinate.x = 0;
                  SlotPt.Coordinate.y = -APACal.LenBetweenRAxisAndRBumper - RearSnsDtMinDis;
                } else {
                  SlotPt = APASlotProcCalSlotRelativeToCarCoordinateBySnsDtdDis(RearSnsDtMinDis, ObjIndex);
                }
                SlotPt.Coordinate = APATrajCalPointPosWithAngAndCenterPt(SlotPt.Coordinate, CarCenterPt.CarAng, CarCenterPt.Coordinate);
                if (ObjIndex == APA_RLS_SNS_INDEX) {
                  if (CarLCornerPt.x < (USSPar.TrajCalObj1Pos.x + (APACal.LenBetweenRAxisAndRBumper / 2))) {
                    SlotPt.Coordinate.y += (APACal.APASlotCorPCarMayHitObj1CorRLSSnsCalObj1YCompensateDis2);
                  } else {
                    SlotPt.Coordinate.y += APACal.APASlotCorPCarMayHitObj1CorRLSSnsCalObj1YCompensateDis1;
                  }
                } else if (ObjIndex == APA_RL_SNS_INDEX) {
                  if (USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength < (APACal.WidthOfCar + 1200)) {
                    // Small slot
                    SlotPt.Coordinate.y += APACal.APASlotCorPCarMayHitObj1CorRLCSnsCalObj1YCompensateDis2;
                  } else {
                    // Big slot.
                    if (CarLCornerPt.x < (USSPar.TrajCalObj1Pos.x + (APACal.LenBetweenRAxisAndRBumper / 2))) {
                      SlotPt.Coordinate.y += (APACal.APASlotCorPCarMayHitObj1CorRLCSnsCalObj1YCompensateDis1);
                    } else {
                      // Big slot inside the slot, do not compensate??.
                      SlotPt.Coordinate.y += APACal.APASlotCorPCarMayHitObj1CorRLCSnsCalObj1YCompensateDis0;
                    }
                  }
                } else {
                  // Mid sensor.
                  SlotPt.Coordinate.y += APACal.APASlotCorPCarMayHitObj1CorMidSnsCalObj1YCompensateDis;
                }

                ObjPt1Y   = SlotPt.Coordinate.y;
                SlotLen   = SlotObj2Y - ObjPt1Y;
                Dis1      = APACal.APASlotPMinSmallSlotLen - SlotLen;
                CalResult = 0;
                if (Dis1 > APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS) {
                  // ?? Data error
                  // ?? Actually code should never reach.
                  // If yes. it may be the Obj2.y compensate to much.
                  // Just ignore the current correction and return.
                  CalResult = 1;
                } else if (Dis1 > 0) {
                  if ((ObjPt1Y - APASlotCorrectionOriginalObj1Y) > 250) {
                    // Over 25cm tol
                    // regarded as invalid.

                    Dis1 /= 3;
                    ObjPt1Y = SlotObj2Y - APACal.APASlotPMinSmallSlotLen + Dis1;
                    if (ObjPt1Y > APASlotCorrectionOriginalObj1Y) {
                      // OK. use the new objpt1y
                      SlotLen = APACal.APASlotPMinSmallSlotLen;
                      USSPar.TrajCalObj2Pos.y += Dis1;

                    } else {
                      CalResult = 1;
                    }
                  } else {
                    SlotLen = APACal.APASlotPMinSmallSlotLen;
                    // The Obj1.y and Obj2.y will be compensated with Dis1 / 2.
                    Dis1 /= 2;
                    ObjPt1Y -= Dis1;
                    USSPar.TrajCalObj2Pos.y += Dis1;
                  }
                  //} else if(SlotLen > APACal.APASlotPMaxSlotLength) {
                  // ?? Data error or the car has just run over the Obj1 and Obj1 has moved away.
                  // Just treat as the bigest slot length.
                  //	SlotLen = APACal.APASlotPMaxSlotLength;
                  //	ObjPt1Y = SlotObj2Y - SlotLen;
                } else {
                  // The slot length is still within the min small slot len range.
                  // OK.
                }
                // adjust the car end pos.y
                if (CalResult == 0) {
                  // Recorrect the slot length.
                  ObjPt   = USSPar.TrajCalObj1Pos;
                  ObjPt.y = ObjPt1Y;
                  bFlag   = APASlotProcCheckIfObjPt12IsValid(CarCenterPt, &ObjPt, 0);

                  if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == FALSE) {
                    USSPar.TrajCalObj1Pos = ObjPt;
                  } else {
                    USSPar.TrajCalObj1Pos.y = ObjPt.y;
                  }
                  APASlotCorrectionFlag.Bits.Obj1YHasBeenCorrectedDueToRLCMayHitObj1 = TRUE;
                  USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist               = TRUE;

                  APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(SlotLen, 0);
#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
                  bCarEndPosChanged = TRUE;
#endif
                } else {
                  // It is an error.
                  // Can not be corrected.
                  // just remain the previous value.
                }
              }
            }
          }
        }

        if (((APACal.APACalCommonFlags2.Bits.bAPASlotCorPCorObj1YCheckHasBeenCorrectedDueToRLCMayHitObj1 == FALSE) ||
             (APASlotCorrectionFlag.Bits.Obj1YHasBeenCorrectedDueToRLCMayHitObj1 == FALSE)) &&
            ((APASlotCorrectionFlag.Bits.LeftSideLineHasBeenCorrected == FALSE) ||
             ((USSPar.TrajCalObj2Pos.y - 1800) < USSPar.TrajCalObj1Pos.y))) {
          // Check if it is necessary to use SDG method to correct.
          // Check the RRS Sns first.
          // 1.2.2.1 10 CH: Can not be corrected.
          // 1.2.2.2 12 CH: use the rear side sensor to correct the Obj2.y
          // when the Obj2 is within the rear side sensor FOV.
          // Car angle is about from 10deg to 60deg.
          // Process the RS slot data
#ifdef Mike_Yi_Debug
          cCorrectPoint = 4;
#endif
          bFlag = APASlotProcCorrectSlotPReCalObj1YWithSDGBuf(CarCenterPt, SDG_RLS_SNS_INDEX);
          if (bFlag == FALSE) {
            // Then check RRC Sns
            bFlag = APASlotProcCorrectSlotPReCalObj1YWithSDGBuf(CarCenterPt, SDG_FLS_SNS_INDEX);
#ifdef Mike_Yi_Debug
            if (TRUE == bFlag) {
              cCorrectPoint = 7;
            }
#endif
            if ((APACal.APACalCommonFlags.Bits.bAPASlotCorPCheckObjExistOrNot == TRUE) && (bFlag == FALSE) && (APASlotPObjExistCheckSequence >= 2)) {
              // Check if the Obj2 exist?
              ObjIndex = APASlotProcCorrectSlotPCheckIfTheObj1Obj2Exist(CarCenterPt.Coordinate.x, SDG_RLS_SNS_INDEX);
              if (ObjIndex == 0) {
                // OK, obj2 does not exist.
                ObjIndex = APASlotProcCorrectSlotPCheckIfTheObj1Obj2Exist(CarCenterPt.Coordinate.x, SDG_FLS_SNS_INDEX);
                if (ObjIndex == 0) {
                  // OK, Obj2 really does not exist.

                  USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist = FALSE;
                  USSPar.TrajCalObj1Pos.x                           = USSPar.TrajCalCarEndPos.Coordinate.x + APACal.LenBetweenRAxisAndRBumper;
                  // APASlotCorrectionIndicationFlag.Bits.Obj1XChanged = TRUE;

                  if (APASlotCorrectionFlag.Bits.SlotBorderLineHasBeenCorrected == FALSE) {

                    // Actually it is hard to determine the exact obj.x, do not adjust the obj.x
#if 0
										// adjust the car end pos.x
										if((bAPATrajCalCarParkAlongCurb == FALSE)
												&& (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE)) {
											USSPar.TrajCalCarEndPos.Coordinate.x =
											USSPar.TrajCalObj2Pos.x + APACal.LenBetweenRAxisAndFBumper;
											APASlotCorrectionIndicationFlag.Bits.CarEndPosXChanged = TRUE;
											USSPar.SlotCarEndPosXPrevValue = USSPar.TrajCalCarEndPos.Coordinate.x;

										}
#endif
#ifdef Mike_Yi_Debug
                    cCorrectPoint = 6;
#endif

                    APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength, 0);
#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
                    bCarEndPosChanged = TRUE;
#endif
                  } else {
                    // Reqeust to recorrect end pos line and end pos
                    APASlotCorrectionFlag.Bits.ParkProcReqSlotBorderLineCorrect = TRUE;
                  }
                }
              }
            }
          }
        } else {
          if ((bAPACarIsRunningBackwards == TRUE) &&
              (CarCenterPt.Coordinate.x > (USSPar.TrajCalObj1Pos.x - APACal.LenBetweenRAxisAndFBumper / 2))) {
            APASlotCorrectionFlag.Bits.Obj1YHasBeenCorrectedDueToRLCMayHitObj1 = FALSE;
          }
        }
      }

    } else {
      APASlotCorrectionTimer++;
    }

    // slot border line correction

#if 1
    // Process rear side and corner sns dis with SDG algorithm.
    // It is mainly used for the in slot, slot border line angle calculation.
    //
    if ((CarCenterPt.CarAng > APA_SLOT_PER_OBJ1Y_OBJ2Y_CORRECT_RANGE_CAR_POS_ANG_MIN2) &&
        (CarCenterPt.CarAng < APA_SLOT_PER_OBJ1Y_OBJ2Y_CORRECT_RANGE_CAR_POS_ANG_MAX2) &&
        (CarCenterPt.Coordinate.y > APA_SLOT_PER_OBJ1Y_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MIN2) &&
        (CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ1Y_OBJ2Y_CORRECT_RANGE_CAR_POS_Y_MAX2) &&
        (CarCenterPt.Coordinate.x > APA_SLOT_PER_OBJ1Y_OBJ2Y_CORRECT_RANGE_CAR_POS_X_MIN2) &&
        (CarCenterPt.Coordinate.x < APA_SLOT_PER_OBJ1Y_OBJ2Y_CORRECT_RANGE_CAR_POS_X_MAX2) &&
        (APASlotPSlotBorderLineFitSequence < APACal.APASlotCorPSlotBorderLineFitMaxStepSequenceNum)) {

      // Seqnum < 3

      /*if(APASlotPObj2NotExistObj1BorderLineFitSequence == 0){
       if(CarCenterPt.Coordinate.x > APA_SLOT_PER_IN_SLOT_OBJ2_NOT_EXIST_OBJ1_BORDERLINE_FIT_MAX_X1){
       APASlotPObj2NotExistObj1BorderLineFitSequence = 1;
       }
       } else if(APASlotPObj2NotExistObj1BorderLineFitSequence == 1)*/
      {
        if (CarCenterPt.Coordinate.x < APA_SLOT_PER_IN_SLOT_OBJ2_NOT_EXIST_OBJ1_BORDERLINE_FIT_MIN_X1) {
          APASlotPObj2NotExistObj1BorderLineFitSequence = 2;
        }
      }

      if ((APASlotPSlotBorderLineFitSequence & 0x01) == 0) {
        if (EndPosToCurCarPosDeltaX < APACal.APASlotCorPSlotBorderLineFitRegardAsOneStepIntoSlotMaxDeltaCarPosX) {
          APASlotPSlotBorderLineFitSequence++;
        }
      }

      if (APASlotPSlotBorderLineFitConvexShapeCheckSequence == 0) {
        if (EndPosToCurCarPosDeltaX < APACal.APASlotCorPSlotBorderLineFitConvexShapeCheckFirstStepIntoSlotMaxDeltaCarPosX) {
          APASlotPSlotBorderLineFitConvexShapeCheckSequence = 1;
        }
      }
      if (APASlotPSlotBorderLineFitConvexShapeCheckSequence == 1) {
        if (CarCenterPt.Coordinate.x < APACal.APASlotCorPSlotBorderLineFitConvexShapeCheckFirstStepOutSlotMinCarPosX) {
          APASlotPSlotBorderLineFitConvexShapeCheckSequence = 2;
        }
      }
      if (APASlotPSlotBorderLineFitConvexShapeCheckSequence == 2) {
        if (EndPosToCurCarPosDeltaX < APACal.APASlotCorPSlotBorderLineFitConvexShapeCheckSecondStepIntoSlotMaxDeltaCarPosX) {
          APASlotPSlotBorderLineFitConvexShapeCheckSequence = 3;
        }
      }

      bRRCSnsDisUpdated = bRRCUPASnsDtdObjDisUpdated;
      bRLCSnsDisUpdated = bRLCUPASnsDtdObjDisUpdated;
      RRSnsDtDis        = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
      Dis1              = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX - 1];
      RLSnsDtDis        = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX];
      Dis2              = DtObjUPASnsDtObjDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX][UPA_SNS_DT_OBJ_LAST_VALUE_INDEX - 1];

      if (MATH_ABS(Dis1 - RRSnsDtDis) > APACal.APASlotCorPSlotBorderLineFitRegardedRCSnsDtDisAsInvalidMaxDeltaObjDis) {
        // Regarded rear corner sns dis as invalid.
        RRSnsDtDis = NO_OBJ_DISTANCE;
      }
      if (MATH_ABS(Dis2 - RLSnsDtDis) > APACal.APASlotCorPSlotBorderLineFitRegardedRCSnsDtDisAsInvalidMaxDeltaObjDis) {
        // Regarded rear corner sns dis as invalid.
        RLSnsDtDis = NO_OBJ_DISTANCE;
      }
      if ((bRRCSnsDisUpdated == TRUE) || (bRLCSnsDisUpdated == TRUE)) {
        // bRRCUPASnsDtdObjDisUpdated and bRLCUPASnsDtdObjDisUpdated flags will be cleared
        // just outside of this function.

        /*if(RRSnsDtDis != NO_OBJ_DISTANCE){
         RRSnsDtDis *= 10; // cm -> mm.
         }
         if(RLSnsDtDis != NO_OBJ_DISTANCE){
         RLSnsDtDis *= 10; // cm -> mm.
         }*/

        if (USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
          Dis1              = RRSnsDtDis;
          RRSnsDtDis        = RLSnsDtDis;
          RLSnsDtDis        = Dis1;
          bFlag             = bRRCSnsDisUpdated;
          bRRCSnsDisUpdated = bRLCSnsDisUpdated;
          bRLCSnsDisUpdated = bFlag;
        } else {
          // OK,
        }

        // Added by lu zhimeng 2014 04 14
        for (DeltaAngIndex = 0; DeltaAngIndex < APACal.APASlotPCorRROrRLDeltaAngBetweenCurAngAndEndAng.APASlotPCorDeltaAngZoneNum; DeltaAngIndex++) {
          if (EndPosToCurCarPosDeltaAng < APACal.APASlotPCorRROrRLDeltaAngBetweenCurAngAndEndAng.APASlotPCorDeltaAngArray[DeltaAngIndex]) {
            break;
          }
        }
        if ((bRRCSnsDisUpdated == TRUE) && (RRSnsDtDis < APACal.APASlotCorPObjExistMaxSnsDtDis)) {
          // Process RRC Sns.
          if (SlotObj2X > APACal.APASlotMaxOffsetDisBetweenObj1AndObj2ForPerpendicular) {
            SlotObj2X = 0;
          }
          SlotPt.Coordinate.x = APACal.SnsPos[APA_RR_SNS_INDEX].x;
          SlotPt.Coordinate.y = APACal.SnsPos[APA_RR_SNS_INDEX].y;
          RRCSnsPt.Coordinate = APATrajCalPointPosWithAngAndCenterPt(SlotPt.Coordinate, CarCenterPt.CarAng, CarCenterPt.Coordinate);
          if ((EndPosToCurCarPosDeltaX < APACal.APASlotPRegardRCornerSnsAsNoObjDtDeltaDisToEndPosX) ||
              (RRSnsDtDis > APACal.APASlotPRCornerSnsDtMaxObjDisInsideSlot[SDG_FRS_SNS_INDEX]) ||
              (CarCenterPt.Coordinate.x < (SlotObj2X + APACal.APASlotPSDGBufRRCornerSnsDtMinCarPosX)) ||
              (CarCenterPt.CarAng < APACal.APASlotPCorMaxCarAngToAcceptRRSnsDis[SDG_FRS_SNS_INDEX])) { // 80cm ??
            RRSnsDtDis = NO_OBJ_DISTANCE;
          } else {
            // lu zhimeng 2014 04 14
            bCompDisMethodFlag               = FALSE;
            CorSnsXDisBiggerThanThresholdCnt = 0;
            if (RRCSnsPt.Coordinate.x < (SlotObj2X + APACal.APASlotPCorMinDelPosXToCorObjByAngAndDis[0])) {
              if (RRSnsDtDis > APACal.APASlotPCorMaxDisOfCorOrSideSnsDtIfCarInOutSideSlot[SDG_FRS_SNS_INDEX]) {
                RRSnsDtDis = NO_OBJ_DISTANCE;
              } else {
                for (SDGBufDisIndex = 0; SDGBufDisIndex < SDGObjInfo.SnsObjPtBuf[SDG_FRS_SNS_INDEX].ObjPtCnt; SDGBufDisIndex++) {
                  if (SDGObjInfo.SnsObjPtBuf[SDG_FRS_SNS_INDEX].ObjPtBuf[SDGBufDisIndex].ObjDis != NO_OBJ_DISTANCE) {
                    if ((SDGObjInfo.SnsObjPtBuf[SDG_FRS_SNS_INDEX].ObjPtBuf[SDGBufDisIndex].Pt.x - SlotObj2X) >=
                        APACal.APASlotPCorMinDetXOfCorOrSideSnsDtOnCarBodyIfIngoreDisDtOnCarHead[SDG_FRS_SNS_INDEX]) {
                      CorSnsXDisBiggerThanThresholdCnt++;
                    }
                    if (CorSnsXDisBiggerThanThresholdCnt >=
                        APACal.APASlotPCorMinCntOfCorOrSideSnsDtOnCarBodyIfIngoreDisDtOnCarHead[SDG_FRS_SNS_INDEX]) {
                      RRSnsDtDis = NO_OBJ_DISTANCE;
                      break;
                    }
                  }
                }
              }
              if (RRSnsDtDis != NO_OBJ_DISTANCE) {
                bCompDisMethodFlag = TRUE;
              }
            }
          }
          if (RRSnsDtDis != NO_OBJ_DISTANCE) {
            for (RRCDisIndex = 0; RRCDisIndex < (APA_SLOT_P_COR_SNS_DIS_DIV_NUM - 1); RRCDisIndex++) {
              if (RRSnsDtDis < APACal.APASlotPCorCorOrSideSnsDisArray[0][RRCDisIndex]) {
                break;
              }
            }
            APASlotCorPCarMayHitObj2CorRRCSnsMaxCompensateAng =
                APASlotPCorCorSnsDisCompensatCalculation(DeltaAngIndex, RRCDisIndex, 0, EndPosToCurCarPosDeltaAng, RRSnsDtDis, 0, bCompDisMethodFlag);
          } else {
            APASlotCorPCarMayHitObj2CorRRCSnsMaxCompensateAng = 0;
          }
          ObjPt          = APASlotProcCalObjPtCoordinateBySnsDtdDis(RRSnsDtDis, APASlotCorPCarMayHitObj2CorRRCSnsMaxCompensateAng, APA_RR_SNS_INDEX);
          ObjPt          = APATrajCalPointPosWithAngAndCenterPt(ObjPt, CarCenterPt.CarAng, CarCenterPt.Coordinate);
          SDGRObjPt.Pt.x = ObjPt.x;
          SDGRObjPt.Pt.y = ObjPt.y;
          SDGRObjPt.ObjDis              = RRSnsDtDis;
          SDGRObjPt.CarPos.Coordinate.x = CarCenterPt.Coordinate.x;
          SDGRObjPt.CarPos.Coordinate.y = CarCenterPt.Coordinate.y;
          SDGRObjPt.CarPos.CarAng       = CarCenterPt.CarAng;
          SDGRObjPt.ObjType             = SDG_OBJ_TYPE_UNKNOWN;
          SDGSaveObjPointToBuf(SDG_FRS_SNS_INDEX, &SDGRObjPt);
        }

        if ((bRLCSnsDisUpdated == TRUE) && (RLSnsDtDis < APACal.APASlotCorPObjExistMaxSnsDtDis)) {
          // Process RLC Sns.
          if (SlotObj1X > APACal.APASlotMaxOffsetDisBetweenObj1AndObj2ForPerpendicular) {
            SlotObj1X = 0;
          }

          if (CarCenterPt.Coordinate.x < -500) {
            // Out side slot.
            Dis1 = APACal.APASlotPRCornerSnsDtMaxObjDisOutsideSlot;
          } else {
            Dis1 = APACal.APASlotPRCornerSnsDtMaxObjDisInsideSlot[SDG_FLS_SNS_INDEX];
          }
          if ((EndPosToCurCarPosDeltaX < APACal.APASlotPRegardRCornerSnsAsNoObjDtDeltaDisToEndPosX) || (RLSnsDtDis > Dis1) ||
              (CarCenterPt.Coordinate.x < (SlotObj1X + APACal.APASlotPSDGBufRLCornerSnsDtMinCarPosX)) ||
              (CarCenterPt.CarAng < APACal.APASlotPCorMaxCarAngToAcceptRRSnsDis[SDG_FLS_SNS_INDEX])) {
            RLSnsDtDis = NO_OBJ_DISTANCE;
          } else {
            // lu zhimeng 2014 04 14
            SlotPt.Coordinate.x              = APACal.SnsPos[APA_RL_SNS_INDEX].x;
            SlotPt.Coordinate.y              = APACal.SnsPos[APA_RL_SNS_INDEX].y;
            RLCSnsPt.Coordinate              = APATrajCalPointPosWithAngAndCenterPt(SlotPt.Coordinate, CarCenterPt.CarAng, CarCenterPt.Coordinate);
            bCompDisMethodFlag               = FALSE;
            CorSnsXDisBiggerThanThresholdCnt = 0;
            if (RLCSnsPt.Coordinate.x < (SlotObj1X + APACal.APASlotPCorMinDelPosXToCorObjByAngAndDis[1])) {
              if (RLSnsDtDis > APACal.APASlotPCorMaxDisOfCorOrSideSnsDtIfCarInOutSideSlot[SDG_FLS_SNS_INDEX]) {
                RLSnsDtDis = NO_OBJ_DISTANCE;
              } else {
                for (SDGBufDisIndex = 0; SDGBufDisIndex < SDGObjInfo.SnsObjPtBuf[SDG_FLS_SNS_INDEX].ObjPtCnt; SDGBufDisIndex++) {
                  if (SDGObjInfo.SnsObjPtBuf[SDG_FLS_SNS_INDEX].ObjPtBuf[SDGBufDisIndex].ObjDis != NO_OBJ_DISTANCE) {
                    if ((SDGObjInfo.SnsObjPtBuf[SDG_FLS_SNS_INDEX].ObjPtBuf[SDGBufDisIndex].Pt.x - SlotObj1X) >=
                        APACal.APASlotPCorMinDetXOfCorOrSideSnsDtOnCarBodyIfIngoreDisDtOnCarHead[SDG_FLS_SNS_INDEX]) {
                      CorSnsXDisBiggerThanThresholdCnt++;
                    }
                    if (CorSnsXDisBiggerThanThresholdCnt >=
                        APACal.APASlotPCorMinCntOfCorOrSideSnsDtOnCarBodyIfIngoreDisDtOnCarHead[SDG_FLS_SNS_INDEX]) {
                      RLSnsDtDis = NO_OBJ_DISTANCE;
                      break;
                    }
                  }
                }
              }
              if (RLSnsDtDis != NO_OBJ_DISTANCE) {
                bCompDisMethodFlag = TRUE;
              }
            }
          }
          if (RLSnsDtDis != NO_OBJ_DISTANCE) {
            for (RLCDisIndex = 0; RLCDisIndex < (APA_SLOT_P_COR_SNS_DIS_DIV_NUM - 1); RLCDisIndex++) {
              if (RLSnsDtDis < APACal.APASlotPCorCorOrSideSnsDisArray[0][RLCDisIndex]) {
                break;
              }
            }

            APASlotCorPCarMayHitObj1CorRLCSnsMaxCompensateAng =
                APASlotPCorCorSnsDisCompensatCalculation(DeltaAngIndex, RLCDisIndex, 1, EndPosToCurCarPosDeltaAng, RLSnsDtDis, 0, bCompDisMethodFlag);

          } else {
            APASlotCorPCarMayHitObj1CorRLCSnsMaxCompensateAng = 0;
          }

          ObjPt          = APASlotProcCalObjPtCoordinateBySnsDtdDis(RLSnsDtDis, -APASlotCorPCarMayHitObj1CorRLCSnsMaxCompensateAng, APA_RL_SNS_INDEX);
          ObjPt          = APATrajCalPointPosWithAngAndCenterPt(ObjPt, CarCenterPt.CarAng, CarCenterPt.Coordinate);
          SDGRObjPt.Pt.x = ObjPt.x;
          SDGRObjPt.Pt.y = ObjPt.y;
          SDGRObjPt.ObjDis              = RLSnsDtDis;
          SDGRObjPt.CarPos.Coordinate.x = CarCenterPt.Coordinate.x;
          SDGRObjPt.CarPos.Coordinate.y = CarCenterPt.Coordinate.y;
          SDGRObjPt.CarPos.CarAng       = CarCenterPt.CarAng;
          SDGRObjPt.ObjType             = SDG_OBJ_TYPE_UNKNOWN;
          SDGSaveObjPointToBuf(SDG_FLS_SNS_INDEX, &SDGRObjPt);
        }
      }

      // if(APASlotCorrectionFlag.Bits.SlotCorrectionTimerTimeOut == TRUE)
      if ((APACal.APACalCommonFlags.Bits.bAPASlotCorPSupportCorrectSlotBorderLine == TRUE) &&
          (APASlotCorrectionFlag.Bits.ParkProcReqSlotBorderLineCorrect == TRUE)) {
        // 2.2.2 Correction during the car entering the slot:
        //      Angle between car angle and end position line is less than 15 deg.
        //      Car Pos.x > TBD (-2m) and < TBD (Car End Pos.x + lm)
        //      Car Pos.y > TBD (Obj1.y ??) and < TBD(Obj2.y)

        // 2.2.2.1 10 CH: Use rear corner sensor to check the Obj1.y.
        // 2.2.2.2 12 CH: Use both rear side sensor and rear corner sensor to check.
        // But the rear side sensor has high priority than the corner sensor.
        // If the side sensor can not detect an obj (with no object, in blind zone),
        // use the corner sensor detected object info.
        // Use the SDG method to calculate the object border angle.

        // Use SDG algorithm to fit the slot object border line.
        // 1. use the side sensor to fit the right side border line.

        // APASlotCorrectionFlag.Bits.SlotCorrectionTimerTimeOut = FALSE;

        APASlotCorrectionFlag.Bits.ParkProcReqSlotBorderLineCorrect = FALSE;

        ObjIndex2 = 0; // Right side object border line index.
        ObjIndex3 = 2; // Left side obj border line index.

        if (APASlotCorrectionFlag.Bits.RightSideLineCanNotBeCorrected == FALSE) {

          bFlag = APASlotProcInSlotCalculateSlotBorderLineWithSDGObjBuf(&(USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[0]),
                                                                        &(SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX]),
                                                                        SDG_RRS_SNS_INDEX);
          bRightSideLineExist = TRUE;
          bFlag2              = FALSE;
          if (bFlag == FALSE) {
            // 2. use the corner to fit the rigth side border line.
            if ((APACal.APACalCommonFlags.Bits.bAPASlotCorPUseRCornerSnsToCorrectSlotBorderLine == TRUE) &&
                (USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[0].EndPtIndex == 0)) {
              // Slot border line calculated by RRS Sns does not exist.
              bFlag2 =
                  APASlotProcInSlotCalculateSlotBorderLineWithSDGObjBuf(&(USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[1]),
                                                                        &(SDGObjInfo.SnsObjPtBuf[SDG_FRS_SNS_INDEX]),
                                                                        SDG_FRS_SNS_INDEX);
              if (bFlag2 == FALSE) {
                if (USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[1].EndPtIndex == 0) {
                  // Slot border line calculated by RR Sns does not exist.
                  bRightSideLineExist = FALSE;
                } else {
                  ObjIndex2       = 1;
                  RightSideLine.K = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[1].LinePar.K;
                  RightSideLine.B = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[1].LinePar.B;
                }
              } else {
                ObjIndex2       = 1;
                RightSideLine.K = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[1].LinePar.K;
                RightSideLine.B = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[1].LinePar.B;
              }
            } else {
              if (USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[0].EndPtIndex == 0) {
                // Slot border line calculated by RRS Sns does not exist.
                bRightSideLineExist = FALSE;
              } else {
                RightSideLine.K = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[0].LinePar.K;
                RightSideLine.B = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[0].LinePar.B;
              }
            }

          } else {
            RightSideLine.K = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[0].LinePar.K;
            RightSideLine.B = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[0].LinePar.B;
          }
          if (APASlotCorrectionFlag.Bits.RightSideLineHasBeenCorrected == TRUE) {
            if (EndPosToCurCarPosDeltaX < APACal.APASlotPResetSlotBorderLineMaxDeltaCarPosX) {
              // < 1m
              // Car is almost achieve the end pos.
              LineAng    = MATH_ATAN(USSPar.TrajCalSlotRightSideLine.K);
              CarAngTemp = (CarCenterPt.CarAng - PI / 2.0 - LineAng);
              fDis1      = USSPar.TrajCalSlotRightSideLine.K * CarCenterPt.Coordinate.x + USSPar.TrajCalSlotRightSideLine.B; // cross pt y.
              fDis1 -= CarCenterPt.Coordinate.y;
              Dis1 = fDis1;
              if (((CarAngTemp > -APACal.APASlotPResetSlotBorderLineMinDeltaCarAngWithEndPos1) ||
                   ((CarAngTemp > -APACal.APASlotPResetSlotBorderLineMinDeltaCarAngWithEndPos2) &&
                    (Dis1 < APACal.APASlotPResetSlotBorderLineMaxCarAndBorderLineDisY))) ||
                  (APASlotPSlotBorderLineFitSequence > 1)) {
                APASlotCorrectionFlag.Bits.ResetRightSideSlotBorderLineCheck = TRUE;
                if ((bFlag == FALSE) && (bFlag2 == FALSE)) {
                  // both side and corner sensor can not fit the line.
                  if (APASlotProcInSlotSlotCheckIfBorderLineCanBeFittedWithSDGObjBuf(&(SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX]),
                                                                                     SDG_RRS_SNS_INDEX) == FALSE) {
                    if (APASlotProcInSlotSlotCheckIfBorderLineCanBeFittedWithSDGObjBuf(&(SDGObjInfo.SnsObjPtBuf[SDG_FRS_SNS_INDEX]),
                                                                                       SDG_FRS_SNS_INDEX) == FALSE) {
                      APASlotCorrectionFlag.Bits.RightSideLineCanNotBeCorrected = TRUE;
                    }
                  }
                }
              }
            }
          }
        } else {
          bRightSideLineExist = FALSE;
        }

        if (APASlotCorrectionFlag.Bits.LeftSideLineCanNotBeCorrected == FALSE) {

          // 3. use the side sensor to fit the left side border line.
          bFlag = APASlotProcInSlotCalculateSlotBorderLineWithSDGObjBuf(&(USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[2]),
                                                                        &(SDGObjInfo.SnsObjPtBuf[SDG_RLS_SNS_INDEX]),
                                                                        SDG_RLS_SNS_INDEX);
          bLeftSideLineExist = TRUE;
          bFlag2             = FALSE;
          if (bFlag == FALSE) {
            // 2. use the corner to fit the left side border line.
            if ((APACal.APACalCommonFlags.Bits.bAPASlotCorPUseLCornerSnsToCorrectSlotBorderLine == TRUE) &&
                (USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[2].EndPtIndex == 0)) {
              // Slot border line calculated by RLS Sns does not exist.
              bFlag2 =
                  APASlotProcInSlotCalculateSlotBorderLineWithSDGObjBuf(&(USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[3]),
                                                                        &(SDGObjInfo.SnsObjPtBuf[SDG_FLS_SNS_INDEX]),
                                                                        SDG_FLS_SNS_INDEX);
              if (bFlag2 == FALSE) {
                if (USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[3].EndPtIndex == 0) {
                  // Slot border line calculated by RR Sns does not exist.
                  bLeftSideLineExist = FALSE;
                } else {
                  LeftSideLine.K = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[3].LinePar.K;
                  LeftSideLine.B = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[3].LinePar.B;
                  ObjIndex3      = 3;
                }
              } else {
                LeftSideLine.K = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[3].LinePar.K;
                LeftSideLine.B = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[3].LinePar.B;
                ObjIndex3      = 3;
              }
            } else {
              if (USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[2].EndPtIndex == 0) {
                // Slot border line calculated by RRS Sns does not exist.
                bLeftSideLineExist = FALSE;
              } else {
                LeftSideLine.K = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[2].LinePar.K;
                LeftSideLine.B = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[2].LinePar.B;
              }
            }
          } else {
            LeftSideLine.K = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[2].LinePar.K;
            LeftSideLine.B = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[2].LinePar.B;
          }
          if (APASlotCorrectionFlag.Bits.LeftSideLineHasBeenCorrected == TRUE) {
            if (EndPosToCurCarPosDeltaX < APACal.APASlotPResetSlotBorderLineMaxDeltaCarPosX) {
              // < 1m
              // Car is almost achieve the end pos.
              LineAng    = MATH_ATAN(USSPar.TrajCalSlotLeftSideLine.K);
              CarAngTemp = (CarCenterPt.CarAng - PI / 2.0 - LineAng);
              fDis1      = USSPar.TrajCalSlotLeftSideLine.K * CarCenterPt.Coordinate.x + USSPar.TrajCalSlotLeftSideLine.B; // cross pt y.
              fDis1      = CarCenterPt.Coordinate.y - fDis1;
              Dis1       = fDis1;
              if (((CarAngTemp < APACal.APASlotPResetSlotBorderLineMinDeltaCarAngWithEndPos1) ||
                   ((CarAngTemp < APACal.APASlotPResetSlotBorderLineMinDeltaCarAngWithEndPos2) &&
                    (Dis1 < APACal.APASlotPResetSlotBorderLineMaxCarAndBorderLineDisY))) ||
                  (APASlotPSlotBorderLineFitSequence > 1)) {
                APASlotCorrectionFlag.Bits.ResetLeftSideSlotBorderLineCheck = TRUE;
                if ((bFlag == FALSE) && (bFlag2 == FALSE)) {
                  // both side and corner sensor can not fit the line.

                  if (APASlotProcInSlotSlotCheckIfBorderLineCanBeFittedWithSDGObjBuf(&(SDGObjInfo.SnsObjPtBuf[SDG_RLS_SNS_INDEX]),
                                                                                     SDG_RLS_SNS_INDEX) == FALSE) {
                    if (APASlotProcInSlotSlotCheckIfBorderLineCanBeFittedWithSDGObjBuf(&(SDGObjInfo.SnsObjPtBuf[SDG_FLS_SNS_INDEX]),
                                                                                       SDG_FLS_SNS_INDEX) == FALSE) {
                      APASlotCorrectionFlag.Bits.LeftSideLineCanNotBeCorrected = TRUE;
                    }
                  }
                }
              }
            }
          }
        } else {
          bLeftSideLineExist = FALSE;
        }

        bFlag = TRUE;

        Obj1YCorMethod = USSPar.ParkProcCarEndPosition;
        if ((bLeftSideLineExist == TRUE) && (bRightSideLineExist == TRUE)) {
          if (APACal.APACalCommonFlags.Bits.bAPASlotCorPReDetermineEndPosSide == FALSE) {
          } else if (APASlotPSlotBorderLineFitSequence < 3) {
            // Dis between the two line.
            ObjPt.x       = 0;
            ObjPt.y       = RightSideLine.B;
            LineParTemp.A = LeftSideLine.K;
            LineParTemp.B = 1.0;
            LineParTemp.C = LeftSideLine.B;
            if (MATH_FABS(LeftSideLine.K) < APACal.APATrajCalLineIsHMinK) {
              LineParTemp.LineType = APALineIsHorizontal; // Line Type.
            } else {
              LineParTemp.LineType = APALineIsIncline;
            }
            fDis1 = APATrajCalGetPointToLineDis(ObjPt, LineParTemp);
            // Slot width.
            Dis1 = (APA_DISTANCE_TYPE)fDis1;

            ObjPt.x = APACal.LengthOfCar;
            ObjPt.y = RightSideLine.K * ObjPt.x + RightSideLine.B;
            fDis1   = APATrajCalGetPointToLineDis(ObjPt, LineParTemp);
            Dis2    = (APA_DISTANCE_TYPE)fDis1;

            if (Dis1 > Dis2) {
              Dis1 = Dis2;
            }

            if (USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2) {
              Dis2 = APACal.APATrajCalPMaxSlotLengthForAGivenSlot + APA_PARKPROC_CAR_END_POSITION_REDTM_SLOT_TOL1;
              if (Dis1 > Dis2) {
                // Big than a regular slot.
                // redtm the parking side.
                fDis1 = LeftSideLine.K * CarCenterPt.Coordinate.x + LeftSideLine.B;
                fDis1 = CarCenterPt.Coordinate.y - fDis1;
                fDis2 = RightSideLine.K * CarCenterPt.Coordinate.x + RightSideLine.B;
                fDis2 = fDis2 - CarCenterPt.Coordinate.y;
                if (fDis1 < fDis2) {
                  // Car is now close to obj1.
                  USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1;
                } else {
                  USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2;
                }
              }
            } else {
              // car park close to obj1 or obj2.
              Dis2 = (APACal.WidthOfCar + APACal.APAParkProcCarEndPositionToObj1Dis + APACal.APAParkProcCarEndPositionToObj2Dis);
              if (Dis1 < Dis2) {
                // Park at mid of slot.
                USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2;
              } else {
                // Remain the last state.
              }
            }
            Obj1YCorMethod = USSPar.ParkProcCarEndPosition;
          }

          if ((APACal.APACalCommonFlags.Bits.bAPASlotCorPParkParallelToObjIfEndPosIsCloseToObj == TRUE) &&
              (USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength > APACal.APATrajCalPRegardAsBigSlotLength)) {
            if (Obj1YCorMethod == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1) {
              // park close to obj1.
              // regard the obj2 as invalid.
              bRightSideLineExist = FALSE;
            } else if (Obj1YCorMethod == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2) {
              // park close to obj2.
              // regard the obj1 as invalid.
              bLeftSideLineExist = FALSE;
            }
          }
        }

        bLeftAndRightSideLineDeltaAngIsBig = FALSE;
        bInhibitObj1YUpdate                = FALSE;
        bInhibitObj2YUpdate                = FALSE;
        if (bRightSideLineExist == FALSE) {
          if (bLeftSideLineExist == FALSE) {
            // Can not correct the car end pos line.
            // just remain the previous value.
            bFlag = FALSE;
          } else {
            // Left side is fitted, but right side is not. just treat the right side as 0deg.

            USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist = TRUE;

            LineAng = MATH_ATAN(LeftSideLine.K);
#if 0
						if(USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
							// OK Obj2 exist.
							// Regard as 90deg.
							//RightSideLine.K = 0;
							//RightSideLine.B = USSPar.TrajCalObj2Pos.y;
						} else {
							// Obj2 does not exist.
							// Regard the right side line parallel to the left side line.
							// Car park at the left side and near to the left obj.
							if(APASlotPObj2NotExistObj1BorderLineFitSequence == 2) {
								//RightSideLine.K = LeftSideLine.K;
								LineAng += APACal.APASlotPObj2NotExistObj1BorderLineFitCompensateAng1;
							} else {
								LineAng += APACal.APASlotPObj2NotExistObj1BorderLineFitCompensateAng2;
							}
						}
						RightSideLine.K = MATH_TAN(LineAng);
						fDis1 = APACal.APATrajCalPCarEndPositionToObj1Dis + APACal.HalfWidthOfCar;
#endif

            if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
              // OK Obj2 exist.
              // Regard as 90deg.
              LineParTemp.A = LeftSideLine.K;
              LineParTemp.B = 1.0;
              LineParTemp.C = LeftSideLine.B;
              if (MATH_FABS(LeftSideLine.K) < APACal.APATrajCalLineIsHMinK) {
                LineParTemp.LineType = APALineIsHorizontal; // Line Type.
              } else {
                LineParTemp.LineType = APALineIsIncline;
              }

              // Get the min dis to left side line.
              Dis1         = 10000; // Delta Dis to Left side line ObjPt.Y.
              ObjIndex2    = 0x7f;
              pSDGObjPtBuf = &SDGObjInfo.SnsObjPtBuf[SDG_RRS_SNS_INDEX];
              Dis2         = (APA_DISTANCE_TYPE)USSPar.TrajCalCarEndPos.Coordinate.x;
              Dis2 -= APACal.APASlotPDtmEndPosLineCheckSideObjExisMinDeltaXDisSideSns;
              Dis3 = (APA_DISTANCE_TYPE)USSPar.TrajCalObj2Pos.x;
              for (ObjIndex = 0; ObjIndex < pSDGObjPtBuf->ObjPtCnt; ObjIndex++) {
                // Dis2 = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x -
                if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < APACal.APASlotCorPSlotBorderLineFitMaxSnsDtDis) &&
                    (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < Dis2) && (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x > Dis3)) {
                  fDis1 = LeftSideLine.K * ((APA_DISTANCE_CAL_FLOAT_TYPE)(pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x)) + LeftSideLine.B;
                  Dis4  = (APA_DISTANCE_TYPE)fDis1;
                  Dis4  = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y - Dis4;
                  if ((Dis1 > Dis4) && (Dis4 > 2000)) {
                    Dis1      = Dis4;
                    ObjIndex2 = ObjIndex;
                  }
                }
              }
              if (ObjIndex2 != 0x7f) {
                ObjPt.x = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x;
                ObjPt.y = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.y;
              }
              // if(Dis1 == 10000)
              {
                // RRS sns dose not detect an obj.
                // Use RRC sns to check.
                pSDGObjPtBuf = &SDGObjInfo.SnsObjPtBuf[SDG_FRS_SNS_INDEX];
                ObjIndex2    = 0x7f;
                Dis2         = (APA_DISTANCE_TYPE)USSPar.TrajCalCarEndPos.Coordinate.x;
                Dis2 -= APACal.APASlotPDtmEndPosLineCheckSideObjExisMinDeltaXDisCornerSns;
                for (ObjIndex = 0; ObjIndex < pSDGObjPtBuf->ObjPtCnt; ObjIndex++) {
                  if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < APACal.APASlotCorPSlotBorderLineFitMaxSnsDtDis) &&
                      (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < Dis2) && (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x > Dis3)) {
                    fDis1 = LeftSideLine.K * ((APA_DISTANCE_CAL_FLOAT_TYPE)(pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x)) + LeftSideLine.B;
                    Dis4  = (APA_DISTANCE_TYPE)fDis1;
                    Dis4  = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y - Dis4;
                    if ((Dis1 > Dis4) && (Dis4 > 2000)) {
                      Dis1      = Dis4;
                      ObjIndex2 = ObjIndex;
                    }
                  }
                }
                if (Dis1 != 10000) {
                  if (ObjIndex2 != 0x7f) {
                    ObjPt.x = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x;
                    ObjPt.y = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.y;
                  }
                } else {
                  // Due to the obj2.y is calculated based on itself, it is no need
                  // to update it. And if we update it, due to the cal tolerance
                  // the value will be become biger and biger and will induce
                  // incorect value and the car end pos and line will be incorect.
                  bInhibitObj2YUpdate = TRUE;
                  ObjPt               = USSPar.TrajCalObj2Pos;
                }
                //} else {
                //	ObjPt.x = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x;
                //	ObjPt.y = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.y;
              }

              fDis1 = APATrajCalGetPointToLineDis(ObjPt, LineParTemp);

              if (fDis1 > (APACal.APATrajCalPMaxSlotLengthForAGivenSlot + APA_PARKPROC_CAR_END_POSITION_REDTM_SLOT_TOL1)) {
                // Slot width is invalid.
                USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1;
              } else {
                // Slot width.
                if (APACal.APACalCommonFlags.Bits.bAPASlotCorPReDetermineEndPosSide == TRUE) {
                  Dis1 = (APA_DISTANCE_TYPE)fDis1;

                  if (USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2) {
                    Dis2 = APACal.APATrajCalPMaxSlotLengthForAGivenSlot + APA_PARKPROC_CAR_END_POSITION_REDTM_SLOT_TOL1;
                    if (Dis1 > Dis2) {
                      // Big than a regular slot.
                      // redtm the parking side.
                      fDis1 = LeftSideLine.K * CarCenterPt.Coordinate.x + LeftSideLine.B;
                      fDis1 = CarCenterPt.Coordinate.y - fDis1;
                      fDis2 = ObjPt.y - CarCenterPt.Coordinate.y;
                      if (fDis1 < fDis2) {
                        // Car is now close to obj1.
                        USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1;
                      } else {
                        USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2;
                      }
                    }
                  } else {
                    // car park close to obj1 or obj2.
                    Dis2 = (APACal.WidthOfCar + APACal.APAParkProcCarEndPositionToObj1Dis + APACal.APAParkProcCarEndPositionToObj2Dis);
                    if (Dis1 < Dis2) {
                      // Park at mid of slot.
                      USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2;
                    } else {
                      // Remain the last state.
                    }
                  }
                }
              }
              if (USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1) {
                // Park close to obj1.
                fDis1 = APACal.APATrajCalPCarEndPositionToObj1Dis + APACal.HalfWidthOfCar;
              } else if (USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2) {
                // Park close to obj2.
                fDis1 -= (APACal.APATrajCalPCarEndPositionToObj2Dis + APACal.HalfWidthOfCar);
              } else {
                // Mid of obj1 and obj2.
                fDis1 = fDis1 / 2;
              }
            } else {
              // Obj2 does not exist.
              // Regard the right side line parallel to the left side line.
              // Car park at the left side and near to the left obj.
              bInhibitObj2YUpdate = TRUE;
              fDis1               = APACal.APATrajCalPCarEndPositionToObj1Dis + APACal.HalfWidthOfCar;
            }

            fDis1           = fDis1 / MATH_COS(LineAng);
            RightSideLine.B = fDis1 * 2.0 + LeftSideLine.B;
            RightSideLine.K = LeftSideLine.K;
            LineAng += LineAng;

            Obj1YCorMethod = APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2; // Mide of the left and right side line.
          }
        } else {
          USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist = TRUE;

          LineAng = MATH_ATAN(RightSideLine.K);
          if (bLeftSideLineExist == FALSE) {
            // Right side is fitted, but left side is not. just treat the left side as 0deg.
            LeftSideLine.K = RightSideLine.K;
            if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE) {
              // OK Obj1 exist.
              // Regard as 90deg.
              LineParTemp.A = RightSideLine.K;
              LineParTemp.B = 1.0;
              LineParTemp.C = RightSideLine.B;
              if (MATH_FABS(RightSideLine.K) < APACal.APATrajCalLineIsHMinK) {
                LineParTemp.LineType = APALineIsHorizontal; // Line Type.
              } else {
                LineParTemp.LineType = APALineIsIncline;
              }

              // Get the min dis to right side line.
              Dis1         = 10000; // delta dis to right side line ObjPt.Y.
              ObjIndex2    = 0x7f;
              pSDGObjPtBuf = &SDGObjInfo.SnsObjPtBuf[SDG_RLS_SNS_INDEX];
              Dis2         = (APA_DISTANCE_TYPE)USSPar.TrajCalCarEndPos.Coordinate.x;
              Dis2 -= APACal.APASlotPDtmEndPosLineCheckSideObjExisMinDeltaXDisSideSns;
              Dis3 = (APA_DISTANCE_TYPE)USSPar.TrajCalObj1Pos.x;
              for (ObjIndex = 0; ObjIndex < pSDGObjPtBuf->ObjPtCnt; ObjIndex++) {
                // Dis2 = pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x -
                if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < APACal.APASlotCorPSlotBorderLineFitMaxSnsDtDis) &&
                    (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < Dis2) && (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x > Dis3)) {
                  fDis1 = RightSideLine.K * ((APA_DISTANCE_CAL_FLOAT_TYPE)(pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x)) + RightSideLine.B;
                  Dis4  = (APA_DISTANCE_TYPE)fDis1;
                  Dis4  = Dis4 - pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y;
                  if ((Dis1 > Dis4) && (Dis4 > 2000)) {
                    Dis1      = Dis4;
                    ObjIndex2 = ObjIndex;
                  }
                }
              }
              if (ObjIndex2 != 0x7f) {
                ObjPt.x = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x;
                ObjPt.y = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.y;
              }
              // if(Dis1 == 10000)
              {
                // RLS sns dose not detect an obj.
                // Use RLC sns to check.
                pSDGObjPtBuf = &SDGObjInfo.SnsObjPtBuf[SDG_FLS_SNS_INDEX];
                ObjIndex2    = 0x7f;
                Dis2         = (APA_DISTANCE_TYPE)USSPar.TrajCalCarEndPos.Coordinate.x;
                Dis2 -= APACal.APASlotPDtmEndPosLineCheckSideObjExisMinDeltaXDisCornerSns;
                for (ObjIndex = 0; ObjIndex < pSDGObjPtBuf->ObjPtCnt; ObjIndex++) {
                  if ((pSDGObjPtBuf->ObjPtBuf[ObjIndex].ObjDis < APACal.APASlotCorPSlotBorderLineFitMaxSnsDtDis) &&
                      (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x < Dis2) && (pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x > Dis3)) {
                    fDis1 = RightSideLine.K * ((APA_DISTANCE_CAL_FLOAT_TYPE)(pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.x)) + RightSideLine.B;
                    Dis4  = (APA_DISTANCE_TYPE)fDis1;
                    Dis4  = Dis4 - pSDGObjPtBuf->ObjPtBuf[ObjIndex].Pt.y;
                    if ((Dis1 > Dis4) && (Dis4 > 2000)) {
                      Dis1      = Dis4;
                      ObjIndex2 = ObjIndex;
                    }
                  }
                }
                if (Dis1 != 10000) {
                  if (ObjIndex2 != 0x7f) {
                    ObjPt.x = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x;
                    ObjPt.y = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.y;
                  }
                } else {
                  // Due to the obj1.y is calculated based on itself, it is no need
                  // to update it. And if we update it, due to the cal tolerance
                  // the value will be become biger and biger and will induce
                  // incorect value and the car end pos and line will be incorect.
                  bInhibitObj1YUpdate = TRUE;
                  ObjPt               = USSPar.TrajCalObj1Pos;
                }
                //} else {
                //	ObjPt.x = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.x;
                //	ObjPt.y = pSDGObjPtBuf->ObjPtBuf[ObjIndex2].Pt.y;
              }

              fDis1 = APATrajCalGetPointToLineDis(ObjPt, LineParTemp);

              if (fDis1 > (APACal.APATrajCalPMaxSlotLengthForAGivenSlot + APA_PARKPROC_CAR_END_POSITION_REDTM_SLOT_TOL1)) {
                // Slot width is invalid.
                USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2;
              } else {

                // Slot width.
                Dis1 = (APA_DISTANCE_TYPE)fDis1;

                if (APACal.APACalCommonFlags.Bits.bAPASlotCorPReDetermineEndPosSide == TRUE) {
                  if (USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2) {
                    Dis2 = APACal.APATrajCalPMaxSlotLengthForAGivenSlot + APA_PARKPROC_CAR_END_POSITION_REDTM_SLOT_TOL1;
                    if (Dis1 > Dis2) {
                      // Big than a regular slot.
                      // redtm the parking side.
                      fDis1 = CarCenterPt.Coordinate.y - ObjPt.y;
                      fDis2 = RightSideLine.K * CarCenterPt.Coordinate.x + RightSideLine.B;
                      fDis2 = fDis2 - CarCenterPt.Coordinate.y;
                      if (fDis1 < fDis2) {
                        // Car is now close to obj1.
                        USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1;
                      } else {
                        USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2;
                      }
                    }
                  } else {
                    // car park close to obj1 or obj2.
                    Dis2 = (APACal.WidthOfCar + APACal.APAParkProcCarEndPositionToObj1Dis + APACal.APAParkProcCarEndPositionToObj2Dis);
                    if (Dis1 < Dis2) {
                      // Park at mid of slot.
                      USSPar.ParkProcCarEndPosition = APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2;
                    } else {
                      // Remain the last state.
                    }
                  }
                }
              }
              if (USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1) {
                // Park close to obj1.
                fDis1 -= (APACal.APATrajCalPCarEndPositionToObj1Dis + APACal.HalfWidthOfCar);
              } else if (USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ2) {
                // Park close to obj2.
                fDis1 = APACal.APATrajCalPCarEndPositionToObj2Dis + APACal.HalfWidthOfCar;
              } else {
                // Mid of obj1 and obj2.
                fDis1 = fDis1 / 2;
              }
            } else {
              // Obj1 does not exist.
              // Regard the right side line parallel to the left side line.
              // Car park at the left side and near to the left obj.

              bInhibitObj1YUpdate = TRUE;
              fDis1               = APACal.APATrajCalPCarEndPositionToObj2Dis + APACal.HalfWidthOfCar;
            }
            fDis1          = fDis1 / MATH_COS(LineAng);
            LeftSideLine.B = RightSideLine.B - fDis1 * 2.0;
            LineAng += LineAng;

            Obj1YCorMethod = APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2; // Mide of the left and right side line.

          } else {
            // Both left and right side line exist.
            USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist = TRUE;

            CarAngTemp = MATH_ATAN(LeftSideLine.K);

            if (MATH_FABS(CarAngTemp - LineAng) > APACal.APASlotCorPRegardSlotBorderLineDeltaAngIsBigMinDeltaAng) {
              bLeftAndRightSideLineDeltaAngIsBig = TRUE;
            }

            LineAng += CarAngTemp;
#if 0
						Dis1 = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[ObjIndex2].LineDepth; // Right side.
						Dis2 = USSPar.Slot[USSPar.APARightSlotDataIndex].BorderLineInfo.LineBuf[ObjIndex3].LineDepth;// Left side.
						if(Dis1 < Dis2) {
							// right side line len is less than left side line len
							if(Dis1 < APACal.APASlotCorPSlotBorderLineFitMinLineLen2) {
								// Regard the right side line as invalid. just use left side line.
								bRightSideLineExist = FALSE;
								LineAng = MATH_ATAN(LeftSideLine.K);
								if(APASlotPObj2NotExistObj1BorderLineFitSequence == 2) { // ??? need to debug ??
									//RightSideLine.K = LeftSideLine.K;
									LineAng += APACal.APASlotPObj2NotExistObj1BorderLineFitCompensateAng1;
								} else {
									LineAng += APACal.APASlotPObj2NotExistObj1BorderLineFitCompensateAng2;
								}
								RightSideLine.K = MATH_TAN(LineAng);
								fDis1 = APACal.APATrajCalPCarEndPositionToObj1Dis + APACal.HalfWidthOfCar;
								fDis1 = fDis1 / MATH_COS(LineAng);
								RightSideLine.B = fDis1 * 2.0 + LeftSideLine.B;
								LineAng += LineAng;
							} else {
								LineAng += MATH_ATAN(LeftSideLine.K);
							}
						} else {
							// left side line len is less than right side line len
							if(Dis1 < APACal.APASlotCorPSlotBorderLineFitMinLineLen2) {
								// Regard the left side line as invalid. just use right side line.
								bLeftSideLineExist = FALSE;
								LeftSideLine.K = RightSideLine.K;
								fDis1 = APACal.APATrajCalPCarEndPositionToObj2Dis + APACal.HalfWidthOfCar;
								fDis1 = fDis1 / MATH_COS(LineAng);
								LeftSideLine.B = RightSideLine.B - fDis1 * 2.0;
								LineAng += LineAng;
							} else {
								LineAng += MATH_ATAN(LeftSideLine.K);
							}
						}
#endif
          }
        }

        if (bFlag == FALSE) {
          if ((APASlotCorrectionFlag.Bits.RightAndLeftSideLineCanNotBeCorrectedEndPosLineReseted == FALSE) && (bRightSideLineExist == FALSE) &&
              (bLeftSideLineExist == FALSE) &&
              ((APASlotCorrectionFlag.Bits.RightSideLineCanNotBeCorrected == TRUE) ||
               (APASlotCorrectionFlag.Bits.LeftSideLineCanNotBeCorrected == TRUE))) {
            // Reset the end position line and
            if (((CarCenterPt.CarAng > APACal.APASlotCorPAllowEndPosLineAngResetMinEndPosCarAng) &&
                 (CarCenterPt.CarAng < APACal.APASlotCorPAllowEndPosLineAngResetMaxEndPosCarAng)) ||
                (APASlotPSlotBorderLineFitSequence < 3)) {
              // Within the tolerance.
              // Just reset the end position line.
              APASlotCorrectionFlag.Bits.SlotBorderLineHasBeenCorrected = FALSE;
              APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength, 1);
              // APASlotCorrectionFlag.Bits.SlotBorderLineHasBeenCorrected = TRUE;
              APASlotCorrectionFlag.Bits.RightAndLeftSideLineCanNotBeCorrectedEndPosLineReseted = TRUE;
            }
          }
          bLeftAndRightSideLineDeltaAngIsBig = FALSE;
        } else {

          if ((APASlotPSlotBorderLineFitSequence & 0x01) == 1) {
            if ((MATH_FABS(CarCenterPt.CarAng - USSPar.TrajCalCarEndPos.CarAng) <
                 APACal.APASlotCorPSlotBorderLineFitStartCheckFitSeqenceMaxDetalAng)) {
              if (EndPosToCurCarPosDeltaX > APACal.APASlotCorPSlotBorderLineFitRegardAsOneStepOutSlotMinDeltaCarPosX) {
                APASlotPSlotBorderLineFitSequence++;
              }
            }
          }

          USSPar.TrajCalSlotLeftSideLine  = LeftSideLine;
          USSPar.TrajCalSlotRightSideLine = RightSideLine;

          LineAng = LineAng / 2.0; // Mean angle of left and right side border line.
          /*ObjPt.x = USSPar.TrajCalObj1Pos.x;
           if(ObjPt.x > USSPar.TrajCalObj2Pos.x) {
           ObjPt.x = USSPar.TrajCalObj2Pos.x;
           }
           ObjPt.x += APACal.LenBetweenRAxisAndFBumper;// APACal.LengthOfCar / 2; // Car end pos center point.x
           */
          ObjPt.x = USSPar.TrajCalCarEndPos.Coordinate.x + APACal.LenBetweenRAxisAndRBumper;
          fDis2 =
              (RightSideLine.K * ObjPt.x + RightSideLine.B + LeftSideLine.K * ObjPt.x + LeftSideLine.B) / 2.0; // Car end pos center point.y. Mid pt.
          if (Obj1YCorMethod == APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2) {
            // Mide of the left and right side line.
            ObjPt.y = fDis2;
          } else if (Obj1YCorMethod == APA_PARKPROC_CAR_END_POSITION_CLOSE_TO_OBJ1) {
            // Close to obj1.
            fDis1   = APACal.APATrajCalPCarEndPositionToObj1Dis + APACal.HalfWidthOfCar;
            fDis1   = fDis1 / MATH_COS(LineAng);
            ObjPt.y = LeftSideLine.K * ObjPt.x + LeftSideLine.B + fDis1;
            if (fDis2 < ObjPt.y) {
              ObjPt.y = fDis2;
            }
          } else {
            // Close to obj2.
            fDis1   = APACal.APATrajCalPCarEndPositionToObj2Dis + APACal.HalfWidthOfCar;
            fDis1   = fDis1 / MATH_COS(LineAng);
            ObjPt.y = RightSideLine.K * ObjPt.x + RightSideLine.B - fDis1;
            if (fDis2 > ObjPt.y) {
              ObjPt.y = fDis2;
            }
          }

          EndPosLine.K = MATH_TAN(LineAng);                // End Pos Line.k
          EndPosLine.B = ObjPt.y - EndPosLine.K * ObjPt.x; // end pos line.b

#if 0
									// Check if the caled end pos line is reasonable?
									if((Obj1YCorMethod == 0)
											&& (MATH_FABS(CarCenterPt.CarAng - PI / 2.0 - LineAng)
													< APACal.APASlotCorPChkEndPosLineMaxDeltaCarAngAndEndPosLineAng)) {
										if((CarCenterPt.Coordinate.x > 0)
												&& ((EndPosToCurCarPosDeltaX < 500))) {
											// RearSnsDtMinDis = USSPar.ParkProcRearSnsDtdNearestDis;
											if(USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
												//RRSSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_RS_EMIT_RS_RX_OBJ_INDEX];
												RRSSnsDtDis = APASideSnsDtObjDis[PARearSys][0];
												RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX];
												RLSSnsDtDis = APASideSnsDtObjDis[PARearSys][1];
												RLSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX];
											} else {
												// Actually RRSSnsDtDis : left side sns
												//RRSSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_LS_EMIT_LS_RX_OBJ_INDEX];
												RRSSnsDtDis = APASideSnsDtObjDis[PARearSys][1];
												RRSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_L_EMIT_L_RX_OBJ_INDEX];
												RLSSnsDtDis = APASideSnsDtObjDis[PARearSys][0];
												RLSnsDtDis = SnsDtObjNearestDisInfo[PARearSys].wDis[UPA_APA_SNS_R_EMIT_R_RX_OBJ_INDEX];
											}

											if(RRSnsDtDis != NO_OBJ_DISTANCE) {
												RRSnsDtDis *= 10; // cm -> mm.
												CarAngTemp = 2.0 * PI - APACal.SnsAng[APA_RR_SNS_INDEX];
												Dis1 = APACal.HalfWidthOfCar - APACal.SnsPos[APA_RR_SNS_INDEX].x;
												fDis1 = RRSnsDtDis;
												fDis1 = fDis1 * MATH_SIN(CarAngTemp) - Dis1;
												Dis1 = fDis1;

												if(RRSSnsDtDis != NO_OBJ_DISTANCE) {
													CarAngTemp = 2.0 * PI - APACal.SnsAng[APA_RRS_SNS_INDEX];
													Dis2 = APACal.HalfWidthOfCar - APACal.SnsPos[APA_RRS_SNS_INDEX].x;
													fDis1 = RRSSnsDtDis;
													fDis1 = fDis1 * MATH_SIN(CarAngTemp) - Dis2;
													Dis2 = fDis1;

													if(Dis2 < Dis1) {
														RRSSnsDtDis = Dis2;
													} else {
														RRSSnsDtDis = Dis1;
													}

												} else {
													RRSSnsDtDis = Dis1;
												}
											}

											if(RLSnsDtDis != NO_OBJ_DISTANCE) {
												RLSnsDtDis *= 10; // cm -> mm.
												CarAngTemp = APACal.SnsAng[APA_RL_SNS_INDEX] - PI;
												Dis1 = APACal.HalfWidthOfCar + APACal.SnsPos[APA_RL_SNS_INDEX].x;
												fDis1 = RLSnsDtDis;
												fDis1 = fDis1 * MATH_SIN(CarAngTemp) - Dis1;
												Dis1 = fDis1;

												if(RLSSnsDtDis != NO_OBJ_DISTANCE) {
													CarAngTemp = APACal.SnsAng[APA_RLS_SNS_INDEX] - PI;
													Dis2 = APACal.HalfWidthOfCar + APACal.SnsPos[APA_RLS_SNS_INDEX].x;
													fDis1 = RLSSnsDtDis;
													fDis1 = fDis1 * MATH_SIN(CarAngTemp) - Dis2;
													Dis2 = fDis1;

													if(Dis2 < Dis1) {
														RLSSnsDtDis = Dis2;
													} else {
														RLSSnsDtDis = Dis1;
													}

												} else {
													RLSSnsDtDis = Dis1;
												}
											}

											// Cal the Y
											fDis1 = RightSideLine.K * CarCenterPt.x + RightSideLine.B - CarCenterPt.Coordinate.y;
											CarAngTemp = MATH_SIN(CarCenterPt.CarAng);
											fDis1 *= CarAngTemp;
											if(RRSSnsDtDis == NO_OBJ_DISTANCE) {
												if((RLSSnsDtDis > APACal.APASlotCorPChkEndPosLineMaxCarSideToObjDis)
														|| (RLSSnsDtDis > APACal.APATrajCalPCarEndPositionToObj1Dis)) {
													// Do not correct.
												} else {
													// Car is close to obj1.
													// Car angle
													Dis1 = APACal.APATrajCalPCarEndPositionToObj1Dis - RLSSnsDtDis;
													if(fDis1 < Dis1) {
														// Compensate the distance.
														fDis1 = Dis1 - fDis1;
														fDis1 = fDis1 / CarAngTemp;
														RightSideLine.B += fDis1;
													}
												}
											} else {
												if(RLSSnsDtDis == NO_OBJ_DISTANCE) {
													if((RRSSnsDtDis > APACal.APASlotCorPChkEndPosLineMaxCarSideToObjDis)
															|| (RRSSnsDtDis > APACal.APATrajCalPCarEndPositionToObj2Dis)) {
														// Do not correct.
													} else {
														// Car is close to obj2.
														// Car angle
														fDis1 = -fDis1;
														Dis1 = APACal.APATrajCalPCarEndPositionToObj2Dis - RRSSnsDtDis;
														if(fDis1 < Dis1) {
															// Compensate the distance.
															fDis1 = Dis1 - fDis1;
															fDis1 = fDis1 / CarAngTemp;
															RightSideLine.B -= fDis1;
														}
													}

												} else {
													// Both side detects obj dis.
													if(RLSSnsDtDis > RRSSnsDtDis) {
														// Car close to obj2.
														if(RRSSnsDtDis < APACal.APATrajCalPCarEndPositionToObj2Dis) {
															if
														}
													} else {
														// Car close to obj1.
													}
												}

											}

											if(fDis1 > 0) {
												// Car is now under the end pos line.
											} else {
												// Car is now above the end pos line.
											}

										}
									}

#endif

          if ((USSPar.ParkProcCarEndPosition == APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2) && (bLeftSideLineExist == TRUE)) {

            // Check if the car end pos almost achieved ?

            CarAngTemp = MATH_FABS(EndPosToCurCarPosDeltaAng);
            fDis1      = USSPar.TrajCalCarEndPosLine.A * CarCenterPt.Coordinate.x + USSPar.TrajCalCarEndPosLine.C; // Y.
            Dis1       = (APA_DISTANCE_TYPE)fDis1;

            Dis2 = USSPar.ParkProcCarEndPositionTol;

            if ((EndPosToCurCarPosDeltaX < APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMinDeltaX) &&
                (CarAngTemp < APACal.APAParkProcPInSlotStartUseCorSteeringAngleDeltaCarAngle) && (Dis1 < Dis2)) {
              // End pos almost achieved.
              // do not recheck if offset a dis or not.
              // just remain the last state.
              if (APASlotCorrectionFlag.Bits.EndPosYHasBeenCorrectedToOffsetFromObj1 == TRUE) {
                EndPosLine.B += APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlot;
              }
            } else {

              SlotLen              = APACal.LengthOfCar / 2;
              ObjPt.x              = SlotLen;
              ObjPt.y              = EndPosLine.K * ObjPt.x + EndPosLine.B; // Car Mid Point Y.
              LineParTemp.LineType = APALineIsIncline;
              LineParTemp.A        = LeftSideLine.K;
              LineParTemp.C        = LeftSideLine.B;
              LineParTemp.B        = 1.0;
              fDis3                = APATrajCalGetPointToLineDis(ObjPt, LineParTemp);
              SlotLen              = (APA_DISTANCE_TYPE)fDis3;
              SlotLen *= 2;
              if (APASlotCorrectionFlag.Bits.EndPosYHasBeenCorrectedToOffsetFromObj1 == FALSE) {
                if ((SlotLen > (APACal.WidthOfCar + APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMinSideDis)) &&
                    (SlotLen < (APACal.WidthOfCar + APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMaxSideDis))) {
                  EndPosLine.B += APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlot;
                  APASlotCorrectionFlag.Bits.EndPosYHasBeenCorrectedToOffsetFromObj1 = TRUE;
                }
              } else {
                if ((SlotLen < (APACal.WidthOfCar + APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMinSideDis -
                                APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlotResetTol)) ||
                    (SlotLen > (APACal.WidthOfCar + APACal.APATrajCalPCarEndPositionOffsetToObj1DisSmallSlotMaxSideDis +
                                APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlotResetTol))) {
                  APASlotCorrectionFlag.Bits.EndPosYHasBeenCorrectedToOffsetFromObj1 = FALSE;
                } else {
                  EndPosLine.B += APACal.APATrajCalPCarEndPositionOffsetToObj1DisForSmallSlot;
                }
              }
            }
          }

          fDis1      = APACal.LenBetweenRAxisAndFBumper;
          CarAngTemp = MATH_FABS(LineAng);
          fDis1      = fDis1 * MATH_COS(CarAngTemp);
          fDis2      = APACal.HalfWidthOfCar + 300;
          fDis2      = fDis2 * MATH_SIN(CarAngTemp);
          fDis1 += fDis2;
          Dis1           = USSPar.SlotCarEndPosXPrevValue - APACal.LenBetweenRAxisAndFBumper;
          ObjPt.x        = ((APA_DISTANCE_CAL_FLOAT_TYPE)Dis1) + fDis1;
          ObjPt.y        = EndPosLine.K * ObjPt.x + EndPosLine.B;
          Obj2YCorMethod = APALineIsIncline; // End pos line type.
          if (MATH_FABS(EndPosLine.K) < APACal.APATrajCalLineIsHMinK) {
            Obj2YCorMethod = APALineIsHorizontal; // Line Type.
          }

          // Check if it is necessary to update the car end pos ang.
          LineAng += PI / 2.0;
          if (EndPosToCurCarPosDeltaX < APACal.APASlotCorPSlotBorderLineFitEndPosLineUpdateTolDevidedCarToEndPosDis) {
            // < 50cm. use big tol.
            DeltaCarAngTol       = APACal.APASlotCorPSlotBorderLineFitEndPosAngUpdateMinTolAng2;
            EndPosLineUpdateCTol = APACal.APASlotCorPSlotBorderLineFitEndPosLineUpdateMinCTol2;
          } else {
            // Use small tol.
            DeltaCarAngTol       = APACal.APASlotCorPSlotBorderLineFitEndPosAngUpdateMinTolAng1;
            EndPosLineUpdateCTol = APACal.APASlotCorPSlotBorderLineFitEndPosLineUpdateMinCTol1;
          }
          if ((ObjPt.x > 0) && (ObjPt.x < APACal.LengthOfCar) && (ObjPt.y > -8000) && (ObjPt.y < 5000) && (LineAng > (20.0 * PI / 180.0)) &&
              (LineAng < (160.0 * PI / 180.0)) && (EndPosLine.K > -2.7) && (EndPosLine.K < 2.7) &&
              (EndPosLine.B < USSPar.TrajCalSlotRightSideLine.B) && (EndPosLine.B > USSPar.TrajCalSlotLeftSideLine.B) &&
              ((MATH_FABS(USSPar.TrajCalCarEndPos.CarAng - LineAng) > DeltaCarAngTol) ||
               (MATH_FABS(USSPar.TrajCalCarEndPosLine.C - EndPosLine.B) > EndPosLineUpdateCTol))) {
            // Recorrect Obj1.y, obj2.y

            fDis1 = USSPar.TrajCalSlotRightSideLine.K * USSPar.TrajCalObj2Pos.x + USSPar.TrajCalSlotRightSideLine.B;
            fDis2 = USSPar.TrajCalSlotLeftSideLine.K * USSPar.TrajCalObj1Pos.x + USSPar.TrajCalSlotLeftSideLine.B;

            if ((fDis1 > 8000) || (fDis1 < -10000)) {
              // Invalid Data.
              // bInhibitObj2YUpdate = TRUE;
            } else if ((fDis2 > 6000) || (fDis2 < -12000)) {
              // Invalid Data.
              // bInhibitObj1YUpdate = TRUE;
            } else {

              if (bInhibitObj2YUpdate == FALSE) {
                if (fDis1 > USSPar.TrajCalObj2Pos.y) {
                  USSPar.TrajCalObj2Pos.y = fDis1;
                }
              }
              if (bRightSideLineExist == TRUE) {
                APASlotCorrectionFlag.Bits.RightSideLineHasBeenCorrected = TRUE;
              } else {
              }
              if (bInhibitObj1YUpdate == FALSE) {
                if (fDis2 < USSPar.TrajCalObj1Pos.y) {
                  USSPar.TrajCalObj1Pos.y = fDis2;
                }
              }
              if (bLeftSideLineExist == TRUE) {
                APASlotCorrectionFlag.Bits.LeftSideLineHasBeenCorrected = TRUE;
              }

              APASlotCorrectionFlag.Bits.SlotBorderLineHasBeenCorrected = TRUE;
              APASlotPSlotCorEndPosYCalMethod                           = Obj1YCorMethod;

              APASlotCorrectionIndicationFlag.Bits.CarEndPosYChanged = TRUE;
              // USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength = SlotLen;
              USSPar.TrajCalCarEndPos.Coordinate.x = ObjPt.x;
              USSPar.TrajCalCarEndPos.Coordinate.y = ObjPt.y;
              USSPar.TrajCalCarEndPosLine.LineType = (APALineIsVerticalOrHorizontalType)Obj2YCorMethod;
              USSPar.TrajCalCarEndPosLine.A        = EndPosLine.K;
              USSPar.TrajCalCarEndPosLine.B        = 1.0;
              USSPar.TrajCalCarEndPosLine.C        = EndPosLine.B;
              USSPar.TrajCalCarEndPos.CarAng       = LineAng;
#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
              bCarEndPosLineChanged = TRUE;
#endif
            }
          }
        }
        // APASlotCorrectionIndicationFlag.Bits.RightSideLineExist = bRightSideLineExist;
        // APASlotCorrectionIndicationFlag.Bits.LeftSideLineExist = bLeftSideLineExist;
        APASlotCorrectionIndicationFlag.Bits.LeftAndRightSideLineDeltaAngIsBig = bLeftAndRightSideLineDeltaAngIsBig;
      }
    }
#endif

    // 3. Check if the car will hit obj1 or obj2 in the slot ??
    bCarHitRObj     = FALSE;
    bCarCloseToRObj = FALSE;
#if 1 /* DX7 */
    SlotObj1Y = USSPar.TrajCalObj1Pos.y;
#endif
    if ((CarCenterPt.CarAng > APA_SLOT_PER_OBJ1Y_OBJ2Y_HIT_REAR_BUMPER_CHECK_CAR_POS_ANG_MIN1) &&
        (CarCenterPt.CarAng < APA_SLOT_PER_OBJ1Y_OBJ2Y_HIT_REAR_BUMPER_CHECK_CAR_POS_ANG_MAX1) &&
        (CarCenterPt.Coordinate.y > APA_SLOT_PER_OBJ1Y_OBJ2Y_HIT_REAR_BUMPER_CHECK_CAR_POS_Y_MIN1) &&
        (CarCenterPt.Coordinate.y < APA_SLOT_PER_OBJ1Y_OBJ2Y_HIT_REAR_BUMPER_CHECK_CAR_POS_Y_MAX1) &&
        (CarCenterPt.Coordinate.x > APA_SLOT_PER_OBJ1Y_OBJ2Y_HIT_REAR_BUMPER_CHECK_CAR_POS_X_MIN1) &&
        (CarCenterPt.Coordinate.x < APA_SLOT_PER_OBJ1Y_OBJ2Y_HIT_REAR_BUMPER_CHECK_CAR_POS_X_MAX1)) {
      // 3.2 rear bumper
      CarAngTemp = MATH_FABS(CarCenterPt.CarAng - USSPar.TrajCalCarEndPos.CarAng);
      fDis1      = USSPar.TrajCalCarEndPosLine.A * CarCenterPt.Coordinate.x + USSPar.TrajCalCarEndPosLine.C; // Y.
      ObjIndex   = 2;                                                                                              // default to car will not hit obj.

      if (CarAngTemp < (2.0 * PI / 180.0)) {
        // Car is almost parallel to the end pos line.
        fDis2 = APACal.LenBetweenRAxisAndRBumper + APACal.APATrajCalSafetyDisToObjAtRear / 2;
        if (CarCenterPt.Coordinate.y > fDis1) {
          // car is above the end pos line.
          // check if the car will hit the obj2.
          if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
            fDis1 = CarRCornerPt.x - USSPar.TrajCalObj2Pos.x;
            if (fDis1 > -fDis2) {
              // car may hit obj2.
              ObjIndex = 1; // check obj2
            }
          }
        } else {
          // car is under the end pos line.
          // check if the car will hit the obj1.
          if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE) {
            fDis1 = CarLCornerPt.x - USSPar.TrajCalObj1Pos.x;
            if (fDis1 > -fDis2) {
              // car may hit obj1.
              ObjIndex = 0; // check obj1
            }
          }
        }

      } else {
        //
        if (CarCenterPt.CarAng > USSPar.TrajCalCarEndPos.CarAng) {
          // Check the Obj2.
          if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
            ObjIndex = 1; // check obj2
          }
        } else {
          // Check the Obj1.
          if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE) {
            ObjIndex = 0; // check obj1
          }
        }
      }

      bFlag  = FALSE; // obj1 hit obj flag.
      bFlag2 = FALSE; // obj2 hit obj flag.
      if (ObjIndex == 0) {
        // Check Obj1.
        bCarHitRObj = APATrajCalPerpendCheckIfCurCarWillHitObj12OrSlotBorderLine(&CarCenterPt, TRUE, FALSE, TRUE, FALSE);
        bFlag       = bCarHitRObj;
        Dis1        = CarLCornerPt.x - USSPar.TrajCalObj1Pos.x;

        if (Dis1 > -400) {
          if (Dis1 > 0) {
            fDis1 = USSPar.TrajCalSlotLeftSideLine.K * CarLCornerPt.x + USSPar.TrajCalSlotLeftSideLine.B;
          } else {
            fDis1 = USSPar.TrajCalObj1Pos.y;
          }
          Dis1 = CarLCornerPt.y - fDis1;
          if (Dis1 < APACal.APAParkProcPRegardedAsCarCloseToObjMinDeltaY) {
            bCarCloseToRObj = TRUE; // car rear left corner is very close to obj1.
          }
        }

      } else if (ObjIndex == 1) {
        // Check Obj2.
        bCarHitRObj = APATrajCalPerpendCheckIfCurCarWillHitObj12OrSlotBorderLine(&CarCenterPt, FALSE, TRUE, FALSE, TRUE);
        bFlag2      = bCarHitRObj;
        Dis1        = CarRCornerPt.x - USSPar.TrajCalObj2Pos.x;
        if (Dis1 > -400) {
          if (Dis1 > 0) {
            fDis1 = USSPar.TrajCalSlotRightSideLine.K * CarRCornerPt.x + USSPar.TrajCalSlotRightSideLine.B;
          } else {
            fDis1 = USSPar.TrajCalObj2Pos.y;
          }
          Dis1 = CarRCornerPt.y - fDis1;
          if (Dis1 < APACal.APAParkProcPRegardedAsCarCloseToObjMinDeltaY) {
            bCarCloseToRObj = TRUE; // car rear left corner is very close to obj1.
          }
        }
      }

      if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj1Exist == TRUE) {
        Dis1 = CarLCornerPt.x - USSPar.TrajCalObj1Pos.x;
        if (((Dis1 > -400) || ((bFlag == TRUE) && (Dis1 > -600))) &&
            ((CarLCornerPt.y < USSPar.TrajCalObj1Pos.y) || ((CarLCornerPt.y < (USSPar.TrajCalObj1Pos.y - 200)) && (Dis1 < 150)))) {
          bFlag = TRUE; // car rear right corner is very close to obj1.
        }
      }
      if (USSPar.APACommonFlags.Bits.bSlotProcSlotObj2Exist == TRUE) {
        Dis1 = CarRCornerPt.x - USSPar.TrajCalObj2Pos.x;
        if (((Dis1 > -400) || ((bFlag2 == TRUE) && (Dis1 > -600))) &&
            ((CarRCornerPt.y > USSPar.TrajCalObj2Pos.y) || ((CarRCornerPt.y > (USSPar.TrajCalObj2Pos.y - 200)) && (Dis1 < 150)))) {
          bFlag2 = TRUE; // car rear right corner is very close to obj2.
        }
      }

      // Check if the obj1 and obj2 is valid, if not just reset to the original obj1/2 during searching slot.
      if (bFlag == TRUE) {
        // check obj1
        // RearSnsDtMinDis = USSPar.ParkProcRearSnsDtdNearestDis;
        RLMSnsDtDis = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.LObjDis;
        RLSnsDtDis  = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.LSObjDis;

        if ((RLMSnsDtDis > 700) && (RLSnsDtDis > 600)) {
          // Out of detect tol, obj1 is invalid.
          // reset obj1.
          Dis1 = (APA_DISTANCE_TYPE)SlotObj1Y;
          if (Dis1 > APASlotCorrectionOriginalObj1Y) {
            // reset to the original obj1y.
            ObjPt1Y   = APASlotCorrectionOriginalObj1Y;
            SlotLen   = SlotObj2Y - ObjPt1Y;
            Dis1      = APACal.APASlotPMinSmallSlotLen - SlotLen;
            CalResult = 0;
            if (Dis1 > APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS) {
              // ?? Data error
              // ?? Actually code should never reach.
              // If yes. it may be the Obj2.y compensate to much.
              // Just ignore the current correction and return.
              CalResult = 1;
            } else if (Dis1 > 0) {
              SlotLen = APACal.APASlotPMinSmallSlotLen;
              // The Obj1.y and Obj2.y will be compensated with Dis1 / 2.
              USSPar.TrajCalObj2Pos.y += Dis1;
              //} else if(SlotLen > APACal.APASlotPMaxSlotLength) {
              // ?? Data error or the car has just run over the Obj1 and Obj1 has moved away.
              // Just treat as the bigest slot length.
              //	SlotLen = APACal.APASlotPMaxSlotLength;
              //	ObjPt1Y = SlotObj2Y - SlotLen;
            } else {
              // The slot length is still within the min small slot len range.
              // OK.
            }
            // adjust the car end pos.y
            if (CalResult == 0) {
              // Recorrect the slot length.

              USSPar.TrajCalObj1Pos.y = ObjPt1Y;
              bCarHitRObj = FALSE;
              APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(SlotLen, 0);
            } else {
              // It is an error.
              // Can not be corrected.
              // just remain the previous value.
            }
          }
        }
      }
      if (bFlag2 == TRUE) {
        // check obj2
        // RearSnsDtMinDis = USSPar.ParkProcRearSnsDtdNearestDis;
        RRSnsDtDis  = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.RObjDis;
        RRSSnsDtDis = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.RSObjDis;

        if ((RRSnsDtDis > 700) && (RRSSnsDtDis > 600)) {
          // Out of detect tol, obj2 is invalid.
          // reset obj2.
          Dis1 = (APA_DISTANCE_TYPE)SlotObj2Y;
          if (Dis1 < APASlotCorrectionOriginalObj2Y) {
            // reset to the original obj1y.
            ObjPt1Y   = APASlotCorrectionOriginalObj2Y;
            SlotLen   = ObjPt1Y - SlotObj1Y;
            Dis1      = APACal.APASlotPMinSmallSlotLen - SlotLen;
            CalResult = 0;
            if (Dis1 > APA_SLOT_PER_OBJ1Y_CORRECT_TOL_DIS) {
              // ?? Data error
              // ?? Actually code should never reach.
              // If yes. it may be the Obj2.y compensate to much.
              // Just ignore the current correction and return.
              CalResult = 1;
            } else if (Dis1 > 0) {
              SlotLen = APACal.APASlotPMinSmallSlotLen;
              // The Obj1.y and Obj2.y will be compensated with Dis1 / 2.
              USSPar.TrajCalObj1Pos.y -= Dis1;
              //} else if(SlotLen > APACal.APASlotPMaxSlotLength) {
              // ?? Data error or the car has just run over the Obj1 and Obj1 has moved away.
              // Just treat as the bigest slot length.
              //	SlotLen = APACal.APASlotPMaxSlotLength;
              //	ObjPt1Y = USSPar.TrajCalObj2Pos.y - SlotLen;
            } else {
              // The slot length is still within the min small slot len range.
              // OK.
            }
            // adjust the car end pos.y
            if (CalResult == 0) {
              // Recorrect the slot length.
#ifdef Mike_Yi_Debug
              cCorrectPoint = 5;
#endif
              USSPar.TrajCalObj2Pos.y = ObjPt1Y;

              bCarHitRObj = FALSE;
              APASlotProcCorrectSlotPReCalculateTheSlotEndPosY(SlotLen, 1);
            } else {
              // It is an error.
              // Can not be corrected.
              // just remain the previous value.
            }
          }
        }
      }
    }

    // APACarInSlotCarMayHitObj1Or2Flag.Bits.CarInSlotFrontBumperHitObj1Or2 = bCarHitFObj;
    APACarInSlotCarMayHitObj1Or2Flag.Bits.CarInSlotRearBumperHitObj1Or2     = bCarHitRObj;
    APACarInSlotCarMayHitObj1Or2Flag.Bits.CarInSlotRearBumperCloseToObj1Or2 = bCarCloseToRObj;
  }

#ifdef APA_SLOT_PROC_DEBUG_IN_SLOT_BORDER_LINE_PAR
  if (bCarEndPosChanged == TRUE) {
    if (APASlotCorrectionCaledCarEndPosIndex < APA_SLOT_PROC_SLOT_CORRECTION_CALED_CAR_END_POS_NUM) {
      APASlotCorrectionCaledCarEndPos[APASlotCorrectionCaledCarEndPosIndex] = USSPar.TrajCalCarEndPos;
      APASlotCorrectionCaledObj1Pt[APASlotCorrectionCaledCarEndPosIndex]    = USSPar.TrajCalObj1Pos;
      APASlotCorrectionCaledObj2Pt[APASlotCorrectionCaledCarEndPosIndex]    = USSPar.TrajCalObj2Pos;
      APASlotCorrectionCaledCarEndPosIndex++;
    }
  }
  if (bCarEndPosLineChanged == TRUE) {
    if (APASlotCorrectionCaledCarEndPosLineIndex < APA_SLOT_PROC_SLOT_CORRECTION_CALED_CAR_END_POS_NUM) {
      APASlotCorrectionCaledCarEndPosLine[APASlotCorrectionCaledCarEndPosLineIndex] = USSPar.TrajCalCarEndPosLine;
      APASlotCorrectionCaledCarEndPosIndex++;
    }
  }
#endif

//  APASlotParkProcReqSlotBorderLineCorrectSeq++;

#endif
}
#endif
/*************************************************************************************************************************************************
 ** Syntax :  void APASlotProcResetSystemCoordinate(void) **
 **                                                                                                                                              **
 ** Service ID:   : NO.3                                                                                                                           **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

void APASlotProcResetSystemCoordinate(void) {
  //, BOOLEAN bResetSubSlotBuf){
  // Take the center of the rear axis of the car as the original 'O' coordinate.
  // bResetSubSlotBuf == 0: with not reset the slot data.

  APA_INDEX_TYPE i, j, ObjCnt, SnsIndex;
  APACoordinateDataCalFloatType CenterPt, DstPt, CarCoor;
  APA_ANGLE_TYPE CarAng, NewCarAng;
  APACoordinateDataType nPtTemp, nCarCoor;

  APA_DISTANCE_TYPE CarCenterPtDefY;
  APA_DISTANCE_CAL_FLOAT_TYPE fCarCenterPtDefY;

  BOOLEAN bSDGAPASlotDataIsMirrorChange;

#ifdef SUPPORT_APA_SNS_DATA_TEST
  return; // just for debug
#endif

  DstPt.x = USSPar.APACarCenterPt.Coordinate.x;
  DstPt.y = USSPar.APACarCenterPt.Coordinate.y;
  CarAng  = -USSPar.APACarCenterPt.CarAng;

  CenterPt.x = 0;
  CenterPt.y = 0;
  DstPt      = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
  CenterPt.x = -DstPt.x;
  CenterPt.y = -DstPt.y;

  // for (i = 0; i < USSPar.APA_VISION_SLOT.slot_num; i++)
  //{
  //	for (j = 0; j < 4; j++)
  //	{
  //		APACoordinateDataCalFloatType DstPt;
  //		DstPt.x = USSPar.APA_VISION_SLOT.M_Vision_Slot[i].m_slot_point[j][0];
  //		DstPt.y = USSPar.APA_VISION_SLOT.M_Vision_Slot[i].m_slot_point[j][1];
  //		DstPt = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
  //		USSPar.APA_VISION_SLOT.M_Vision_Slot[i].m_slot_point[j][0] = DstPt.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
  //		USSPar.APA_VISION_SLOT.M_Vision_Slot[i].m_slot_point[j][1] = DstPt.y +
  //(APA_DISTANCE_CAL_FLOAT_TYPE)APACal.APASlotCarCenterPtDefaultY;
  //	}
  //}
  //	memset(&USSPar.APA_VISION_SLOT, 0, sizeof(USSPar.APA_VISION_SLOT));  //ethan

  // LIU.PAN vision_slot 2018/9/05
//  for (i = 0; i < USSPar.H_APA_CARPOSISION_ForVision.num; i++) {
//    APACoordinateDataCalFloatType DstPt;
//    DstPt.x = USSPar.H_APA_CARPOSISION_ForVision.carpose[i].H_APACarCenterPt.Coordinate.x;
//    DstPt.y = USSPar.H_APA_CARPOSISION_ForVision.carpose[i].H_APACarCenterPt.Coordinate.y;
//    DstPt   = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
//    USSPar.H_APA_CARPOSISION_ForVision.carpose[i].H_APACarCenterPt.CarAng += CarAng;
//    USSPar.H_APA_CARPOSISION_ForVision.carpose[i].H_APACarCenterPt.Coordinate.x = DstPt.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
//    USSPar.H_APA_CARPOSISION_ForVision.carpose[i].H_APACarCenterPt.Coordinate.y =
//        DstPt.y + (APA_DISTANCE_CAL_FLOAT_TYPE)APACal.APASlotCarCenterPtDefaultY;
//  }

  bSDGAPASlotDataIsMirrorChange = USSPar.APACommonFlags.Bits.bSlotDataIsMirrorChanged; // ??????????????????? kjy 2012 08 23, do we need it ??

  CarCenterPtDefY  = APACal.APASlotCarCenterPtDefaultY;
  fCarCenterPtDefY = (APA_DISTANCE_CAL_FLOAT_TYPE)CarCenterPtDefY;

  USSPar.APACarCenterPt.CarAng       = 0;
  USSPar.APACarCenterPt.Coordinate.x = APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
  USSPar.APACarCenterPt.Coordinate.y = fCarCenterPtDefY;
  // USSPar.CarAngCosValue = 1;
  // USSPar.CarAngSinValue = 0;
  // USSPar.CarAngTanValue = 0;
  // USSPar.APACurrentCarAngState = 1;

  for (i = USSPar.APASnsDtdObjDisInfoBufReadIndex; i < USSPar.APASnsDtdObjDisInfoBufWriteIndex; i++) {
    /* There is sns dtd dis need to be processed */
    DstPt.x = USSPar.APASnsDtdObjDisInfoBuf[i].CarCenterPt.Coordinate.x;
    DstPt.y = USSPar.APASnsDtdObjDisInfoBuf[i].CarCenterPt.Coordinate.y;
    DstPt   = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
    USSPar.APASnsDtdObjDisInfoBuf[i].CarCenterPt.CarAng += CarAng;
    USSPar.APASnsDtdObjDisInfoBuf[i].CarCenterPt.Coordinate.x = DstPt.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
    USSPar.APASnsDtdObjDisInfoBuf[i].CarCenterPt.Coordinate.y = DstPt.y + fCarCenterPtDefY;
    // No need to change the value of CarSpeed
  }

  DstPt.x = USSPar.APACarCenterPtCaledByWheelCnt.Coordinate.x;
  DstPt.y = USSPar.APACarCenterPtCaledByWheelCnt.Coordinate.y;
  DstPt   = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
  USSPar.APACarCenterPtCaledByWheelCnt.CarAng += CarAng;
  USSPar.APACarCenterPtCaledByWheelCnt.Coordinate.x = DstPt.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
  USSPar.APACarCenterPtCaledByWheelCnt.Coordinate.y = DstPt.y + fCarCenterPtDefY;

  for (j = 0; j < APA_SIDE_SENSOR_NUM; j++) {
    for (i = 0; i < APASnsDtdObjPtBuf[j].WrIndex; i++) {

      DstPt.x = APASnsDtdObjPtBuf[j].ObjPtBuf[i].CarPos.Coordinate.x;
      DstPt.y = APASnsDtdObjPtBuf[j].ObjPtBuf[i].CarPos.Coordinate.y;
      DstPt   = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);

      APASnsDtdObjPtBuf[j].ObjPtBuf[i].CarPos.Coordinate.x = DstPt.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
      APASnsDtdObjPtBuf[j].ObjPtBuf[i].CarPos.Coordinate.y = ((APA_DISTANCE_TYPE)(DstPt.y)) + CarCenterPtDefY;
      APASnsDtdObjPtBuf[j].ObjPtBuf[i].CarPos.CarAng       = APASnsDtdObjPtBuf[j].ObjPtBuf[i].CarPos.CarAng + CarAng;
      // No need to change the value of CarSpeed
    }
  }

  for (j = 0; j < APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM; j++) {
    for (i = 0; i < USSPar.Slot[j].SlotOutline.Lane.ObjPtCnt; i++) {
      DstPt.x = USSPar.Slot[j].SlotOutline.Lane.CarCenterPoint[i].x;
      DstPt.y = USSPar.Slot[j].SlotOutline.Lane.CarCenterPoint[i].y;

      DstPt = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);

      USSPar.Slot[j].SlotOutline.Lane.CarCenterPoint[i].x = DstPt.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
      USSPar.Slot[j].SlotOutline.Lane.CarCenterPoint[i].y = ((APA_DISTANCE_TYPE)(DstPt.y)) + CarCenterPtDefY;
      USSPar.Slot[j].SlotOutline.Lane.CarAng[i]           = USSPar.Slot[j].SlotOutline.Lane.CarAng[i] + CarAng;
      // No need to change the value of CarSpeed
      // USSPar.Slot[j].SlotOutline.Lane.CarSpeed[i]         = USSPar.Slot[j].SlotOutline.Lane.CarSpeed[i];

      DstPt.x = USSPar.Slot[j].SlotOutline.Lane.ObjPt[i].x;
      DstPt.y = USSPar.Slot[j].SlotOutline.Lane.ObjPt[i].y;

      DstPt                                         = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
      USSPar.Slot[j].SlotOutline.Lane.ObjPt[i].x = DstPt.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
      USSPar.Slot[j].SlotOutline.Lane.ObjPt[i].y = ((APA_DISTANCE_TYPE)(DstPt.y)) + CarCenterPtDefY;
    }

    for (i = 0; i < USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtCntRSns; i++) {
      DstPt.x = USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarCenterPointRSns[i].x;
      DstPt.y = USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarCenterPointRSns[i].y;

      DstPt = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);

      USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarCenterPointRSns[i].x =
          DstPt.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
      USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarCenterPointRSns[i].y =
          ((APA_DISTANCE_TYPE)(DstPt.y)) + CarCenterPtDefY;
      USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarAngRSns[i] =
          USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarAngRSns[i] + CarAng;

      DstPt.x = USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtRSns[i].x;
      DstPt.y = USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtRSns[i].y;

      DstPt = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
      USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtRSns[i].x =
          DstPt.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
      USSPar.Slot[j].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtRSns[i].y = ((APA_DISTANCE_TYPE)(DstPt.y)) + CarCenterPtDefY;
    }
  }
#ifdef SUPPORT_SDG_FUNCTION
  // transfer SDG Object Pt Coordinate.
  if (SDGState == SDG_OPERATION_MODE) {
    if (bSDGAPASlotDataIsMirrorChange == TRUE) { // dsh 20120227 sdg DONOT MIRROR CHANGE
      CenterPt.x = -CenterPt.x;
      CenterPt.y = CenterPt.y;
      CarAng     = -CarAng;
    }
    for (SnsIndex = 0; SnsIndex < SDG_SUPPORT_SDG_SNS_NUM; SnsIndex++) {
      ObjCnt = SDGSnsDtdObjPtBuf[SnsIndex].WrIndex;
      for (i = 0; i < ObjCnt; i++) {
        DstPt.x                                      = SDGSnsDtdObjPtBuf[SnsIndex].ObjPtBuf[i].Pt.x;
        DstPt.y                                      = SDGSnsDtdObjPtBuf[SnsIndex].ObjPtBuf[i].Pt.y;
        DstPt                                        = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
        nPtTemp.x                                    = (sint16)(DstPt.x);
        nPtTemp.y                                    = (sint16)(DstPt.y);
        SDGSnsDtdObjPtBuf[SnsIndex].ObjPtBuf[i].Pt.x = nPtTemp.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
        SDGSnsDtdObjPtBuf[SnsIndex].ObjPtBuf[i].Pt.y = nPtTemp.y + CarCenterPtDefY;

        DstPt.x                                                     = SDGSnsDtdObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.Coordinate.x;
        DstPt.y                                                     = SDGSnsDtdObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.Coordinate.y;
        DstPt                                                       = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
        nPtTemp.x                                                   = (sint16)(DstPt.x);
        nPtTemp.y                                                   = (sint16)(DstPt.y);
        SDGSnsDtdObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.Coordinate.x = nPtTemp.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
        SDGSnsDtdObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.Coordinate.y = nPtTemp.y + CarCenterPtDefY;
        SDGSnsDtdObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.CarAng += CarAng;
      }
      ObjCnt = SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtCnt;
      for (i = 0; i < ObjCnt; i++) {
        /* There is sns dtd dis need to be processed */
        DstPt.x   = SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].Pt.x;
        DstPt.y   = SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].Pt.y;
        DstPt     = APATrajCalPointPosWithAngAndCenterPt(DstPt, CarAng, CenterPt);
        nPtTemp.x = (sint16)(DstPt.x);
        nPtTemp.y = (sint16)(DstPt.y);

        CarCoor.x  = SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.Coordinate.x;
        CarCoor.y  = SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.Coordinate.y;
        CarCoor    = APATrajCalPointPosWithAngAndCenterPt(CarCoor, CarAng, CenterPt);
        nCarCoor.x = (sint16)(CarCoor.x);
        nCarCoor.y = (sint16)(CarCoor.y);
        NewCarAng  = SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.CarAng + CarAng;

        // Check if the NewCarAng will overfollow?? - PI ~ PI.
        if (NewCarAng > PI) {
          NewCarAng -= 2 * PI;
        } else if (NewCarAng < -PI) {
          NewCarAng += 2 * PI;
        }

        SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].Pt.x                = nPtTemp.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
        SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].Pt.y                = nPtTemp.y + CarCenterPtDefY;
        SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.Coordinate.x = nCarCoor.x + APA_SLOT_CAR_CENTER_POINT_X_DEFAUT_VALUE;
        SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.Coordinate.y = nCarCoor.y + CarCenterPtDefY;
        SDGObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[i].CarPos.CarAng       = NewCarAng;
      }
    }
  }
#endif
}


/*************************************************************************************************************************************************
 ** Syntax :  void USS(void)                                                                                                                     **
 **                                                                                                                                              **
 ** Service ID:   : NA                                                                                                                           **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

APA_SLOT_PT_SLOPE_TYPE
APASlotProcCalTwoObjPtSlope(APACoordinateDataType Pt1, APACoordinateDataType Pt2, APA_DISTANCE_TYPE ObjDis1, APA_DISTANCE_TYPE ObjDis2) {

  /*

   *
   *   | Pt1
   |
   Pt2.

   */

  // If slope < 0: rising shape: Dis1 < Dis2
  // if slope > 0: falling shape: Dis1 > Dis2
  APA_DISTANCE_TYPE ObjWidth, ObjDeltaDis;

  ObjWidth = APASlotProcCalTwoPtApproximateDisInt(Pt1, Pt2);

  if (ObjWidth < APA_SLOT_OBJ_PT_CHECK_CAL_SLOPE_ALLOW_MIN_PT_TO_PT_DIS) {
    // very mall dis
    return APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT;
  } else if (ObjWidth > APA_SLOT_OBJ_PT_CHECK_CAL_SLOPE_ALLOW_MAX_PT_TO_PT_DIS) {
    // very big width ?? data error ??
    return APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_LONG;
  } else {
    ObjDeltaDis = ObjDis1 - ObjDis2;
    ObjDeltaDis = ObjDeltaDis * APA_SLOT_OBJ_PT_SLOPE_ZOOM_TIMES / ObjWidth;
    if (ObjDeltaDis > APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE) {
      return APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;
    } else if (ObjDeltaDis < APA_SLOT_OBJ_PT_SLOPE_MIN_VALUE) {
      return APA_SLOT_OBJ_PT_SLOPE_MIN_VALUE;
    } else {
      return (APA_SLOT_PT_SLOPE_TYPE)ObjDeltaDis;
    }
  }
}

/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcCheckObjPtInFilterBufObjProfile(
 APASlotSnsDtdObjPtBufType *pAPASnsDtdObjPtBuf,
 APA_INDEX_TYPE CurPtIndex, APA_ENUM_TYPE TotalPtNum,
 APA_INDEX_TYPE VehSpdIndex, APA_ENUM_TYPE CheckMode) **
 **                                                                                                                                              **
 ** Service ID:   : NO.4-1 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
BOOLEAN APASlotProcCheckObjPtInFilterBufObjProfile(APASlotSnsDtdObjPtBufType *pAPASnsDtdObjPtBuf,
                                                   APA_INDEX_TYPE CurPtIndex,
                                                   APA_ENUM_TYPE TotalPtNum,
                                                   APA_INDEX_TYPE VehSpdIndex,
                                                   APA_ENUM_TYPE CheckMode) {
  // Check mode: 0: rising edge.
  //             1: falling edge.
  //             2: flat shape big obj
  //             3: flat shape small obj
  //			   4: Curb shape check
  //
  // return: bObjProfileConfirmed
  //         TRUE
  //         FALSE

  APA_DISTANCE_TYPE Dis1, Dis2, PrevDis, Dis3, Dis4, PrevSmallObjDisWithCurb;
  BOOLEAN bBigObjDisIsValid, bFlatPtAtStart, bCheckCurPtSmallObjIsMoreReasonable;
  APA_ENUM_TYPE ObjPtCnt, ObjIndex, ObjIndex2, ObjIndex3, ObjIndex4, ObjIndex5, SecondObjIndex;
  APA_DISTANCE_TYPE FirstPtDis;
  APA_SLOT_PT_SLOPE_TYPE SnsDtdObjDisPtSlopeBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE];
  APA_SLOT_PT_SLOPE_TYPE SnsDtdSmallObjDisWithCurbPtSlopeBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE];
  APA_INDEX_TYPE SnsDtdBigObjDisIndexBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE];
  APA_INDEX_TYPE SnsDtdSmallObjDisIndexBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE];
  APA_ENUM_TYPE NoObjDisIndex1, ConsecutiveNoObjDisPtNum, PrevObjIndex, BigObjPtNum, BigObjPtIndex, SmallObjPtIndex;
  APA_SLOT_PT_SLOPE_CAL_TYPE PtSlope1, PtSlope2, TolSlope, PtSlope3, PtSlope4, PtSlope5;
  APA_ENUM_TYPE NoObjDisDtdCnt;
  APA_ENUM_TYPE CheckCnt, WithinTolCheckResult;
  BOOLEAN bCheckCurbFlag, bBigObjDisIsValidBk;
  APA_DISTANCE_TYPE CurSmallObjDis;

  PrevDis                 = pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].BigObjDis;
  PrevSmallObjDisWithCurb = pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].SmallObjDis;
  // APASlotSnsDtdObjDisFilterFillRisingEdgeMinObjDis 1.2
  // APASlotSnsDtdObjDisFilterFillRisingEdgeMinObjDis  3.5
  // APASlotSnsDtdObjDisFilterFillFallingEdgeMinObjDis 0.5
  // APASlotSnsDtdObjDisFilterFillFallingEdgeMinObjDis 3.5
  // APASlotSnsDtdObjDisFilterFillFlatCurbMinObjDis  2.5
  // APASlotSnsDtdObjDisFilterFillFlatCurbMaxObjDis  5.0
  if (((CheckMode == 2) || (CheckMode == 3)) ||
      ((CheckMode == 0) && (PrevDis > APACal.APASlotSnsDtdObjDisFilterFillRisingEdgeMinObjDis) &&
       (PrevDis < APACal.APASlotSnsDtdObjDisFilterFillRisingEdgeMaxObjDis)) ||
      ((CheckMode == 1) && (PrevDis > APACal.APASlotSnsDtdObjDisFilterFillFallingEdgeMinObjDis) &&
       (PrevDis < APACal.APASlotSnsDtdObjDisFilterFillFallingEdgeMaxObjDis)) ||
      ((CheckMode == 4) &&
       ((PrevDis > APACal.APASlotSnsDtdObjDisFilterFillFlatCurbMinObjDis)                                             // 2500
        && (PrevDis < APACal.APASlotSnsDtdObjDisFilterFillFlatCurbMaxObjDis))                                         // 5000
       && ((PrevSmallObjDisWithCurb > APACal.APASlotSnsDtdObjDisFilterFillRisingOrFallingEdgeWithCurbMinObjDis)       // 1200
           && (PrevSmallObjDisWithCurb < APACal.APASlotSnsDtdObjDisFilterFillRisingOrFallingEdgeWithCurbMaxObjDis)))) // 2200
  {
    // Falling shape
    /*

     * *                  **
     *            *                **********
     *       *

     */
    for (CheckCnt = 0; CheckCnt < 2; CheckCnt++) {
      ObjPtCnt                 = TotalPtNum;
      NoObjDisIndex1           = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
      ConsecutiveNoObjDisPtNum = 0; // Consecutive points num
      PrevDis                  = pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].BigObjDis;
      PrevSmallObjDisWithCurb  = pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].SmallObjDis;
      PrevObjIndex             = CurPtIndex;
      ObjIndex2                = 0; // Total valid obj dis points.
      SmallObjPtIndex          = 0;
      BigObjPtIndex            = 0;
      BigObjPtNum              = 1; // include the first big point.
      TolSlope                 = (APA_SLOT_PT_SLOPE_CAL_TYPE)APACal.APASlotSnsDtdObjDisFilterFillFlatProfileMaxDeltaSlope[VehSpdIndex];
      // APASlotSnsDtdObjDisFilterFillFlatProfileMaxDeltaSlope  17 15 11 8 5
      if (CheckMode == 1) {
        // Falling edge.
        ObjIndex = CurPtIndex + 1;
      } else {
        ObjIndex = CurPtIndex - 1;
        if (CheckMode == 2) {
          // Flat big obj.
          if (PrevDis == NO_OBJ_DISTANCE) {
            return FALSE;
          } else if (PrevDis < 0) {
            // small obj
            BigObjPtNum = 0;
            PrevDis     = -PrevDis;
          }
        } else if (CheckMode == 3) {
          // Flat small obj
          PrevDis = pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].SmallObjDis;
          if (PrevDis == NO_OBJ_DISTANCE) {
            return FALSE;
          }
          BigObjPtNum = 0;
        }
      }
      bFlatPtAtStart = FALSE; // Indicate that there is no flat point at head.
      ObjIndex4      = (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1 - TotalPtNum / 2);
      NoObjDisDtdCnt = 0;
      FirstPtDis     = PrevDis;
      SecondObjIndex = ObjIndex;
      while (ObjPtCnt > 1) {
        ObjPtCnt--;
        bBigObjDisIsValid = FALSE; // Indicate the big obj dis is invalid.
        bCheckCurbFlag    = FALSE; // Indicate it will not check curb
        if (((ObjIndex != SecondObjIndex) || (CheckCnt == 0)) && ((pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjPtStatus.Bits.bIsNoise == FALSE) &&
                                                                  (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis != NO_OBJ_DISTANCE))) {
          Dis2 = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis;
          if (Dis2 < 0) {
            Dis1 = -Dis2;
          } else {
            Dis1 = Dis2;
          }
          bCheckCurPtSmallObjIsMoreReasonable = FALSE;
          WithinTolCheckResult                = 0;
          if (CheckMode > 1) {
            // check flat shape.
            Dis3 = MATH_ABS(PrevDis - Dis1);
            // APASlotSnsDtdObjDisFilterFillFlatProfilePointsMaxDeltaDis1  15cm
            // APASlotSnsDtdObjDisFilterFillFlatProfilePointsMaxDeltaDis2  30cm
            if (Dis3 < APACal.APASlotSnsDtdObjDisFilterFillFlatProfilePointsMaxDeltaDis1) {
              WithinTolCheckResult = 2;
              bBigObjDisIsValid    = TRUE;
            } else if (Dis3 < APACal.APASlotSnsDtdObjDisFilterFillFlatProfilePointsMaxDeltaDis2) {
              WithinTolCheckResult = 1;
            }
            // APASlotSnsDtdObjDisFilterFillFlatCurbMinObjDis 2.5
            if ((Dis2 > APACal.APASlotSnsDtdObjDisFilterFillFlatCurbMinObjDis) && (CheckMode == 4)) {
              bCheckCurbFlag = TRUE;
            }
          } else {
            // check rising or falling edge.
            // APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeFirstTwoPtMaxObjDeltaDis 8 17 17 18 20
            if ((PrevDis < (Dis1 + APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeFirstTwoPtMaxObjDeltaDis[VehSpdIndex]))) {
              if (CheckMode == 0) {
                // rising edge.
                if (ObjIndex >= ObjIndex4) {
                  bFlatPtAtStart       = TRUE;
                  WithinTolCheckResult = 1;
                }
              } else {
                if (ObjIndex <= ObjIndex4) {
                  bFlatPtAtStart       = TRUE;
                  WithinTolCheckResult = 1;
                }
              }
            }
            if (PrevDis < Dis1) {
              WithinTolCheckResult = 1;
            }
          }
          if (WithinTolCheckResult > 0) {
            PtSlope1 = (APA_SLOT_PT_SLOPE_CAL_TYPE)APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[PrevObjIndex].CarPos.Coordinate,
                                                                               pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate,
                                                                               PrevDis,
                                                                               Dis1);
            if (PtSlope1 > APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE) {
              // data error ??
              return FALSE;
            }
            if (WithinTolCheckResult == 1) {
              if (CheckMode > 1) {
                // Flat obj or curb
                if ((PtSlope1 > (APA_SLOT_PT_SLOPE_CAL_TYPE)(-APACal.APASlotSnsDtdObjDisFilterFillFlatProfileMaxSlope)) &&
                    (PtSlope1 < (APA_SLOT_PT_SLOPE_CAL_TYPE)(APACal.APASlotSnsDtdObjDisFilterFillFlatProfileMaxSlope))) {
                  if (ObjIndex2 > 0) {
                    // check the slope.
                    ObjIndex3         = ObjIndex2;
                    bBigObjDisIsValid = TRUE;
                    ObjIndex5         = 0;
                    while (ObjIndex3 > 0) {
                      ObjIndex3--;
                      PtSlope2 = PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[ObjIndex3];
                      if ((PtSlope2 <= (-TolSlope)) || (PtSlope2 >= TolSlope)) {
                        // OK, keep falling shape.
                        bBigObjDisIsValid = FALSE;
                        break;
                      }
                      ObjIndex5++;
                      if (ObjIndex5 > 3) {
                        // total 4 times.
                        break;
                      }
                    }
#if 1
                    if ((bBigObjDisIsValid == TRUE) && ((pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjPtStatus.Bits.bIsNoise == FALSE) &&
                                                        (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjDis != NO_OBJ_DISTANCE))) {
                      CurSmallObjDis = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjDis;
                      PtSlope3       = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[PrevObjIndex].CarPos.Coordinate,
                                                             pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate,
                                                             PrevDis,
                                                             CurSmallObjDis);
                      if (PtSlope3 > APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE) {
                        // data error ??
                        // Just use big obj.
                      } else {
                        if ((PtSlope3 > (APA_SLOT_PT_SLOPE_CAL_TYPE)(-APACal.APASlotSnsDtdObjDisFilterFillFlatProfileMaxSlope)) &&
                            (PtSlope3 < (APA_SLOT_PT_SLOPE_CAL_TYPE)(APACal.APASlotSnsDtdObjDisFilterFillFlatProfileMaxSlope))) {
                          PtSlope2 = MATH_ABS(PtSlope1 - SnsDtdObjDisPtSlopeBuf[ObjIndex2 - 1]);
                          PtSlope4 = MATH_ABS(PtSlope3 - SnsDtdObjDisPtSlopeBuf[ObjIndex2 - 1]);
                          if (PtSlope4 > PtSlope2) {
                            // Just use the big object point.
                          } else {
                            PtSlope1                                           = PtSlope3;
                            pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjDis = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis;
                            pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis   = CurSmallObjDis;
                          }
                        }
                      }
                    }
#endif
                  } else {
                    bBigObjDisIsValid                   = TRUE;
                    bCheckCurPtSmallObjIsMoreReasonable = TRUE;
                  }
                }
              } else {
                // rising or falling.
                if (PtSlope1 > (APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeMaxSlope)) {
                  if (ObjIndex2 > 0) {
                    // check the slope.
                    PtSlope2 = PtSlope1 - SnsDtdObjDisPtSlopeBuf[ObjIndex2 - 1];
                    if (PtSlope2 <= 0) {
                      // OK, keep rising shape.
                      bBigObjDisIsValid = TRUE;
#if 1
                      if ((pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjPtStatus.Bits.bIsNoise == FALSE) &&
                          (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjDis != NO_OBJ_DISTANCE)) {
                        CurSmallObjDis = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjDis;
                        Dis3           = (CurSmallObjDis - PrevDis); // > 0
                        Dis4           = (Dis1 - PrevDis);
                        if ((Dis3 < Dis4) && (Dis3 > 0)) {
                          // Small Obj is more close to prev dis.
                          PtSlope3 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[PrevObjIndex].CarPos.Coordinate,
                                                                 pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate,
                                                                 PrevDis,
                                                                 CurSmallObjDis);
                          if (PtSlope3 > APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE) {
                            // data error ??
                            // return FALSE;
                          } else {
                            if (PtSlope3 > PtSlope1) {
                              PtSlope2 = MATH_ABS(PtSlope1 - SnsDtdObjDisPtSlopeBuf[ObjIndex2 - 1]);
                              PtSlope4 = MATH_ABS(PtSlope3 - SnsDtdObjDisPtSlopeBuf[ObjIndex2 - 1]);
                              if (PtSlope4 > PtSlope2) {
                                // Just use the big object point.
                              } else {
                                PtSlope1                                           = PtSlope3;
                                pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjDis = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis;
                                pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis   = CurSmallObjDis;
                              }
                            }
                          }
                        } else {
                          // Just use the big object point.
                        }
                      }
#endif
                    } else {
                      if ((TotalPtNum - ObjPtCnt) < APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeAllowedMaxFlatPtNumAtHead[VehSpdIndex]) {
                        // OK, flat point num is within range.
                        if (PtSlope2 <= APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeAllowedMaxFlatSlope) {
                          // OK, within tol
                          bBigObjDisIsValid = TRUE;
                        }
                      }
                    }
                  } else {
                    bBigObjDisIsValid                   = TRUE;
                    bCheckCurPtSmallObjIsMoreReasonable = TRUE;
                  }
                }
              }
            }
            if (bBigObjDisIsValid == TRUE) {
#if 1
              if ((bCheckCurPtSmallObjIsMoreReasonable == TRUE) &&
                  (pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].SmallObjPtStatus.Bits.bIsNoise == FALSE) &&
                  (pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].SmallObjDis != NO_OBJ_DISTANCE)) {
                CurSmallObjDis = pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].SmallObjDis;
                Dis4           = MATH_ABS(CurSmallObjDis - Dis1);
                Dis3           = MATH_ABS(PrevDis - Dis1);
                if (Dis4 < Dis3) {
                  // Use small dis as the CurPtIndex big obj pt to cal.
                  PtSlope3 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[PrevObjIndex].CarPos.Coordinate,
                                                         pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate,
                                                         CurSmallObjDis,
                                                         Dis1);
                  if (PtSlope3 > APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE) {
                    // data error ??
                    // return FALSE;
                  } else {
                    PtSlope1 = PtSlope3;
                  }
                }
              }
#endif
              SnsDtdObjDisPtSlopeBuf[ObjIndex2] = PtSlope1;
              PrevDis                           = Dis1;
              ObjIndex2++;
              if (Dis2 > 0) {
                BigObjPtNum++;
              }
              SnsDtdBigObjDisIndexBuf[BigObjPtIndex] = ObjIndex;
              BigObjPtIndex++;
            }
          } else {
            // rising shape.
            // Invalide data.
          }
        }

        if (((bBigObjDisIsValid == FALSE) || (bCheckCurbFlag == TRUE)) &&
            ((pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjPtStatus.Bits.bIsNoise == FALSE) &&
             (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjDis != NO_OBJ_DISTANCE))) {
          Dis1 = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjDis;
          Dis2 = PrevDis; // Save the PrevDis to Dis2 temperally.
          if (CheckMode == 4) {
            PrevDis = PrevSmallObjDisWithCurb;
            Dis3    = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis;
            if ((bBigObjDisIsValid == FALSE) && (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjPtStatus.Bits.bIsNoise == FALSE) &&
                (Dis3 != NO_OBJ_DISTANCE) && (Dis3 < 0) && (PrevSmallObjDisWithCurb < -Dis3) &&
                ((Dis1 + Dis3) > APACal.APASlotMinDeltaDisBetweenCurbAndProfileobjToCheckIfProfileWithCurb)) // 1000
            {
              Dis1 = -Dis3;
            }
          }
          bBigObjDisIsValidBk  = bBigObjDisIsValid;
          WithinTolCheckResult = 0;
          if ((CheckMode == 2) || (CheckMode == 3)) {
            // check flat shape.
            Dis3 = MATH_ABS(PrevDis - Dis1);
            if (Dis3 < APACal.APASlotSnsDtdObjDisFilterFillFlatProfilePointsMaxDeltaDis1) {
              WithinTolCheckResult = 2;
              bBigObjDisIsValid    = TRUE;
            } else if (Dis3 < APACal.APASlotSnsDtdObjDisFilterFillFlatProfilePointsMaxDeltaDis2) {
              WithinTolCheckResult = 1;
            }
          } else {
            // check rising or falling edge.
            if (CheckMode == 4) {
              if ((Dis2 - Dis1) > APACal.APASlotMinDeltaDisBetweenCurbAndProfileobjToCheckIfProfileWithCurb) {
                if (PrevDis < Dis1) {
                  WithinTolCheckResult = 1;
                }
              }
            } else {
              if (PrevDis < Dis1) {
                WithinTolCheckResult = 1;
              }
            }
          }
          if (WithinTolCheckResult > 0) {
            PtSlope1 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[PrevObjIndex].CarPos.Coordinate,
                                                   pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate,
                                                   PrevDis,
                                                   Dis1);
            if (PtSlope1 > APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE) {
              // data error ??
              return FALSE;
            }
            if (WithinTolCheckResult == 1) {
              // Rising shape.
              if ((CheckMode == 2) || (CheckMode == 3)) {
                // Flat obj
                if ((PtSlope1 > (-APACal.APASlotSnsDtdObjDisFilterFillFlatProfileMaxSlope)) &&
                    (PtSlope1 < (APACal.APASlotSnsDtdObjDisFilterFillFlatProfileMaxSlope))) {
                  if (ObjIndex2 > 0) {
                    // check the slope.
                    ObjIndex3         = ObjIndex2;
                    bBigObjDisIsValid = TRUE;
                    ObjIndex5         = 0;
                    while (ObjIndex3 > 0) {
                      ObjIndex3--;
                      PtSlope2 = PtSlope1 - SnsDtdObjDisPtSlopeBuf[ObjIndex3];
                      if ((PtSlope2 <= (-TolSlope)) || (PtSlope2 >= TolSlope)) {
                        // OK, keep falling shape.
                        bBigObjDisIsValid = FALSE;
                        break;
                      }
                      ObjIndex5++;
                      if (ObjIndex5 > 3) {
                        // total 4 times.
                        break;
                      }
                    }
                  } else {
                    bBigObjDisIsValid = TRUE;
                  }
                }
              } else {
                // rising or falling.
                if (PtSlope1 > (APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeMaxSlope)) {
                  // Notes: PtSlope1 will be less than zero.
                  if (CheckMode == 4) {
                    ObjIndex3 = SmallObjPtIndex;
                  } else {
                    ObjIndex3 = ObjIndex2;
                  }
                  if (ObjIndex3 > 0) {
                    // check the slope.
                    if (CheckMode == 4) {
                      PtSlope2 = PtSlope1 - SnsDtdSmallObjDisWithCurbPtSlopeBuf[ObjIndex3 - 1];
                    } else {
                      PtSlope2 = PtSlope1 - SnsDtdObjDisPtSlopeBuf[ObjIndex3 - 1];
                    }
                    if ((PtSlope2 <= APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeAllowedMaxDeltaSlope) && (PtSlope1 < 0)) {
                      // OK, keep falling shape.
                      bBigObjDisIsValid = TRUE;
                    }
                  } else {
                    bBigObjDisIsValid = TRUE;
                  }
                }
              }
            }
            if (bBigObjDisIsValid == TRUE) {
              if (CheckMode == 4) {
                PrevSmallObjDisWithCurb                              = Dis1;
                SnsDtdSmallObjDisWithCurbPtSlopeBuf[SmallObjPtIndex] = PtSlope1;
                SnsDtdSmallObjDisIndexBuf[SmallObjPtIndex]           = ObjIndex;
                SmallObjPtIndex++;
                bBigObjDisIsValid = bBigObjDisIsValidBk;
              } else {
                PrevDis                           = Dis1;
                SnsDtdObjDisPtSlopeBuf[ObjIndex2] = PtSlope1;
                ObjIndex2++;
                SnsDtdSmallObjDisIndexBuf[SmallObjPtIndex] = ObjIndex;
                SmallObjPtIndex++;
              }
            }
          } else {
            // Invalide data.
          }
          if (CheckMode == 4) {
            PrevDis = Dis2;
          }
        }
        if (bBigObjDisIsValid == FALSE) {
          NoObjDisDtdCnt++;
          if (NoObjDisIndex1 != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            if (NoObjDisIndex1 == (ObjIndex - 1)) {
              ConsecutiveNoObjDisPtNum++;
            } else {
              ConsecutiveNoObjDisPtNum = 0;
            }
          }
          NoObjDisIndex1 = ObjIndex;
          if (CheckMode < 2) {
            if ((NoObjDisDtdCnt > APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeAllowedMaxNoObjPt[VehSpdIndex]) ||
                (ConsecutiveNoObjDisPtNum > APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeAllowedMaxConsecutiveNoObjPt[VehSpdIndex])) {
              // too many no obj dis
              break;
            }
          } else {
            // check flat shape
            if ((NoObjDisDtdCnt > APACal.APASlotSnsDtdObjDisFilterFillFlatProfileAllowedMaxNoObjPt[VehSpdIndex]) ||
                (ConsecutiveNoObjDisPtNum > APACal.APASlotSnsDtdObjDisFilterFillFlatProfileAllowedMaxConsecutiveNoObjPt[VehSpdIndex])) {
              // too many no obj dis
              break;
            }
          }
        } else {
          PrevObjIndex = ObjIndex;
          if (CheckMode < 2) {
            if ((PrevDis - FirstPtDis) > APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeMaxObjDeltaDis) {
              // remove one point.
              ObjIndex2--;
              break;
            }
          }
        }
        if (CheckMode == 1) {
          // Falling edge.
          ObjIndex++;
          if (ObjIndex > (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1)) {
            break;
          }
        } else {
          // rising edge or flat shape.
          ObjIndex--;
          if (ObjIndex < 0) {
            break;
          }
        }
      }
      ObjIndex2++; // Including the first point.
      WithinTolCheckResult = 0;
      if (CheckMode == 0) {
        // rising edge.
        if ((ObjIndex2 >= APACal.APASlotSnsDtdObjDisFilterFillRisingEdgeAllowedMinTotalObjPt[VehSpdIndex]) &&
            (((bFlatPtAtStart == FALSE) && (BigObjPtNum >= APACal.APASlotSnsDtdObjDisFilterFillRisingEdgeAllowedMinBigObjPt1[VehSpdIndex])) ||
             ((bFlatPtAtStart == TRUE) && (BigObjPtNum >= APACal.APASlotSnsDtdObjDisFilterFillRisingEdgeAllowedMinBigObjPt2[VehSpdIndex])))) {
          WithinTolCheckResult = 1;
        }
      } else if (CheckMode == 1) {
        // falling edge.
        if ((ObjIndex2 >= APACal.APASlotSnsDtdObjDisFilterFillFallingEdgeAllowedMinTotalObjPt[VehSpdIndex]) &&
            (((bFlatPtAtStart == FALSE) && (BigObjPtNum >= APACal.APASlotSnsDtdObjDisFilterFillFallingEdgeAllowedMinBigObjPt1[VehSpdIndex])) ||
             ((bFlatPtAtStart == TRUE) && (BigObjPtNum >= APACal.APASlotSnsDtdObjDisFilterFillFallingEdgeAllowedMinBigObjPt2[VehSpdIndex])))) {
          WithinTolCheckResult = 1;
        }
      } else if (CheckMode <= 3) {
        // Flat shape.
        ObjIndex5 = APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2 +
                    APACal.APASlotSnsDtdObjDisFilterFillFlatProfileAllowedMinTotalObjPt[VehSpdIndex] / 2;
        if (ObjIndex2 > ObjIndex5) {
          ObjIndex5 = APACal.APASlotSnsDtdObjDisFilterFillFlatProfileAllowedMinBigObjPt2[VehSpdIndex];
        } else {
          ObjIndex5 = APACal.APASlotSnsDtdObjDisFilterFillFlatProfileAllowedMinBigObjPt1[VehSpdIndex];
        }

        if ((ObjIndex2 >= APACal.APASlotSnsDtdObjDisFilterFillFlatProfileAllowedMinTotalObjPt[VehSpdIndex]) && (BigObjPtNum >= ObjIndex5)) {
          WithinTolCheckResult = 1;
        }
      }

      if (WithinTolCheckResult == 1) {
        // OK, obj rising edge confirmed.
        while (BigObjPtIndex > 0) {
          BigObjPtIndex--;
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

          if (pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdBigObjDisIndexBuf[BigObjPtIndex]].BigObjDis == APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
            APASlotPcDebugSnsDtFilterDebug1 = 19;
          }
#endif
          pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdBigObjDisIndexBuf[BigObjPtIndex]].BigObjPtStatus.Bits.bIsObjProfileConfirmed = TRUE;
        }
        if (CheckMode < 3) {
          pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].BigObjPtStatus.Bits.bIsObjProfileConfirmed = TRUE;
        }
        while (SmallObjPtIndex > 0) {
          SmallObjPtIndex--;
          pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdSmallObjDisIndexBuf[SmallObjPtIndex]].SmallObjPtStatus.Bits.bIsObjProfileConfirmed = TRUE;
        }
        return TRUE;
      } else if ((CheckMode == 4) && (ObjIndex2 > APACal.APASlotMinObjCntOfCurbToCheckProfileWithCurb) &&
                 (SmallObjPtIndex > APACal.APASlotMinObjCntOfProfileToCheckProfileWithCurb)) {
        ObjIndex3 = ObjIndex2;
        ObjIndex5 = 0;
        while (ObjIndex3 > 1) {
          ObjIndex3--;
          PtSlope2 = SnsDtdObjDisPtSlopeBuf[0] - SnsDtdObjDisPtSlopeBuf[ObjIndex3];
          if (PtSlope2 < 0) {
            PtSlope2 = -PtSlope2;
          }
          if (PtSlope2 <= APACal.APASlotMaxDeltaSlopeToCheckIfTheProfileWithCurbIsExsit[VehSpdIndex]) {
            ObjIndex5++;
          }
          if (ObjIndex5 > APACal.APASlotMinObjCntOfCurbToCheckProfileWithCurb) {
            // total 4 times.
            // Curb with rising obj2 edge confirmed.
            while (SmallObjPtIndex > 0) {
              SmallObjPtIndex--;
              ObjIndex4                                                                          = SnsDtdSmallObjDisIndexBuf[SmallObjPtIndex];
              pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex4].BigObjPtStatus.Bits.bIsObjProfileConfirmed = TRUE;
              Dis1                                                                               = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex4].BigObjDis;
              if (Dis1 < 0) {
                pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex4].BigObjDis = -Dis1;
              } else {
                pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdSmallObjDisIndexBuf[SmallObjPtIndex]].BigObjDis =
                    pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdSmallObjDisIndexBuf[SmallObjPtIndex]].SmallObjDis;
              }
            }
            return TRUE;
          }
        }
      }
    }
  }
  return FALSE;
}
/*************************************************************************************************************************************************
 ** Syntax :  APA_DISTANCE_TYPE APASlotProcGetObjPtInFilterBuf(
 APASlotSnsDtdObjPtBufType *pAPASnsDtdObjPtBuf, APA_INDEX_TYPE ObjIndex,
 APA_ENUM_TYPE CheckMode)                                                                                                                    **
 **                                                                                                                                              **
 ** Service ID:   : N0.4-2 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

APA_DISTANCE_TYPE APASlotProcGetObjPtInFilterBuf(APASlotSnsDtdObjPtBufType *pAPASnsDtdObjPtBuf, APA_INDEX_TYPE ObjIndex, APA_ENUM_TYPE CheckMode) {
  // Check Mode: 0: without check the obj pt shape.
  //             1: check the obj pt shape.
  APA_DISTANCE_TYPE Dis1;
  BOOLEAN bBigObjConfirmed;

  Dis1             = NO_OBJ_DISTANCE;
  bBigObjConfirmed = FALSE;
  if (((CheckMode == 0) || (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjPtStatus.Bits.bObjDtdCntIsNotEnough == FALSE)) &&
      (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjPtStatus.Bits.bIsNoise == FALSE)) {
    Dis1 = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis;
    if (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjPtStatus.Bits.bIsObjProfileConfirmed == TRUE) {
      // OK, use this point dis.
      bBigObjConfirmed = TRUE;
    } else {
    }
  }
  if ((bBigObjConfirmed == FALSE) &&
      ((APACal.APASlotSnsDtdObjDisFilterUseConfirmedSmallObjEvenIfBigObjExist == TRUE) || (Dis1 < 0) || (Dis1 == NO_OBJ_DISTANCE))) {
    // use Small object.
    if ((((CheckMode == 0) || (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjPtStatus.Bits.bObjDtdCntIsNotEnough == FALSE)) &&
         (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjPtStatus.Bits.bIsNoise == FALSE) &&
         (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjPtStatus.Bits.bIsObjProfileConfirmed == TRUE)) &&
        ((CheckMode == 0) || ((pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjPtStatus.Bits.bIsFlatPt == TRUE) ||
                              (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjPtStatus.Bits.bIsFallingPt == TRUE) ||
                              (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjPtStatus.Bits.bIsRisingPt == TRUE)))) {
      Dis1 = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].SmallObjDis;
    } else {
      // Just use small obj or discast it. ??
    }
  }

#ifdef APA_SLOT_SUPPORT_DEBUG2

  // just for debug 2014 06 05
  if (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis != NO_OBJ_DISTANCE) {
    if (Dis1 != pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].BigObjDis) {
      cSlotDebug2 = 1;
    }
  }
#endif

  if (Dis1 < 0) {
    // small obj.
    Dis1 = -Dis1;
  }
  return Dis1;
}
/*************************************************************************************************************************************************
 ** Syntax :  void APASlotProcGetSnsDtdObjPtFromFilterBuf(
 APASlotSnsDtdObjPtBufType *pAPASnsDtdObjPtBuf,
 APA_ENUM_TYPE RemovedPtIndex, APA_ENUM_TYPE CalObjPtSnsIndex,
 APASlotObjPointType *pObjPtToBeSavedBuf) **
 **                                                                                                                                              **
 ** Service ID:   : NO.4-4 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

void APASlotProcGetSnsDtdObjPtFromFilterBuf(APASlotSnsDtdObjPtBufType *pAPASnsDtdObjPtBuf,
                                            APA_ENUM_TYPE RemovedPtIndex,
                                            APA_ENUM_TYPE CalObjPtSnsIndex,
                                            APASlotObjPointType *pObjPtToBeSavedBuf) {

  APA_ENUM_TYPE ObjIndex;
  APA_DISTANCE_TYPE Dis1;
  APASlotCoordinateDataCalFloatType SlotPt;
  APACoordinateDataCalFloatType CarPos1;

  // Move the point to the Object Point Buffer

  ObjIndex = RemovedPtIndex;

  Dis1              = APASlotProcGetObjPtInFilterBuf(pAPASnsDtdObjPtBuf, ObjIndex, 0); // 20200614
  SlotPt            = APASlotProcCalSlotRelativeToCarCoordinateBySnsDtdDis(Dis1, CalObjPtSnsIndex);
  CarPos1.x         = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x;
  CarPos1.y         = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y;
  SlotPt.Coordinate = APATrajCalPointPosWithAngAndCenterPt(SlotPt.Coordinate, pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng, CarPos1);

  pObjPtToBeSavedBuf->ObjDis              = SlotPt.DisFromCarToObj;
  pObjPtToBeSavedBuf->Pt.x                = (APA_DISTANCE_TYPE)SlotPt.Coordinate.x;
  pObjPtToBeSavedBuf->Pt.y                = (APA_DISTANCE_TYPE)SlotPt.Coordinate.y;
  pObjPtToBeSavedBuf->CarPos.Coordinate.x = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.x;
  pObjPtToBeSavedBuf->CarPos.Coordinate.y = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y;
  pObjPtToBeSavedBuf->CarPos.CarAng       = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.CarAng;
  pObjPtToBeSavedBuf->CarSpeed            = pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarSpeed;

}
/*************************************************************************************************************************************************
 ** Syntax :  void APASlotProcCheckObjPtInFilterBufIsFlatOrRisingOrFalling(
 APASlotSnsDtdObjPtBufType *pAPASnsDtdObjPtBuf,
 APA_DISTANCE_TYPE SnsDtdObjDisBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE],
 APA_SLOT_PT_SLOPE_TYPE SnsDtdObjDisPtSlopeBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE],
 APA_INDEX_TYPE SnsDtdObjDisIndexBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE],
 APA_INDEX_TYPE CheckedPtIndex, APA_INDEX_TYPE ObjPtNum,
 APA_INDEX_TYPE VehSpdIndex,
 tAPASlotSnsDtdObjPointStatusFlagType *pObjPtStatus) **
 **                                                                                                                                              **
 ** Service ID:   : NO.4-3 **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/
void APASlotProcCheckObjPtInFilterBufIsFlatOrRisingOrFalling(
    APASlotSnsDtdObjPtBufType *pAPASnsDtdObjPtBuf,
    APA_DISTANCE_TYPE SnsDtdObjDisBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE],
    APA_SLOT_PT_SLOPE_TYPE SnsDtdObjDisPtSlopeBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE],
    APA_INDEX_TYPE SnsDtdObjDisIndexBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE],
    APA_INDEX_TYPE CheckedPtIndex,
    APA_INDEX_TYPE ObjPtNum,
    APA_INDEX_TYPE VehSpdIndex,
    tAPASlotSnsDtdObjPointStatusFlagType *pObjPtStatus) {
  APA_INDEX_TYPE ObjIndex;
  APA_INDEX_TYPE i, j, k, m, n, g, h, m1;
  APA_DISTANCE_TYPE TolDis1, TolDis2, TolDis3, Dis1, TolDisUp, TolDisDown;
  BOOLEAN bSmallObjWidth, bRisingEdge, bEdgeConfirmed, bOutOfTol;
  APA_SLOT_PT_SLOPE_CAL_TYPE Slope1, TolSlope;
  APA_SLOT_PT_SLOPE_TYPE PtSlope1, PtSlope2;
  APA_INDEX_TYPE ObjWidthIndex, LastObjIndex;
  APA_INDEX_TYPE FlatObjIndexBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE];

  // Check if the obj pt is flat shape.
  if (ObjPtNum == 0) {
    // No obj pt
    return;
  }
  ObjIndex = SnsDtdObjDisIndexBuf[CheckedPtIndex];

  if (SnsDtdObjDisBuf[CheckedPtIndex] < APACal.APASlotSnsDtdObjDisFilterRegardedAsNoObjDtdDevidedObjDis) {
    // < 2m,
    i = 0;
  } else {
    i = 1;
  }
  // 1. check obj beeing detected cnt, if it is a noise?
  if (ObjPtNum <= APACal.APASlotSnsDtdObjDisFilterRegardedAsNoObjDtdMaxDtdObjPtNum[i][VehSpdIndex]) {
    // may be a noise.
    if ((ObjIndex == (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1)) ||
        (APASlotSnsDtdObjLoopCnt < (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE + 4))) {
      // the latest obj point. (obj just being detected.
      pObjPtStatus->Bits.bObjDtdCntIsNotEnough = TRUE;
    }
  } else {
    if ((CheckedPtIndex == 0) && (ObjPtNum > 1) &&
        ((SnsDtdObjDisIndexBuf[CheckedPtIndex + 1] - ObjIndex) >
         APACal.APASlotSnsDtdObjDisFilterRegardedAsNoObjDtdMinConsecutiveNoDtdObjPtNum[VehSpdIndex])) {
      // do not regarded as a valid point.
    } else {
      pObjPtStatus->Bits.bObjDtdCntIsNotEnough = FALSE;
    }
  }

  // 2. check if obj shape has been confirmed?
  if ((pObjPtStatus->Bits.bIsFlatPt == TRUE) || (pObjPtStatus->Bits.bIsFallingPt == TRUE) || (pObjPtStatus->Bits.bIsRisingPt == TRUE) ||
      (ObjPtNum < 2)) {
    // Obj confirmed
    return;
  }

  // check if it is a flat shape.
  if (ObjPtNum >= APACal.APASlotSnsDtdObjDisFilterCheckRisingOrFallingEdgeMinDtdObjPtNum[VehSpdIndex]) {

    Dis1 = APASlotProcCalTwoPtApproximateDisInt(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[0]].CarPos.Coordinate,
                                                pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[ObjPtNum - 1]].CarPos.Coordinate);
    if (Dis1 < APACal.APASlotSnsDtdObjDisFilterCheckRisingOrFallingEdgeDevidedObjWidth1) {
      ObjWidthIndex = 0;
    } else if (Dis1 < APACal.APASlotSnsDtdObjDisFilterCheckRisingOrFallingEdgeDevidedObjWidth2) {
      ObjWidthIndex = 1;
    } else {
      ObjWidthIndex = 2;
    }

    TolDis1 = APACal.APASlotSnsDtdObjDisFilterCheckRisingOrFallingEdgeMaxDeltaDisUp[ObjWidthIndex];   // +30cm
    TolDis2 = APACal.APASlotSnsDtdObjDisFilterCheckRisingOrFallingEdgeMaxDeltaDisDown[ObjWidthIndex]; // 5cm

    for (h = 0; h < 4; h++) {
      LastObjIndex = ObjPtNum - h / 2 - 1;
      if (LastObjIndex < (h + 2)) {
        break;
      }
      m1 = CheckedPtIndex + h;
      if ((CheckedPtIndex < (ObjPtNum / 2)) || (m1 == LastObjIndex)) {
        m1 = h;
      } else {
      }
      if (SnsDtdObjDisBuf[m1] > SnsDtdObjDisBuf[LastObjIndex]) {
        // rising edge.
        TolDisUp    = TolDis2;
        TolDisDown  = -TolDis1;
        bRisingEdge = TRUE;
      } else {
        // Falling edge.
        TolDisUp    = TolDis1;
        TolDisDown  = -TolDis2;
        bRisingEdge = FALSE;
      }
      k              = 1; // indicate how many points is within the tol with the checked pt.
      g              = m1;
      bEdgeConfirmed = FALSE;
      bOutOfTol      = TRUE;
      LastObjIndex   = ObjPtNum - 1;
      m              = ObjPtNum; // falling edge confirmed start pt.
      n              = 0;        // rising edge confirmed end pt.
      for (i = m1 + 1; i < ObjPtNum; i++) {
        Dis1 = (SnsDtdObjDisBuf[i] - SnsDtdObjDisBuf[g]);
        if ((Dis1 < TolDisDown) || (Dis1 > TolDisUp)) {
          // < : Out of tol. rising.
          // >: Out Of tol. falling.
        } else {
          // OK within tol
          k++;
          if (g == (i - 1)) {
            if (i == CheckedPtIndex) {
              j = i + 1;
              if (j < ObjPtNum) {
                Dis1 = (SnsDtdObjDisBuf[j] - SnsDtdObjDisBuf[i]);
                if ((Dis1 < TolDisDown) || (Dis1 > TolDisUp)) {
                  // < : Out of tol. rising.
                  // >: Out Of tol. falling.
                } else {
                  // OK within tol
                  bEdgeConfirmed = TRUE;
                }
              }
            } else if (g == CheckedPtIndex) {
              j = g - 1;
              if (j >= 0) {
                Dis1 = (SnsDtdObjDisBuf[g] - SnsDtdObjDisBuf[j]);
                if ((Dis1 < TolDisDown) || (Dis1 > TolDisUp)) {
                  // < : Out of tol. rising.
                  // >: Out Of tol. falling.
                } else {
                  // OK within tol
                  bEdgeConfirmed = TRUE;
                }
              }
            }
          }
          if ((g == CheckedPtIndex) || (i == CheckedPtIndex)) {
            bOutOfTol = FALSE;
          }
          if ((n < i) && (n < LastObjIndex) && (n != CheckedPtIndex)) {
            n = i;
          }
          if ((m > g) && (m > 0) && (g != CheckedPtIndex)) {
            m = g;
          }
          g = i;
        }
      }
      i = m1;
      g = i;
      while (i > 0) {
        i--;
        Dis1 = (SnsDtdObjDisBuf[g] - SnsDtdObjDisBuf[i]);
        if ((Dis1 < TolDisDown) || (Dis1 > TolDisUp)) {
          // < : Out of tol. rising.
          // >: Out Of tol. falling.
        } else {
          // OK within tol
          k++;
          if (g == (i + 1)) {
            if (i == CheckedPtIndex) {
              j = i - 1;
              if (j >= 0) {
                Dis1 = (SnsDtdObjDisBuf[i] - SnsDtdObjDisBuf[j]);
                if ((Dis1 < TolDisDown) || (Dis1 > TolDisUp)) {
                  // < : Out of tol. rising.
                  // >: Out Of tol. falling.
                } else {
                  // OK within tol
                  bEdgeConfirmed = TRUE;
                }
              }
            } else if (g == CheckedPtIndex) {
              j = g + 1;
              if (j < ObjPtNum) {
                Dis1 = (SnsDtdObjDisBuf[j] - SnsDtdObjDisBuf[g]);
                if ((Dis1 < TolDisDown) || (Dis1 > TolDisUp)) {
                  // < : Out of tol. rising.
                  // >: Out Of tol. falling.
                } else {
                  // OK within tol
                  bEdgeConfirmed = TRUE;
                }
              }
            }
          }

          if ((g == CheckedPtIndex) || (i == CheckedPtIndex)) {
            bOutOfTol = FALSE;
          }

          if ((n < g) && (n < LastObjIndex) && (n != CheckedPtIndex)) {
            n = g;
          }
          if ((m > i) && (m > 0) && (m != CheckedPtIndex)) {
            m = i;
          }
          g = i;
        }
      }

      // k: Indicate how many points is within the tol with the neighbor pt.
      if (k >= APACal.APASlotSnsDtdObjDisFilterRegardedAsRisingOrFallingMinDtdObjPtNum[VehSpdIndex]) {
        // OK,
        if (bRisingEdge == TRUE) {
          if (CheckedPtIndex <= (ObjPtNum / 2)) {
            if (bEdgeConfirmed == TRUE) {

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

              if (SnsDtdObjDisBuf[CheckedPtIndex] == APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                APASlotPcDebugSnsDtFilterDebug1 = 2;
              }
#endif

              pObjPtStatus->Bits.bIsRisingPt = TRUE;
              return;
            } else {
              // the later on code will process this situation
#if 0
							if((CheckedPtIndex == 0)
									&& (SnsDtdObjDisIndexBuf[0] >= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2 - 1)))
							{
								/*

								 * * *
								 * -
								 |
								 Dis out of tol
								 |
								 *  -  noise
								 */

								pObjPtStatus->Bits.bIsNoise = TRUE;
								return;
							}
#endif
            }
          } else {
            if ((CheckedPtIndex == (ObjPtNum - 1)) &&
                (SnsDtdObjDisIndexBuf[CheckedPtIndex] <= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2 + 1))) {

              // m: falling edge confirmed start pt.
              // n: rising edge confirmed end pt.
              // rising edge last point.
              if ((SnsDtdObjDisBuf[n] - SnsDtdObjDisBuf[CheckedPtIndex]) > APACal.APASlotSnsDtdObjDisFilterHeadOrTailFlatObjTolDis[VehSpdIndex]) {
                // OK, noise confirmed.
                /*
                 ----
                 * - noise
                 |
                 Dis out of tol
                 |
                 *  -
                 *
                 *


                 */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                  APASlotPcDebugSnsDtFilterDebug1 = 10;
                }
#endif

                pObjPtStatus->Bits.bIsNoise = TRUE;
                return;
              }
            }
          }
        } else {
          // falling edge.
          if (CheckedPtIndex >= (ObjPtNum / 2)) {
            if (bEdgeConfirmed == TRUE) {

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

              if (SnsDtdObjDisBuf[CheckedPtIndex] == APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                APASlotPcDebugSnsDtFilterDebug1 = 3;
              }
#endif

              pObjPtStatus->Bits.bIsFallingPt = TRUE;
              return;
            } else {
              if ((CheckedPtIndex == (ObjPtNum - 1)) && (bOutOfTol == TRUE) &&
                  (SnsDtdObjDisIndexBuf[CheckedPtIndex] <= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2 + 1))) {
                /*

                 *
                 * *
                 * -
                 |
                 Dis out of tol
                 |
                 *  -  noise
                 */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                  APASlotPcDebugSnsDtFilterDebug1 = 10;
                }
#endif

                pObjPtStatus->Bits.bIsNoise = TRUE;
                return;
              }
            }
          } else {
            if ((CheckedPtIndex == 0) && (SnsDtdObjDisIndexBuf[0] >= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2 - 1))) {
              // m: falling edge confirmed start pt.
              // n: rising edge confirmed end pt.
              // rising edge last point.
              if ((SnsDtdObjDisBuf[m] - SnsDtdObjDisBuf[CheckedPtIndex]) > APACal.APASlotSnsDtdObjDisFilterHeadOrTailFlatObjTolDis[VehSpdIndex]) {
                // OK, noise confirmed.
                /*
                 ----
                 * - noise
                 |
                 Dis out of tol
                 |
                 - *
                 *
                 *


                 */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                  APASlotPcDebugSnsDtFilterDebug1 = 10;
                }
#endif

                pObjPtStatus->Bits.bIsNoise = TRUE;
                return;
              }
            }
          }
        }
      }
    }
  }

  if (SnsDtdObjDisBuf[CheckedPtIndex] < APACal.APASlotSnsDtdObjDisFilterFlatObjTolDevidedObjDis) {
    TolDis3 = APACal.APASlotSnsDtdObjDisFilterFlatObjTolDis2;
  } else {
    TolDis3 = APACal.APASlotSnsDtdObjDisFilterFlatObjTolDis3;
  }

  m = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // first within tol point index.
  n = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // second within tol point index.
  k = 0;                                   // indicate how many points is within the tol with the checked pt.
  g = CheckedPtIndex;
  for (i = CheckedPtIndex + 1; i < ObjPtNum; i++) {
    Dis1 = (SnsDtdObjDisBuf[i] - SnsDtdObjDisBuf[g]);
    if ((Dis1 < (-TolDis3)) || (Dis1 > TolDis3)) {
      // < : Out of tol. rising.
      // >: Out Of tol. falling.
    } else {
      // OK within tol
      if (m == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        m = i;
      } else if (n == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        n = i;
      }
      FlatObjIndexBuf[k] = i;
      k++;
      g = i;
    }
  }
  i = CheckedPtIndex;
  g = i;
  while (i > 0) {
    i--;
    Dis1 = (SnsDtdObjDisBuf[g] - SnsDtdObjDisBuf[i]);
    if ((Dis1 < (-TolDis3)) || (Dis1 > TolDis3)) {
      // < : Out of tol. rising.
      // >: Out Of tol. falling.
    } else {
      // OK within tol
      if (m == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        m = i;
      } else if (n == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        n = i;
      }
      FlatObjIndexBuf[k] = i;
      k++;
      g = i;
    }
  }

  // k indicate how many points is within the tol with the checked pt.
  if (k >= APACal.APASlotSnsDtdObjDisFilterRegardedAsFlatObjMinDtdObjPtNum1[VehSpdIndex]) {
    // OK,

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

    if (SnsDtdObjDisBuf[CheckedPtIndex] == APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
      APASlotPcDebugSnsDtFilterDebug1 = 4;
    }
#endif

    pObjPtStatus->Bits.bIsFlatPt = TRUE;
    for (i = 0; i < k; i++) {
      j = SnsDtdObjDisIndexBuf[FlatObjIndexBuf[i]];
      if (MATH_ABS(pAPASnsDtdObjPtBuf->ObjPtBuf[j].BigObjDis) == SnsDtdObjDisBuf[FlatObjIndexBuf[i]]) {
        pAPASnsDtdObjPtBuf->ObjPtBuf[j].BigObjPtStatus.Bits.bIsFlatPt = TRUE;
      } else if (pAPASnsDtdObjPtBuf->ObjPtBuf[j].SmallObjDis == SnsDtdObjDisBuf[FlatObjIndexBuf[i]]) {
        pAPASnsDtdObjPtBuf->ObjPtBuf[j].SmallObjPtStatus.Bits.bIsFlatPt = TRUE;
      }
    }
    return;
  }

  // check if it is a small width pt obj or big.
  bSmallObjWidth = TRUE;
  for (i = 0; i < ObjPtNum; i++) {
    if (SnsDtdObjDisPtSlopeBuf[i] == APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT) {
      // small obj pt width.
      bSmallObjWidth = FALSE;
      break;
    } else {
      // keep searching.
    }
  }

  if (bSmallObjWidth == FALSE) {
    // small obj pt width.
    // Obj pt width < 3cm.
    if ((k < 3) && (((CheckedPtIndex == 0) && (SnsDtdObjDisIndexBuf[0] >= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2 - 1))) ||
                    ((CheckedPtIndex == (ObjPtNum - 1)) &&
                     (SnsDtdObjDisIndexBuf[CheckedPtIndex] <= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2 + 1))) ||
                    ((CheckedPtIndex > 0) && (CheckedPtIndex < (ObjPtNum - 1))))) {
      // just regarded as noise.
      for (i = 0; i < ObjPtNum; i++) {
        if ((i != CheckedPtIndex) && (i != m) && (i != n)) {
          h = i;
          g = 0; // flat point num
          for (j = 0; j < ObjPtNum; j++) {
            if ((j != CheckedPtIndex) && (j != m) && (j != n)) {

              Dis1 = (SnsDtdObjDisBuf[h] - SnsDtdObjDisBuf[j]);
              if ((Dis1 < (-TolDis3)) || (Dis1 > TolDis3)) {
                // < : Out of tol. rising.
                // >: Out Of tol. falling.
              } else {
                // OK within tol
                h = j;
                g++;
              }
            }
          }
          Dis1 = ObjPtNum - g;
          Dis1 *= 100;
          Dis1 /= ObjPtNum;

          if ((g >= APACal.APASlotSnsDtdObjDisFilterLowSpdRegardedAsNoiseMinFlatPtNum[k]) &&
              (Dis1 < APACal.APASlotSnsDtdObjDisFilterLowSpdRegardedAsNoiseMaxPercentage)) {
            // noise confirmed.
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

            if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
              APASlotPcDebugSnsDtFilterDebug1 = 10;
            }
#endif

            pObjPtStatus->Bits.bIsNoise = TRUE;
            break;
          }
        }
      }
    } else {
      // can not confirm
    }
  } else {
    // normal or big obj pt width

    if (SnsDtdObjDisBuf[CheckedPtIndex] < APACal.APASlotSnsDtdObjDisFilterFlatObjTolDevidedObjDis) {
      TolDis3 = APACal.APASlotSnsDtdObjDisFilterFlatObjTolDis1;
    } else {
      TolDis3 = APACal.APASlotSnsDtdObjDisFilterFlatObjTolDis3;
    }

    TolSlope = APACal.APASlotSnsDtdObjDisFilterAllowedMaxDeltaSlope1[VehSpdIndex];
    k        = 0; // delta slope within range point num
    j        = (ObjPtNum - 1);
    h        = CheckedPtIndex;
    if (h == (ObjPtNum - 1)) {
      h--;
    }

    if ((SnsDtdObjDisPtSlopeBuf[h] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
        (SnsDtdObjDisPtSlopeBuf[h] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
      g = h;
      for (i = h + 1; i < j; i++) {
        if ((SnsDtdObjDisPtSlopeBuf[i] < -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
            (SnsDtdObjDisPtSlopeBuf[i] > APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
          break;
        }

        Slope1 = (SnsDtdObjDisPtSlopeBuf[i]);
        Slope1 = Slope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)(SnsDtdObjDisPtSlopeBuf[g]);
        if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
          // < : Out of tol. rising.
          // >: Out Of tol. falling.
          break;
        } else {
          // OK within tol
          k++;
        }
        g = i;
      }

      i = h;
      g = h;
      while (i > 0) {
        i--;
        if ((SnsDtdObjDisPtSlopeBuf[i] < -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
            (SnsDtdObjDisPtSlopeBuf[i] > APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
          break;
        }

        Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[g] - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[i]);
        if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
          // < : Out of tol. rising.
          // >: Out Of tol. falling.
          break;
        } else {
          // OK within tol
          k++;
        }
        g = i;
      }
      // k: Total delta slope within tol num
      if (k >= APACal.APASlotSnsDtdObjDisFilterRegardedAsOKShapeMinOKDeltaSlopeNum[VehSpdIndex]) {
        // OK. shape.

        if (CheckedPtIndex < (ObjPtNum - 1)) {
          // bOutOfTol = FALSE;

          if (CheckedPtIndex > 0) {
            Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 1] -
                      (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex]);
            if ((Slope1 < (-APACal.APASlotSnsDtdObjDisFilterAllowedMaxDeltaSlope2[VehSpdIndex])) ||
                (Slope1 > (APACal.APASlotSnsDtdObjDisFilterAllowedMaxDeltaSlope2[VehSpdIndex]))) {
              // Out of tol
              if ((CheckedPtIndex < (ObjPtNum - 3)) && (SnsDtdObjDisBuf[CheckedPtIndex] < (SnsDtdObjDisBuf[CheckedPtIndex - 1] - TolDis3)) &&
                  (SnsDtdObjDisBuf[CheckedPtIndex] < (SnsDtdObjDisBuf[CheckedPtIndex + 1] - TolDis3)) &&
                  (SnsDtdObjDisBuf[CheckedPtIndex + 1] < (SnsDtdObjDisBuf[CheckedPtIndex - 1])) &&
                  (SnsDtdObjDisBuf[CheckedPtIndex + 2] < (SnsDtdObjDisBuf[CheckedPtIndex + 1])) &&
                  (SnsDtdObjDisBuf[CheckedPtIndex + 3] < (SnsDtdObjDisBuf[CheckedPtIndex + 2]))) {
                if (((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                     (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) &&
                    ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                     (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope))) {
                  Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] -
                            (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2]);
                  if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                    // < : Out of tol. rising.
                    // >: Out Of tol. falling.
                    // unknow shape ??
                  } else {
                    // within tol
                    // Noise.
                    /*
                     | noise              *
                     *             *
                     *
                     *
                     */

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                    if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                      APASlotPcDebugSnsDtFilterDebug1 = 10;
                    }
#endif

                    pObjPtStatus->Bits.bIsNoise = TRUE;

                    return;
                  }
                }
              } else if ((CheckedPtIndex > 2) && (SnsDtdObjDisBuf[CheckedPtIndex] < (SnsDtdObjDisBuf[CheckedPtIndex - 1] - TolDis3)) &&
                         (SnsDtdObjDisBuf[CheckedPtIndex] < (SnsDtdObjDisBuf[CheckedPtIndex + 1] - TolDis3)) &&
                         (SnsDtdObjDisBuf[CheckedPtIndex - 1] < (SnsDtdObjDisBuf[CheckedPtIndex + 1])) &&
                         (SnsDtdObjDisBuf[CheckedPtIndex - 2] < (SnsDtdObjDisBuf[CheckedPtIndex - 1])) &&
                         (SnsDtdObjDisBuf[CheckedPtIndex - 3] < (SnsDtdObjDisBuf[CheckedPtIndex - 2]))) {
                if (((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                     (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) &&
                    ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                     (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope))) {
                  Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] -
                            (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3]);
                  if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                    // < : Out of tol. rising.
                    // >: Out Of tol. falling.
                    // unknow shape ??
                  } else {
                    // within tol
                    // Noise.
                    /*

                     *
                     *	           |   noise
                     * 	  *

                     *
                     */

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                    if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                      APASlotPcDebugSnsDtFilterDebug1 = 10;
                    }
#endif

                    pObjPtStatus->Bits.bIsNoise = TRUE;

                    return;
                  }
                }
              }
            }
          } else {
          }

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

          if (SnsDtdObjDisBuf[CheckedPtIndex] == APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
            APASlotPcDebugSnsDtFilterDebug1 = 8;
          }
#endif

          if (SnsDtdObjDisPtSlopeBuf[h] < 0) {
            // rising shape
            pObjPtStatus->Bits.bIsRisingPt = TRUE;
          } else {
            pObjPtStatus->Bits.bIsFallingPt = TRUE;
          }
        } else {
          Dis1 = (SnsDtdObjDisBuf[CheckedPtIndex - 1] - SnsDtdObjDisBuf[CheckedPtIndex]);
          if ((Dis1 < TolDis3) && (Dis1 > -TolDis3)) {

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

            if (SnsDtdObjDisBuf[CheckedPtIndex] == APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
              APASlotPcDebugSnsDtFilterDebug1 = 9;
            }
#endif
            if (SnsDtdObjDisPtSlopeBuf[h] < 0) {
              // rising shape
              pObjPtStatus->Bits.bIsRisingPt = TRUE;
            } else {
              pObjPtStatus->Bits.bIsFallingPt = TRUE;
            }
          }
        }
        return;
      }
    }

    if ((CheckedPtIndex < (ObjPtNum - 1)) && (CheckedPtIndex > 0) &&
        ((SnsDtdObjDisPtSlopeBuf[h - 1] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
         (SnsDtdObjDisPtSlopeBuf[h - 1] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope))) {
      h--;
      k = 0;
      i = h;
      g = h;
      while (i > 0) {
        i--;
        if ((SnsDtdObjDisPtSlopeBuf[i] < -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
            (SnsDtdObjDisPtSlopeBuf[i] > APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
          break;
        }
        Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[g] - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[i]);
        if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
          // < : Out of tol. rising.
          // >: Out Of tol. falling.
          break;
        } else {
          // OK within tol
          k++;
        }
        g = i;
      }
      if (k >= APACal.APASlotSnsDtdObjDisFilterRegardedAsOKShapeMinOKDeltaSlopeNum[VehSpdIndex]) {
        // OK. shape.

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

        if (SnsDtdObjDisBuf[CheckedPtIndex] == APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
          APASlotPcDebugSnsDtFilterDebug1 = 6;
        }
#endif

        if (SnsDtdObjDisPtSlopeBuf[h] < 0) {
          // rising shape
          pObjPtStatus->Bits.bIsRisingPt = TRUE;
        } else {
          pObjPtStatus->Bits.bIsFallingPt = TRUE;
        }
        return;
      }
    }

    if ((ObjPtNum > 3) && (SnsDtdObjDisIndexBuf[CheckedPtIndex] >= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2 - 1)) &&
        (SnsDtdObjDisIndexBuf[CheckedPtIndex] <= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2 + 1))) {
      // checked point is the mid point.
      if (CheckedPtIndex == 0) {
        // Obj First point.

        if (SnsDtdObjDisPtSlopeBuf[0] > APACal.APASlotSnsDtdObjDisFilterObjHeadAllowedMaxSlope) {
          // a noise detected. ??
          if (SnsDtdObjDisBuf[0] < (SnsDtdObjDisBuf[2] - APACal.APASlotSnsDtdObjDisFilterHeadOrTailFlatObjTolDis[VehSpdIndex])) {
            // OK noise confirmed.
            /*
             noise
             *
             **
             */

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

            if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
              APASlotPcDebugSnsDtFilterDebug1 = 10;
            }
#endif

            pObjPtStatus->Bits.bIsNoise = TRUE;

          } else if (ObjPtNum > 4) {
            if (SnsDtdObjDisBuf[2] < (SnsDtdObjDisBuf[3] - TolDis3)) {
              Dis1 = MATH_ABS(SnsDtdObjDisBuf[1] - SnsDtdObjDisBuf[3]);
              if (Dis1 < TolDis3) {
                Dis1 = MATH_ABS(SnsDtdObjDisBuf[3] - SnsDtdObjDisBuf[4]);
                if (Dis1 < TolDis3) {
                  // Both index 0 and 2 are noises.
                  /*
                   Noise
                   * *
                   * **
                   */

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                  if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                    APASlotPcDebugSnsDtFilterDebug1 = 10;
                  }
#endif

                  pObjPtStatus->Bits.bIsNoise = TRUE;
                }
              }
            }
          }
        } else if (ObjPtNum > 4) {
          if (((SnsDtdObjDisPtSlopeBuf[3] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
               (SnsDtdObjDisPtSlopeBuf[3] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) &&
              ((SnsDtdObjDisPtSlopeBuf[2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
               (SnsDtdObjDisPtSlopeBuf[2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope))) {
            Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[3] - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[2]);
            if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
              // < : Out of tol. rising.
              // >: Out Of tol. falling.
              // unknow shape ??
            } else {
              // within tol

              if ((SnsDtdObjDisBuf[0] < SnsDtdObjDisBuf[2]) && (SnsDtdObjDisBuf[0] < SnsDtdObjDisBuf[3])) {
                Dis1 = APASlotProcCalTwoPtApproximateDisInt(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[0]].CarPos.Coordinate,
                                                            pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[1]].CarPos.Coordinate);
                if (Dis1 < APACal.APASlotSnsDtdObjDisFilterAllowedToRemoveTwoPointsMaxDis) {
                  // Cal ths slope of point 0 and 2
                  PtSlope1 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[2]].CarPos.Coordinate,
                                                         pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[0]].CarPos.Coordinate,
                                                         SnsDtdObjDisBuf[2],
                                                         SnsDtdObjDisBuf[0]);
                  if (PtSlope1 > APACal.APASlotSnsDtdObjDisFilterObjHeadAllowedMaxSlope) {
                    // a noise detected. ??
                    /*
                     *
                     Noise	*          **
                     ***      ***
                     */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                    if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                      APASlotPcDebugSnsDtFilterDebug1 = 10;
                    }
#endif

                    pObjPtStatus->Bits.bIsNoise = TRUE;
                  }
                }
              }
            }
          }
        }

      } else if (CheckedPtIndex == (ObjPtNum - 1)) {
        // Obj end point.
        if (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex] < APACal.APASlotSnsDtdObjDisFilterObjTailAllowedMinSlope) {
          // a noise detected. ??
          if (SnsDtdObjDisBuf[CheckedPtIndex] <
              (SnsDtdObjDisBuf[CheckedPtIndex - 2] - APACal.APASlotSnsDtdObjDisFilterHeadOrTailFlatObjTolDis[VehSpdIndex])) {
            // OK noise confirmed.
            /*

             * noise
             ** ----
             */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

            if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
              APASlotPcDebugSnsDtFilterDebug1 = 10;
            }
#endif

            pObjPtStatus->Bits.bIsNoise = TRUE;

          } else if (ObjPtNum > 4) {
            if (SnsDtdObjDisBuf[CheckedPtIndex - 2] < (SnsDtdObjDisBuf[CheckedPtIndex - 3] - TolDis3)) {
              Dis1 = MATH_ABS(SnsDtdObjDisBuf[CheckedPtIndex - 1] - SnsDtdObjDisBuf[CheckedPtIndex - 3]);
              if (Dis1 < TolDis3) {
                Dis1 = MATH_ABS(SnsDtdObjDisBuf[CheckedPtIndex - 3] - SnsDtdObjDisBuf[CheckedPtIndex - 4]);
                if (Dis1 < TolDis3) {
                  // Both index CheckedPtIndex and CheckedPtIndex - 2 are noises.
                  /*
                   *  * noise
                   **  *
                   */

#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                  if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                    APASlotPcDebugSnsDtFilterDebug1 = 10;
                  }
#endif

                  pObjPtStatus->Bits.bIsNoise = TRUE;
                }
              }
            }
          }
        } else if (ObjPtNum > 4) {

          if (((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
               (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) &&
              ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
               (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope))) {
            Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] -
                      (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2]);
            if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
              // < : Out of tol. rising.
              // >: Out Of tol. falling.
              // unknow shape ??
            } else {
              // within tol

              if ((SnsDtdObjDisBuf[CheckedPtIndex - 0] < SnsDtdObjDisBuf[CheckedPtIndex - 2]) &&
                  (SnsDtdObjDisBuf[CheckedPtIndex - 0] < SnsDtdObjDisBuf[CheckedPtIndex - 3])) {
                Dis1 = APASlotProcCalTwoPtApproximateDisInt(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                                            pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex]].CarPos.Coordinate);
                if (Dis1 < APACal.APASlotSnsDtdObjDisFilterAllowedToRemoveTwoPointsMaxDis) {
                  // Cal ths slope of point 0 and 2

                  // Cal ths slope of point 0 and 2
                  PtSlope1 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 0]].CarPos.Coordinate,
                                                         pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 2]].CarPos.Coordinate,
                                                         SnsDtdObjDisBuf[CheckedPtIndex - 0],
                                                         SnsDtdObjDisBuf[CheckedPtIndex - 2]);
                  if (PtSlope1 < APACal.APASlotSnsDtdObjDisFilterObjTailAllowedMinSlope) {
                    /*
                     ** noise
                     ***
                     */
                    // a noise detected. ??
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                    if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                      APASlotPcDebugSnsDtFilterDebug1 = 10;
                    }
#endif

                    pObjPtStatus->Bits.bIsNoise = TRUE;
                  }
                }
              }
            }
          }
        }
      } else {
        // Mid of the object.

        // check from cur pt to tail
        if (CheckedPtIndex < (ObjPtNum - 2)) {
          Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex] -
                    (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1]);
          if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
            // < : Out of tol. rising.
            // >: Out Of tol. falling.
            if (SnsDtdObjDisBuf[CheckedPtIndex] > SnsDtdObjDisBuf[CheckedPtIndex + 1]) {
              if (SnsDtdObjDisBuf[CheckedPtIndex] > (SnsDtdObjDisBuf[CheckedPtIndex + 2] - TolDis3)) {
                if (SnsDtdObjDisBuf[CheckedPtIndex] > (SnsDtdObjDisBuf[CheckedPtIndex - 1] - TolDis3)) {
                  // Cal ths slope of point 0 and 2
                  if ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                      (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                    PtSlope1 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 1]].CarPos.Coordinate,
                                                           pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                                           SnsDtdObjDisBuf[CheckedPtIndex + 1],
                                                           SnsDtdObjDisBuf[CheckedPtIndex - 1]);
                    if ((PtSlope1 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                        (PtSlope1 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                      Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1]);
                      if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                        // < : Out of tol. rising.
                        // >: Out Of tol. falling.
                        // Unknown shape.
                      } else {
                        // within range.
                        // noise confirmed.
                        /*
                         *  **
                         *
                         */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                        if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                          APASlotPcDebugSnsDtFilterDebug1 = 10;
                        }
#endif

                        pObjPtStatus->Bits.bIsNoise = TRUE;
                      }
                    }
                  }
                } else {
                  if (CheckedPtIndex > 2) {
                    if (((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                         (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) &&
                        ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                         (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope))) {
                      Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] -
                                (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1]);
                      if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                        // < : Out of tol. rising.
                        // >: Out Of tol. falling.
                        // Unknow shape.
                      } else {
                        Dis1 = APASlotProcCalTwoPtApproximateDisInt(
                            pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                            pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex]].CarPos.Coordinate);
                        if (Dis1 < APACal.APASlotSnsDtdObjDisFilterAllowedToRemoveTwoPointsMaxDis) {

                          PtSlope1 =
                              APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 1]].CarPos.Coordinate,
                                                          pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 2]].CarPos.Coordinate,
                                                          SnsDtdObjDisBuf[CheckedPtIndex + 1],
                                                          SnsDtdObjDisBuf[CheckedPtIndex - 2]);
                          if ((PtSlope1 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                              (PtSlope1 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {

                            // Noise confirmed. Checked Pt Index and Checked Pt Index - 1 are all both noise.
                            /*
                             **  **
                             ** <- noise
                             */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                            if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                              APASlotPcDebugSnsDtFilterDebug1 = 10;
                            }
#endif

                            pObjPtStatus->Bits.bIsNoise = TRUE;
                          }
                        }
                      }
                    }
                  } else {
                    // it is hard to determine if the cur point is a noise
                  }
                }
              } else {
                //
                if (SnsDtdObjDisBuf[CheckedPtIndex] > (SnsDtdObjDisBuf[CheckedPtIndex - 1] - TolDis3)) {
                  if (CheckedPtIndex > 1) {
                    // Cal ths slope of point 0 and 2
                    if ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                        (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                      PtSlope1 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 1]].CarPos.Coordinate,
                                                             pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                                             SnsDtdObjDisBuf[CheckedPtIndex + 1],
                                                             SnsDtdObjDisBuf[CheckedPtIndex - 1]);
                      if ((PtSlope1 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                          (PtSlope1 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                        Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2]);
                        if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                          // < : Out of tol. rising.
                          // >: Out Of tol. falling.
                          // Unknown shape.
                        } else {
                          // within range.
                          // noise confirmed.
                          /*
                           **  *
                           *  *
                           */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                          if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                            APASlotPcDebugSnsDtFilterDebug1 = 10;
                          }
#endif

                          pObjPtStatus->Bits.bIsNoise = TRUE;
                        }
                      }
                    }
                  } else {
                    // It is hard to determin the cur point is a noise or not ??
                    // Just regarded as the previous point status.
                  }
                } else {
                  if ((CheckedPtIndex > 1) && (CheckedPtIndex < (ObjPtNum - 3))) {
                    Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] -
                              (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 1]);
                    if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                      // < : Out of tol. rising.
                      // >: Out Of tol. falling.
                      if (((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                           (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) &&
                          ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                           (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope))) {
                        Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] -
                                  (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2]);
                        if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                          // < : Out of tol. rising.
                          // >: Out Of tol. falling.
                          // Unknown shape.
                        } else {
                          PtSlope1 =
                              APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 2]].CarPos.Coordinate,
                                                          pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                                          SnsDtdObjDisBuf[CheckedPtIndex + 2],
                                                          SnsDtdObjDisBuf[CheckedPtIndex - 1]);
                          if ((PtSlope1 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                              (PtSlope1 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {

                            Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2]);
                            if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                              // < : Out of tol. rising.
                              // >: Out Of tol. falling.
                              // Unknown shape.
                            } else {
                              // within range.
                              // Noise confirmed.
                              /*
                               Noise
                               * *
                               * *    * *
                               */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                              if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                                APASlotPcDebugSnsDtFilterDebug1 = 10;
                              }
#endif

                              pObjPtStatus->Bits.bIsNoise = TRUE;
                            }
                          }
                        }
                      }
                    } else {
                      // Ok not a noise
                      /*        *
                       * * *   * *
                       | Checked Pt Index.
                       */
                    }
                  }
                }
              }
            } else {
              // point with near dis.
              if (SnsDtdObjDisBuf[CheckedPtIndex] < (SnsDtdObjDisBuf[CheckedPtIndex - 1] - TolDis3)) {
                if (SnsDtdObjDisBuf[CheckedPtIndex] < (SnsDtdObjDisBuf[CheckedPtIndex + 2] - TolDis3)) {
                  if (CheckedPtIndex > 1) {
                    Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] -
                              (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1]);
                    if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope) ||
                        (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] > APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
                        (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] < -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
                        (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] > APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
                        (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] < -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                      // < : Out of tol. rising.
                      // >: Out Of tol. falling.
                      if (CheckedPtIndex > 2) {
                        if (SnsDtdObjDisBuf[CheckedPtIndex - 2] < (SnsDtdObjDisBuf[CheckedPtIndex - 3] - TolDis3)) {
                          if ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                              (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                            PtSlope1 =
                                APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 1]].CarPos.Coordinate,
                                                            pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                                            SnsDtdObjDisBuf[CheckedPtIndex + 1],
                                                            SnsDtdObjDisBuf[CheckedPtIndex - 1]);
                            if ((PtSlope1 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                                (PtSlope1 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {

                              Slope1 =
                                  ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 1]);
                              if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                                // < : Out of tol. rising.
                                // >: Out Of tol. falling.
                                // Unknown shape.
                              } else {
                                // within range.
                                PtSlope2 = APASlotProcCalTwoObjPtSlope(
                                    pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                    pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 3]].CarPos.Coordinate,
                                    SnsDtdObjDisBuf[CheckedPtIndex - 1],
                                    SnsDtdObjDisBuf[CheckedPtIndex - 3]);

                                if ((PtSlope2 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                                    (PtSlope2 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                                  Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope2);
                                  if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                                    // < : Out of tol. rising.
                                    // >: Out Of tol. falling.
                                    // Unknown shape.
                                  } else {
                                    // within range.
                                    // OK, noise confirmed.
                                    /*
                                     noise
                                     * *
                                     *  * **

                                     */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                                    if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                                      APASlotPcDebugSnsDtFilterDebug1 = 10;
                                    }
#endif

                                    pObjPtStatus->Bits.bIsNoise = TRUE;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          // unknown shape.
                        }
                      } else {
                        // unknown shape.
                      }
                      if ((pObjPtStatus->Bits.bIsNoise == FALSE) && (CheckedPtIndex < (ObjPtNum - 3))) {
                        // Check if it is
                        /*
                         Noise-> **

                         * *    **
                         */
                        Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] -
                                  (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 1]);
                        if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                          // < : Out of tol. rising.
                          // >: Out Of tol. falling.
                          if (((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                               (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) &&
                              ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                               (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope))) {

                            Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] -
                                      (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2]);
                            if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                              // < : Out of tol. rising.
                              // >: Out Of tol. falling.
                              // unknown shape.
                            } else {
                              PtSlope1 = APASlotProcCalTwoObjPtSlope(
                                  pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 2]].CarPos.Coordinate,
                                  pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                  SnsDtdObjDisBuf[CheckedPtIndex + 2],
                                  SnsDtdObjDisBuf[CheckedPtIndex - 1]);
                              if ((PtSlope1 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                                  (PtSlope1 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {

                                Slope1 =
                                    ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 2]);
                                if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                                  // < : Out of tol. rising.
                                  // >: Out Of tol. falling.
                                  // Unknown shape.
                                } else {
                                  // within range.
                                  // OK, noise confirmed.
                                  /*
                                   Noise-> **

                                   * *    **
                                   */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                                  if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                                    APASlotPcDebugSnsDtFilterDebug1 = 10;
                                  }
#endif

                                  pObjPtStatus->Bits.bIsNoise = TRUE;
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      //
                      // OK, noise confirmed.
                      /*
                       *
                       **   **
                       */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                      if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                        APASlotPcDebugSnsDtFilterDebug1 = 10;
                      }
#endif

                      pObjPtStatus->Bits.bIsNoise = TRUE;
                    }
                  } else {
                    // checkedPtIndex == 1
                    PtSlope1 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[2]].CarPos.Coordinate,
                                                           pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[0]].CarPos.Coordinate,
                                                           SnsDtdObjDisBuf[2],
                                                           SnsDtdObjDisBuf[0]);
                    Slope1   = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[2]);
                    if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope) ||
                        (SnsDtdObjDisPtSlopeBuf[2] > APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
                        (SnsDtdObjDisPtSlopeBuf[2] < -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
                        (PtSlope1 > APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
                        (PtSlope1 < -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                      // < : Out of tol. rising.
                      // >: Out Of tol. falling.
                      if (ObjPtNum > 5) {
                        PtSlope2 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[4]].CarPos.Coordinate,
                                                               pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[2]].CarPos.Coordinate,
                                                               SnsDtdObjDisBuf[4],
                                                               SnsDtdObjDisBuf[2]);
                        Slope1   = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope2);

                        if ((PtSlope2 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                            (PtSlope2 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                          if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                            // < : Out of tol. rising.
                            // >: Out Of tol. falling.
                            // Unknown shape.
                          } else {
                            // within range.
                            Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope2 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[4]);
                            if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                              // < : Out of tol. rising.
                              // >: Out Of tol. falling.
                              // Unknown shape.
                            } else {
                              // OK, noise confirmed.
                              /*
                               noise
                               * *
                               *  * **

                               */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                              if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                                APASlotPcDebugSnsDtFilterDebug1 = 10;
                              }
#endif

                              pObjPtStatus->Bits.bIsNoise = TRUE;
                            }
                          }
                        }
                      }
                    } else {
                      // within range.
                      // OK, noise confirmed.
                      /*
                       *
                       *   **
                       */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                      if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                        APASlotPcDebugSnsDtFilterDebug1 = 10;
                      }
#endif

                      pObjPtStatus->Bits.bIsNoise = TRUE;
                    }
                  }
                } else {
                  if (CheckedPtIndex < (ObjPtNum - 3)) {

                    if (SnsDtdObjDisBuf[CheckedPtIndex] < (SnsDtdObjDisBuf[CheckedPtIndex + 3] - TolDis3)) {
                      if (CheckedPtIndex > 1) {
                        if ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                            (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {

                          PtSlope1 =
                              APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 1]].CarPos.Coordinate,
                                                          pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                                          SnsDtdObjDisBuf[CheckedPtIndex + 1],
                                                          SnsDtdObjDisBuf[CheckedPtIndex - 1]);
                          if ((PtSlope1 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                              (PtSlope1 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {

                            Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2]);
                            if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                              // < : Out of tol. rising.
                              // >: Out Of tol. falling.
                              // Unknown shape.
                            } else {
                              // within range.
                              PtSlope2 = APASlotProcCalTwoObjPtSlope(
                                  pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 3]].CarPos.Coordinate,
                                  pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 1]].CarPos.Coordinate,
                                  SnsDtdObjDisBuf[CheckedPtIndex + 3],
                                  SnsDtdObjDisBuf[CheckedPtIndex + 1]);
                              if ((PtSlope2 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                                  (PtSlope2 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {

                                Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope2);
                                if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                                  // < : Out of tol. rising.
                                  // >: Out Of tol. falling.
                                  // Unknown shape.
                                } else {
                                  // within range.
                                  // OK, noise confirmed.
                                  /*
                                   noise
                                   * *
                                   **  * *

                                   */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                                  if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                                    APASlotPcDebugSnsDtFilterDebug1 = 10;
                                  }
#endif

                                  pObjPtStatus->Bits.bIsNoise = TRUE;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        // CheckPtIndex == 1:
                        if (CheckedPtIndex < (ObjPtNum - 4)) {
                          if ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 3] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                              (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 3] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {

                            PtSlope1 =
                                APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 3]].CarPos.Coordinate,
                                                            pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 1]].CarPos.Coordinate,
                                                            SnsDtdObjDisBuf[CheckedPtIndex + 3],
                                                            SnsDtdObjDisBuf[CheckedPtIndex + 1]);
                            if ((PtSlope1 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                                (PtSlope1 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
                              Slope1 =
                                  ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex + 3]);

                              if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                                // < : Out of tol. rising.
                                // >: Out Of tol. falling.
                                // Unknown shape.
                              } else {
                                // within range.
                                PtSlope2 = APASlotProcCalTwoObjPtSlope(
                                    pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 1]].CarPos.Coordinate,
                                    pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                    SnsDtdObjDisBuf[CheckedPtIndex + 1],
                                    SnsDtdObjDisBuf[CheckedPtIndex - 1]);
                                if ((PtSlope2 < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                                    (PtSlope2 > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {

                                  Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope2);
                                  if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                                    // < : Out of tol. rising.
                                    // >: Out Of tol. falling.
                                    // Unknown shape.
                                  } else {
                                    // within range.
                                    // OK, noise confirmed.
                                    /*
                                     noise
                                     * *
                                     *  * **

                                     */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                                    if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                                      APASlotPcDebugSnsDtFilterDebug1 = 10;
                                    }
#endif

                                    pObjPtStatus->Bits.bIsNoise = TRUE;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          // Shape can not be confirmed.
                          // Noise ??
                        }
                      }
                    } else {
                      // unknow shape.
                      /*
                       *  **
                       **  *  ***
                       */
                    }
                  } else {
                    // It is hard to check the noise
                    // ??
                  }
                }
              } else {
                // unknow shape
                // Not a noise ??
                /*
                 |checked point
                 **
                 ****

                 */
              }
            }
          } else {
            // within tol
            // Not a noise
            /*      | check point
             ***
             **   ***
             */
          }
        } else {
          // Checked Point Index == ObjPtNum - 2
          Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex] -
                    (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 1]);
          if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
            // < : Out of tol. rising.
            // >: Out Of tol. falling.
            PtSlope1 = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex + 1]].CarPos.Coordinate,
                                                   pAPASnsDtdObjPtBuf->ObjPtBuf[SnsDtdObjDisIndexBuf[CheckedPtIndex - 1]].CarPos.Coordinate,
                                                   SnsDtdObjDisBuf[CheckedPtIndex + 1],
                                                   SnsDtdObjDisBuf[CheckedPtIndex - 1]);
            Slope1   = ((APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 1]);
            if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope) ||
                (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 1] > APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
                (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 1] < -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) ||
                (PtSlope1 > APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) || (PtSlope1 < -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) {
              // < : Out of tol. rising.
              // >: Out Of tol. falling.
              // unknown shape.
              /*
               **               * *
               ***    -----  or  ***  - --

               */
              if ((CheckedPtIndex > 2) && (SnsDtdObjDisBuf[CheckedPtIndex] < (SnsDtdObjDisBuf[CheckedPtIndex - 1] - TolDis3))) {
                if (((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                     (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope)) &&
                    ((SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] < APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope) &&
                     (SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3] > -APACal.APASlotSnsDtdObjDisFilterObjAllowedMaxSlope))) {

                  Slope1 = ((APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 2] -
                            (APA_SLOT_PT_SLOPE_CAL_TYPE)SnsDtdObjDisPtSlopeBuf[CheckedPtIndex - 3]);
                  if ((Slope1 < (-TolSlope)) || (Slope1 > TolSlope)) {
                    // < : Out of tol. rising.
                    // >: Out Of tol. falling.
                    // unknown shape.
                  } else {
                    // within tol
                    j = SnsDtdObjDisIndexBuf[CheckedPtIndex];
                    k = SnsDtdObjDisIndexBuf[CheckedPtIndex + 1];
                    if (j < (k - APACal.APASlotSnsDtdObjDisFilterObjTailCheckNoiseAllowedMinNoObjDtdBetTwoPt)) {
                      /*
                       noise confirmed
                       |
                       * *
                       ***  - --

                       */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                      if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                        APASlotPcDebugSnsDtFilterDebug1 = 10;
                      }
#endif

                      pObjPtStatus->Bits.bIsNoise = TRUE;
                    } else {
                      if (k < (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 3)) {
                        Dis1 = APASlotProcCalTwoPtApproximateDisInt(pAPASnsDtdObjPtBuf->ObjPtBuf[j].CarPos.Coordinate,
                                                                    pAPASnsDtdObjPtBuf->ObjPtBuf[k].CarPos.Coordinate);
                        if (Dis1 < APACal.APASlotSnsDtdObjDisFilterAllowedToRemoveTwoPointsMaxDis) {
                          // Noise confirmed. Checked Pt Index and Checked Pt Index - 1 are all both noise.
                          /*
                           **
                           ***    -----
                           */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

                          if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                            APASlotPcDebugSnsDtFilterDebug1 = 10;
                          }
#endif

                          pObjPtStatus->Bits.bIsNoise = TRUE;
                        }
                      }
                    }
                  }
                }
              }

            } else {
              // within range.
              // OK, noise confirmed.
              /*
               *
               **   *
               */
#ifdef APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_FILTER

              if (SnsDtdObjDisBuf[CheckedPtIndex] != APA_SLOT_SUPPORT_PC_DEBUG_SNS_DT_NOISE_DIS) {
                APASlotPcDebugSnsDtFilterDebug1 = 10;
              }
#endif

              pObjPtStatus->Bits.bIsNoise = TRUE;
            }
          } else {
            // Within tol
            // OK, not a noise.
          }
        }
      }
    } else {
      // It is hard to determine a noise.
    }
  }
}
/*************************************************************************************************************************************************
 ** Syntax :  APA_ENUM_TYPE APASlotProcSaveSnsDtdObjDisToFilterBuf(
 APA_DISTANCE_TYPE SnsDtdObjDis, APA_DISTANCE_TYPE SnsDtdSmallObjDis,
 APA_ENUM_TYPE SnsIndex, APA_ENUM_TYPE CalObjPtSnsIndex,
 APACarCoordinateDataCalFloatType *pCurCarPos,
 APA_INDEX_TYPE VehSpdIndex, APASlotObjPointType ObjPtToBeSavedBuf[2],
 BOOLEAN bAPACarIsRunningBackwards) **
 **                                                                                                                                              **
 ** Service ID:   : NO.4                                                                                                                           **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

APA_ENUM_TYPE APASlotProcSaveSnsDtdObjDisToFilterBuf(APA_DISTANCE_TYPE SnsDtdObjDis,
                                                     APA_DISTANCE_TYPE SnsDtdSmallObjDis,
                                                     APA_ENUM_TYPE SnsIndex,
                                                     APA_ENUM_TYPE CalObjPtSnsIndex,
                                                     APACarCoordinateDataCalFloatType *pCurCarPos,
                                                     APA_INDEX_TYPE VehSpdIndex,
                                                     APASlotObjPointType ObjPtToBeSavedBuf[2],
                                                     BOOLEAN bAPACarIsRunningBackwards,
                                                     uint8 CurCarSpeed) {
  // Input Par:
  // SnsDtdObjDis: APA Sensor detected object distance, if SnsDtdObjDis < 0, it means a small obj.
  //
  // pCurCarPos: current car position.
  // VehSpd: current car speed.
  //
  // Output Par:
  // ObjPtToBeSavedBuf: Object Point which need to be saved to the Object Buffer outside this function.


  APACoordinateDataCalFloatType CarPos1;
  APASlotCoordinateDataCalFloatType SlotPt;

  APA_DISTANCE_TYPE Dis1;
  BOOLEAN bFlag, bObjProfileConfirmed, bMayBeACurb;
  APA_ENUM_TYPE ObjPtCnt, ObjIndex, ObjIndex2, i, j, k;
  APASlotSnsDtdObjPtBufType *pAPASnsDtdObjPtBuf;
  APA_INDEX_TYPE CurPtIndex, StartPtIndex, StartPtIndex2, MidPtIndex, MidPtIndex2, EndPtIndex, CheckedPtNum;
  APA_DISTANCE_TYPE SnsDtdObjDisBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE];
  APA_SLOT_PT_SLOPE_TYPE SnsDtdObjDisPtSlopeBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE];
  APA_INDEX_TYPE SnsDtdObjDisIndexBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE];
  APA_ENUM_TYPE NoObjDisIndex1, NoObjDisIndex2, PrevObjIndex, BigObjPtNum, BigObjPtIndex, SmallObjPtIndex;
  APA_SLOT_PT_SLOPE_TYPE PtSlope1, PtSlope2;
  APA_SLOT_PT_SLOPE_CAL_TYPE Slope1;
  APA_INDEX_TYPE RemovedPtIndex;

  pAPASnsDtdObjPtBuf = &APASnsDtdObjPtBuf[SnsIndex];

  ObjPtCnt = pAPASnsDtdObjPtBuf->WrIndex;
  if (ObjPtCnt > (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1)) {
    // ?? data error ??
    ObjPtCnt = (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1);
  }

  // save the current point into the buf.
  // search the cur pos.
  // Just use y to check where should the current object being inserted to


  ObjIndex   = ObjPtCnt;
  CurPtIndex = 0;
  if (ObjIndex == 0) {
  } else {
    bFlag = TRUE;
    while (ObjIndex > 0) {
      ObjIndex--;
      if (pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex].CarPos.Coordinate.y <= pCurCarPos->Coordinate.y) {
        // OK, Insert current car pos into
        ObjIndex++;
        bFlag = FALSE;
      } else {
        if (ObjIndex == 0) {
          bFlag = FALSE;
        }
      }
      if (bFlag == FALSE) {
        ObjIndex2 = ObjPtCnt;
        while (ObjIndex2 > ObjIndex) {
          APATrajCalCopyMemory((UCHAR *)(&(pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex2])),
                               (UCHAR *)(&(pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex2 - 1])),
                               sizeof(APASlotSnsDtdObjPointType));
          ObjIndex2--;
        }
        CurPtIndex = ObjIndex;
        break;
      }
    }
  }

  pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].CarPos.Coordinate.x     = (APA_DISTANCE_TYPE)(pCurCarPos->Coordinate.x);
  pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].CarPos.Coordinate.y     = (APA_DISTANCE_TYPE)(pCurCarPos->Coordinate.y);
  pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].CarPos.CarAng           = (APA_ANGLE_TYPE)(pCurCarPos->CarAng);
  pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].BigObjDis               = SnsDtdObjDis;
  pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].SmallObjDis             = SnsDtdSmallObjDis;
  pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].BigObjPtStatus.Status   = 0;
  pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].SmallObjPtStatus.Status = 0;
  pAPASnsDtdObjPtBuf->ObjPtBuf[CurPtIndex].CarSpeed                = CurCarSpeed;

  ObjPtCnt++;


  pAPASnsDtdObjPtBuf->WrIndex = ObjPtCnt;
    
    
  if (ObjPtCnt < (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE)) {

    return 0;
    // return 0;  //ethan
  }

  RemovedPtIndex = APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - APACal.APASlotSnsDtdObjDisFilterBufSize[VehSpdIndex];
  //(buffer size 10 7 6 5 5    according to different spped choose different point number)
  StartPtIndex = RemovedPtIndex;
  if (bAPACarIsRunningBackwards == FALSE) {
    // car drv fw.

    if (CurPtIndex < (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1)) {
      pAPASnsDtdObjPtBuf->RemovedPtIndex = 0;

      return 0;
      // return 0;  //ethan
    }
    if (pAPASnsDtdObjPtBuf->RemovedPtIndex >= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1)) {
      // ?? Data error ??
      // code should never reached.
      pAPASnsDtdObjPtBuf->RemovedPtIndex = RemovedPtIndex;
    }
  } else {
    // car drv bk.
    if (CurPtIndex > 0) {
      return 0;
      // return 0;  //ethan
    }
    pAPASnsDtdObjPtBuf->RemovedPtIndex = (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1);
  }

  if ((CurPtIndex == (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1)) && (bAPACarIsRunningBackwards == FALSE)) {
    // car is drving fw
    // Check if the obj shape is rising or falling
    // 1. check rising shape.
    // 10 points and drive forward do the first filter;
    bObjProfileConfirmed = APASlotProcCheckObjPtInFilterBufObjProfile(
        pAPASnsDtdObjPtBuf,
        (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1),
        (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - APACal.APASlotSnsDtdObjDisFilterFillRisingEdgeAllowedMinObjPtIndex[VehSpdIndex]),
        VehSpdIndex,
        0);
    // check rising edge ,APASlotSnsDtdObjDisFilterFillRisingEdgeAllowedMinObjPtIndex 0 2 3 4
    if (bObjProfileConfirmed == FALSE) {
      bObjProfileConfirmed = APASlotProcCheckObjPtInFilterBufObjProfile(
          pAPASnsDtdObjPtBuf,
          APACal.APASlotSnsDtdObjDisFilterFillFallingEdgeAllowedMinObjPtIndex[VehSpdIndex],
          (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - APACal.APASlotSnsDtdObjDisFilterFillFallingEdgeAllowedMinObjPtIndex[VehSpdIndex]),
          VehSpdIndex,
          1);
    }
    // check falling edge, APASlotSnsDtdObjDisFilterFillFallingEdgeAllowedMinObjPtIndex 0 2 3 4 4
    if (bObjProfileConfirmed == FALSE) {
      bObjProfileConfirmed = APASlotProcCheckObjPtInFilterBufObjProfile(
          pAPASnsDtdObjPtBuf, APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1, APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE, VehSpdIndex, 2);
    }
    if (bObjProfileConfirmed == FALSE) {
      bObjProfileConfirmed = APASlotProcCheckObjPtInFilterBufObjProfile(
          pAPASnsDtdObjPtBuf, APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1, APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE, VehSpdIndex, 3);
    } else {
      bObjProfileConfirmed = APASlotProcCheckObjPtInFilterBufObjProfile(
          pAPASnsDtdObjPtBuf, APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1, APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE, VehSpdIndex, 4);
    }
  }

  // get the object pt dis

  if (bAPACarIsRunningBackwards == FALSE) {
    // drv fw.
    if (RemovedPtIndex <= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2)) {
      MidPtIndex = (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2);
    } else {
      MidPtIndex = RemovedPtIndex;
    }
  } else {
    // drv bk.
    MidPtIndex     = (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE / 2);
    RemovedPtIndex = APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1;
  }

  ObjIndex2     = 0;
  CheckedPtNum  = 0;
  StartPtIndex2 = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  MidPtIndex2   = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  EndPtIndex    = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  if ((StartPtIndex < pAPASnsDtdObjPtBuf->RemovedPtIndex) &&
      (pAPASnsDtdObjPtBuf->RemovedPtIndex != (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1))) {
    StartPtIndex = pAPASnsDtdObjPtBuf->RemovedPtIndex;
  }
  for (ObjIndex = 0; ObjIndex < ObjPtCnt; ObjIndex++) {
    Dis1 = APASlotProcGetObjPtInFilterBuf(pAPASnsDtdObjPtBuf, ObjIndex, 0);
    if (Dis1 != NO_OBJ_DISTANCE) {
      SnsDtdObjDisBuf[CheckedPtNum]      = Dis1;
      SnsDtdObjDisIndexBuf[CheckedPtNum] = ObjIndex;
      if (CheckedPtNum > 0) {
        ObjIndex2 = CheckedPtNum - 1;

        SnsDtdObjDisPtSlopeBuf[ObjIndex2] = APASlotProcCalTwoObjPtSlope(pAPASnsDtdObjPtBuf->ObjPtBuf[CheckedPtNum].CarPos.Coordinate,
                                                                        pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex2].CarPos.Coordinate,
                                                                        SnsDtdObjDisBuf[CheckedPtNum],
                                                                        SnsDtdObjDisBuf[ObjIndex2]);
      }
      if (ObjIndex == StartPtIndex) {
        StartPtIndex2 = CheckedPtNum;
      }
      if (ObjIndex == MidPtIndex) {
        MidPtIndex2 = CheckedPtNum;
      } else if (ObjIndex == (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1)) {
        EndPtIndex = CheckedPtNum;
      }
      CheckedPtNum++;
    }
  }

  if (CheckedPtNum > 0) {
    if (EndPtIndex != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
      APASlotProcCheckObjPtInFilterBufIsFlatOrRisingOrFalling(
          pAPASnsDtdObjPtBuf,
          SnsDtdObjDisBuf,
          SnsDtdObjDisPtSlopeBuf,
          SnsDtdObjDisIndexBuf,
          EndPtIndex,
          CheckedPtNum,
          VehSpdIndex,
          &(pAPASnsDtdObjPtBuf->ObjPtBuf[APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1].BigObjPtStatus));
    }

    for (ObjIndex = 0; ObjIndex < 3; ObjIndex++) {
      if (ObjIndex == 1) {
        // Check the start point.
        if ((MidPtIndex2 > StartPtIndex2) && (StartPtIndex2 != INVALID_APA_SLOT_BUFFER_VALUE_INDEX)) {
          MidPtIndex2 = StartPtIndex2;
          MidPtIndex  = StartPtIndex;
        } else {
          break;
        }
      } else if (ObjIndex == 2) {
        StartPtIndex2++;
        StartPtIndex++;

        if ((MidPtIndex2 > (StartPtIndex2)) && ((StartPtIndex2) < (CheckedPtNum - 1)) && (StartPtIndex == SnsDtdObjDisIndexBuf[StartPtIndex2])) {
          MidPtIndex2 = StartPtIndex2;
          MidPtIndex  = StartPtIndex;
        } else {
          break;
        }
      }
      if (MidPtIndex2 != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        Dis1        = MATH_ABS(pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].BigObjDis);
        bFlag       = FALSE;
        bMayBeACurb = FALSE;
        if (SnsDtdObjDisBuf[MidPtIndex2] == Dis1) {
          // Big obj.
          APASlotProcCheckObjPtInFilterBufIsFlatOrRisingOrFalling(pAPASnsDtdObjPtBuf,
                                                                  SnsDtdObjDisBuf,
                                                                  SnsDtdObjDisPtSlopeBuf,
                                                                  SnsDtdObjDisIndexBuf,
                                                                  MidPtIndex2,
                                                                  CheckedPtNum,
                                                                  VehSpdIndex,
                                                                  &(pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].BigObjPtStatus));
          if (pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].BigObjPtStatus.Bits.bIsNoise == FALSE) {
            // Not a noise.
            bFlag = TRUE;
            if (pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].BigObjDis > APACal.APASlotSnsDtdObjDisFilterFlatObjTolDevidedObjDis) {
              // regarded as a curb.
              // check if it is an obj edge.
              if (pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].SmallObjPtStatus.Bits.bIsObjProfileConfirmed == TRUE) {
                SnsDtdObjDisBuf[MidPtIndex2] = pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].SmallObjDis;
                bFlag                        = FALSE;
                bMayBeACurb                  = TRUE;
              }
            }
          } else {
            // check small obj.
            if (pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].SmallObjDis != NO_OBJ_DISTANCE) {
              SnsDtdObjDisBuf[MidPtIndex2] = pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].SmallObjDis;
            } else {
              // no need to check small obj.
              bFlag = TRUE;
            }
          }
        } else {
          // small obj
        }

        if (bFlag == FALSE) {
          // check small obj.
          // APASlotProcCheckObjPtInFilterBufIsFlatOrRisingOrFalling(pAPASnsDtdObjPtBuf,
          //                                                         SnsDtdObjDisBuf,
          //                                                         SnsDtdObjDisPtSlopeBuf,
          //                                                         SnsDtdObjDisIndexBuf,
          //                                                         MidPtIndex2,
          //                                                         CheckedPtNum,
          //                                                         VehSpdIndex,
          //                                                         &(pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].SmallObjPtStatus));
          if ((bMayBeACurb == TRUE) && (pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].SmallObjPtStatus.Bits.bIsNoise == FALSE) &&
              ((pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].SmallObjPtStatus.Bits.bIsFallingPt == TRUE) ||
               (pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].SmallObjPtStatus.Bits.bIsFallingPt == TRUE) ||
               (pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].SmallObjPtStatus.Bits.bIsRisingPt == TRUE))) {
            // Risiing or falling shape is confirmed.
            i = 0; // big obj num
            j = 1; // small obj num

            for (k = MidPtIndex - 1; k >= 0; k--) {
              if ((pAPASnsDtdObjPtBuf->ObjPtBuf[k].BigObjPtStatus.Bits.bIsNoise == FALSE) &&
                  (pAPASnsDtdObjPtBuf->ObjPtBuf[k].BigObjPtStatus.Bits.bIsObjProfileConfirmed == TRUE) &&
                  (pAPASnsDtdObjPtBuf->ObjPtBuf[k].BigObjDis < APACal.APASlotSnsDtdObjDisFilterFlatObjTolDevidedObjDis)) {
                // Big obj confirmed.
                i++;
              } else {
                j++;
              }
            }
            if ((i >= APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeAllowedMinBigObjNum[VehSpdIndex]) &&
                (j <= APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeAllowedSmallObjNum[VehSpdIndex])) {
              // OK, regarded as a valid obj rising or falling point.
              // regard the big obj pt as a noise
              /*

               *****
               * <- ok falling shape. (small obj width)
               * <- ok falling shape. (small obj width)

               * * ******
               |
               Big obj width.
               */
              pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].BigObjPtStatus.Bits.bIsNoise = TRUE;
            } else {
              i = 0; // big obj num
              j = 1; // small obj num

              for (k = MidPtIndex + 1; k < APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE; k++) {
                if ((pAPASnsDtdObjPtBuf->ObjPtBuf[k].BigObjPtStatus.Bits.bIsNoise == FALSE) &&
                    (pAPASnsDtdObjPtBuf->ObjPtBuf[k].BigObjPtStatus.Bits.bIsObjProfileConfirmed == TRUE) &&
                    (pAPASnsDtdObjPtBuf->ObjPtBuf[k].BigObjDis < APACal.APASlotSnsDtdObjDisFilterFlatObjTolDevidedObjDis)) {
                  // Big obj confirmed.
                  i++;
                } else {
                  j++;
                }
              }
              if ((i >= APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeAllowedMinBigObjNum[VehSpdIndex]) &&
                  (j <= APACal.APASlotSnsDtdObjDisFilterFillRisingAndFallingEdgeAllowedSmallObjNum[VehSpdIndex])) {
                // OK, regarded as a valid obj rising or falling point.
                // regard the big obj pt as a noise
                /*

                 *****
                 * <- ok falling shape. (small obj width)
                 * <- ok falling shape. (small obj width)

                 * * **** * *
                 |
                 Big obj width.
                 */
                pAPASnsDtdObjPtBuf->ObjPtBuf[MidPtIndex].BigObjPtStatus.Bits.bIsNoise = TRUE;
              }
            }
          }
        }
      }
    }
  }
  // Move the point to the Object Point Buffer

  ObjPtCnt = 0;
  ObjIndex = pAPASnsDtdObjPtBuf->RemovedPtIndex;

  if (ObjIndex <= RemovedPtIndex) {
    while (ObjPtCnt < 2) {
      APASlotProcGetSnsDtdObjPtFromFilterBuf(pAPASnsDtdObjPtBuf, ObjIndex, CalObjPtSnsIndex, &ObjPtToBeSavedBuf[ObjPtCnt]);
      ObjPtCnt++;
      if ((ObjIndex < RemovedPtIndex) && (ObjIndex < (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1)) && (ObjPtCnt < 2)) {
        ObjIndex++;
      } else {
        break;
      }
    }
  } else {
    if (ObjIndex > 0) {
      ObjIndex--;
    }
  }
  pAPASnsDtdObjPtBuf->RemovedPtIndex = ObjIndex;

  if (bAPACarIsRunningBackwards == FALSE) {
    // remove the head object.
    for (ObjIndex2 = 0; ObjIndex2 < APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE - 1; ObjIndex2++) {
      APATrajCalCopyMemory((UCHAR *)(&(pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex2])),
                           (UCHAR *)(&(pAPASnsDtdObjPtBuf->ObjPtBuf[ObjIndex2 + 1])),
                           sizeof(APASlotSnsDtdObjPointType));
    }
  } else {
    // remove the tail object.
  }
  if (APASlotSnsDtdObjLoopCnt < (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE + 4)) {

    return 0;
    // return 0;  //ethan
  }

  return ObjPtCnt;
}

/*************************************************************************************************************************************************
 ** Syntax :  void USS(void)                                                                                                                     **
 **                                                                                                                                              **
 ** Service ID:   : 5                                                                                                                          **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

void APASlotProcSaveObjPointToSlotBuf(APA_ENUM_TYPE SnsIndex, APASlotObjPointType *pObjPt
                                      // APA_SPEED_CAL_FLOAT_TYPE VehSpd,
                                      // BOOLEAN bAPACarIsRunningBackwards
) {
  // Input Par:
  // SnsDtdObjDis: APA Sensor detected object distance
  // pCurCarPos: current car position.
  // VehSpd: current car speed.
  //
  // Output Par:
  // pObjPt: Object Point which need to be saved to the Object Buffer outside this function.

  APA_ENUM_TYPE Index, ObjIndex2, ObjPtCnt, WrIndex, ObjTypeTemp, Index2;
  APASlotOutlineCoordinateDataType *pSlot;
  APA_DISTANCE_TYPE L, LTemp;
  UCHAR ObjIsBigEnough1, ObjIsBigEnough2;

  pSlot = &USSPar.Slot[SnsIndex].SlotOutline.Lane;
  // Insert the current object point to the buffer.
  // WrIndex  = pSlot->WrIndex;
  ObjPtCnt = pSlot->ObjPtCnt;
  if (ObjPtCnt <= 0) {
    // WrIndex = 0;
    /*			APATrajCalCopyMemory((UCHAR *)(&(APAObjInfo.SnsObjPtBuf[SnsIndex].ObjPtBuf[WrIndex])),
     (UCHAR *)(pObjPt), sizeof(APASlotObjPointType));*/

    pSlot->CarCenterPoint[0].x = pObjPt->CarPos.Coordinate.x;
    pSlot->CarCenterPoint[0].y = pObjPt->CarPos.Coordinate.y;
    pSlot->CarAng[0]           = pObjPt->CarPos.CarAng;
    pSlot->DisFromCarToObj[0]  = pObjPt->ObjDis;
    pSlot->ObjPt[0].x          = pObjPt->Pt.x;
    pSlot->ObjPt[0].y          = pObjPt->Pt.y;
    // pSlot->ObjType[0] = pObjPt->ObjType;
    pSlot->bObjIsBigEnough[0] = 0;
    pSlot->CarSpeed[0]         = pObjPt->CarSpeed;

    ObjPtCnt                  = 1;
  } else {
    // Check where should the new object point be inserted.
    if (ObjPtCnt >= APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
      ObjPtCnt = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM;
    }
    WrIndex = ObjPtCnt - 1;
    if (pSlot->CarCenterPoint[WrIndex].y == pObjPt->CarPos.Coordinate.y) {
      // Ok, the car is static.
      if (APASlotVehicleStaticTimer >= APA_SLOT_VEHICLE_STATIC_UPDATE_SLOT_PT_TIME) {
        // Vehicle is static now.
        // search back and remove the point which is within the APA Sns FOV.
        L = pObjPt->CarPos.Coordinate.y - APACal.APASlotHFOVWidthBySeg[0] / 4; // 5cm
        for (ObjIndex2 = WrIndex - 1; ObjIndex2 > 0; ObjIndex2--) {
          if (pSlot->CarCenterPoint[ObjIndex2].y <= L) {
            // Ok, Out of FOV scope just remove it.
            break;
          }
        }
        WrIndex = ObjIndex2 + 1;
      } else {
        WrIndex++;
      }
    } else if (pSlot->CarCenterPoint[WrIndex].y < pObjPt->CarPos.Coordinate.y) {
      // Ok, the car pos is in increasing sequence.
      WrIndex++;
    } else if (WrIndex > 0) {
      // The car is driving backwards now.
      for (ObjIndex2 = WrIndex - 1; ObjIndex2 >= 0; ObjIndex2--) {
        if (pSlot->CarCenterPoint[ObjIndex2].y <= pObjPt->CarPos.Coordinate.y) {
          // Ok, the car pos is in increasing sequence.
          break;
        }
      }
      if (ObjIndex2 <= 0) {
        WrIndex = 0;
      } else {
        if (MATH_FABS(pSlot->CarAng[ObjIndex2] - pObjPt->CarPos.CarAng) > APACal.APASlotMaxDeltaCarAngBetObjPt) {
          // Invalid car angle
          // It may cause data error.
          WrIndex = 0;
        } else {
          WrIndex = ObjIndex2 + 1;
        }
      }
      Index = USSPar.Slot[SnsIndex].SlotNum;
      while (Index > 0) {
        Index--;
        if (WrIndex > USSPar.Slot[SnsIndex].SlotPar[Index].SlotEndIndex) {
          // OK, Just remove the previous point.
        } else {
          if (WrIndex >= USSPar.Slot[SnsIndex].SlotPar[Index].SlotStartIndex) {
            // Check if it is necessory to readjust the slot star or end point pos.

#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ

            // slot end point position readjustment
            if ((USSPar.Slot[SnsIndex].SlotPar[Index].bSlotHeadCompensated == TRUE)) {
              if (USSPar.Slot[SnsIndex].SlotPar[Index].SlotDepth == NO_OBJ_DISTANCE) {
                CarToObjDisTemp = NO_OBJ_DISTANCE;
              } else {
                CarToObjDisTemp =
                    USSPar.Slot[SnsIndex].SlotPar[Index].SlotDepth + USSPar.Slot[SnsIndex].SlotPar[Index].DisCarToObj2ByPassingSlot;
              }
              for (n = USSPar.Slot[SnsIndex].SlotPar[Index].SlotEndIndex - 1; n > USSPar.Slot[SnsIndex].SlotPar[Index].SlotStartIndex; n--) {
                if ( //(pSlot->DisFromCarToObj[n] == NO_OBJ_DISTANCE) ||
                    (pSlot->DisFromCarToObj[n] >= CarToObjDisTemp)) {
                  break;
                }
              }

              n++;

              CompensateDis = (APA_DISTANCE_CAL_FLOAT_TYPE)(USSPar.Slot[SnsIndex].SlotPar[Index].APASlotDetectionCompensateLengthHead);

              for (; n <= USSPar.Slot[SnsIndex].SlotPar[Index].SlotEndIndex; n++) {

                DeltaDis         = (CompensateDis)*MATH_SIN(pSlot->CarAng[n]);
                PtDeltaDisTemp.x = (APA_DISTANCE_TYPE)DeltaDis;
                DeltaDis         = (CompensateDis)*MATH_COS(pSlot->CarAng[n]);
                PtDeltaDisTemp.y = (APA_DISTANCE_TYPE)DeltaDis;

                pSlot->CarCenterPoint[n].x += (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
                pSlot->CarCenterPoint[n].y -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.y;
                pSlot->ObjPt[n].x += (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
                pSlot->ObjPt[n].y -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.y;
                pSlot->CarSpeed[t]         = ;
              }
              WrIndex = ObjPtCnt - 1;
              if (pSlot->CarCenterPoint[WrIndex].y <= pObjPt->CarPos.Coordinate.y) {
                // Ok, the car pos is in increasing sequence.
              } else if (WrIndex > 0) {
                for (ObjIndex2 = WrIndex - 1; ObjIndex2 >= 0; ObjIndex2--) {
                  if (pSlot->CarCenterPoint[ObjIndex2].y <= pObjPt->CarPos.Coordinate.y) {
                    // Ok, the car pos is in increasing sequence.
                    break;
                  }
                }
                WrIndex = ObjIndex2;
              }
              USSPar.Slot[SnsIndex].SlotPar[Index].bSlotHeadCompensated = FALSE;
            }
#endif
            Index2 = USSPar.Slot[SnsIndex].SlotNum;
            while (Index2 > 0) {
              Index2--;
              USSPar.Slot[SnsIndex].SlotPar[Index2].TrajectoryCalRequestType = APAParkProcSlotFoundTrajCalReqWithoutCaled;
            }
            USSPar.Slot[SnsIndex].SlotNum--;
            // End 2012 03 26
          } else {

            USSPar.Slot[SnsIndex].SlotPar[Index].SlotEndIndex = WrIndex;

#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
            USSPar.Slot[SnsIndex].SlotPar[Index].bSlotHeadCompensated = FALSE;
            USSPar.Slot[SnsIndex].SlotPar[Index].bSlotTailCompensated = FALSE;
#endif
          }
        }
      }
#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
      Index     = USSPar.Slot[SnsIndex].SlotNum;
      ObjIndex2 = USSPar.Slot[SnsIndex].SlotPar[Index].SlotStartIndex;
      if (ObjIndex2 > 0) {
        ObjIndex2--; // The slot border start point index.
      }

      if ((Index < APA_SLOT_SUPPORT_MAX_SLOT_NUM) && (ObjIndex2 < ObjPtCnt)) {

        // slot start point position readjustment
        if ((USSPar.Slot[SnsIndex].SlotPar[Index].bSlotTailCompensated == TRUE)) {

          if (USSPar.Slot[SnsIndex].SlotPar[Index].SlotDepth == NO_OBJ_DISTANCE) {
            CarToObjDisTemp = NO_OBJ_DISTANCE;
          } else {
            CarToObjDisTemp = USSPar.Slot[SnsIndex].SlotPar[Index].SlotDepth + USSPar.Slot[SnsIndex].SlotPar[Index].DisCarToObj1ByPassingSlot;
          }
          for (n = USSPar.Slot[SnsIndex].SlotPar[Index].SlotStartIndex; n < USSPar.Slot[SnsIndex].SlotPar[Index].SlotEndIndex; n++) {
            if ( //(pSlot->DisFromCarToObj[n] == NO_OBJ_DISTANCE) ||
                (n >= ObjPtCnt) || (pSlot->DisFromCarToObj[n] >= CarToObjDisTemp)) {
              break;
            }
          }
          n--;
          if ((Index > 0) // More than one slot.
              && (ObjIndex2 <= USSPar.Slot[SnsIndex].SlotPar[Index - 1].SlotEndIndex)) {
            // The slot start point of the current slot is the same as the slot end point of
            // the previous slot. Just do not readjust the slot start point.
            ObjIndex2 = USSPar.Slot[SnsIndex].SlotPar[Index - 1].SlotEndIndex + 1;
          }
          bFlag = FALSE;
          for (; n >= ObjIndex2; n--) {
            CompensateDis = USSPar.Slot[SnsIndex].SlotPar[Index].APASlotDetectionCompensateLengthTail;

            DeltaDis         = ((APA_DISTANCE_CAL_FLOAT_TYPE)(CompensateDis)) * MATH_SIN(pSlot->CarAng[n]);
            PtDeltaDisTemp.x = (APA_DISTANCE_TYPE)DeltaDis;
            DeltaDis         = ((APA_DISTANCE_CAL_FLOAT_TYPE)(CompensateDis)) * MATH_COS(pSlot->CarAng[n]);
            PtDeltaDisTemp.y = (APA_DISTANCE_TYPE)DeltaDis;

            DeltaDis += pSlot->CarCenterPoint[n].y;
            if (DeltaDis > pObjPt->CarPos.Coordinate.y) {
              // readjust the slot tail
              bFlag = TRUE;
            } else if (bFlag == FALSE) {
              break;
            }
            pSlot->CarCenterPoint[n].x -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
            pSlot->CarCenterPoint[n].y = DeltaDis;

            pSlot->ObjPt[n].x -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
            pSlot->ObjPt[n].y += (APA_DISTANCE_TYPE)PtDeltaDisTemp.y;
            pSlot->CarSpeed[t]         = ;

            USSPar.Slot[SnsIndex].SlotPar[Index].bSlotTailCompensated = FALSE;
          }
          if (bFlag == TRUE) {
            WrIndex = ObjPtCnt - 1;
            if (pSlot->CarCenterPoint[WrIndex].y <= pObjPt->CarPos.Coordinate.y) {
              // Ok, the car pos is in increasing sequence.
            } else if (WrIndex > 0) {
              for (ObjIndex2 = WrIndex - 1; ObjIndex2 >= 0; ObjIndex2--) {
                if (pSlot->CarCenterPoint[ObjIndex2].y <= pObjPt->CarPos.Coordinate.y) {
                  // Ok, the car pos is in increasing sequence.
                  break;
                }
              }
              WrIndex = ObjIndex2;
            }
          }
        }
      }
#endif
    } else {
      WrIndex = 0;
    }

    // Check if there is space in the buffer to save the new object point.
    if (WrIndex < 0) {
      WrIndex = 0;
    } else if (WrIndex < APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
      // Buffer is not full, just save the current point.
    } else {
      // Buffer is full.
      // Actually the code will never reach, since the function
      // APASlotProcRemoveUselessObjPtFromSlotBuffer will make sure it will not happen.
      WrIndex = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM - 1;
    }

    // Searching down

#if 0
		ObjTypeTemp = pObjPt->ObjType;

		if(ObjTypeTemp == APA_SLOT_SIMPLE_OBJ_TYPE_ROUND) {
			// To make the round object near point to be round object.
			Index = WrIndex;
			while(Index > 0) {
				Index --;
				L = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[WrIndex],
						pSlot->CarCenterPoint[Index]);
				if(L > APACal.APASlotRoundObjPtSearchBackMaxDis) {
					break;
				}
				pSlot->ObjType[Index] = APA_SLOT_SIMPLE_OBJ_TYPE_ROUND;
			}
		}
#endif

    pSlot->CarCenterPoint[WrIndex].x = pObjPt->CarPos.Coordinate.x;
    pSlot->CarCenterPoint[WrIndex].y = pObjPt->CarPos.Coordinate.y;
    pSlot->CarAng[WrIndex]           = pObjPt->CarPos.CarAng;
    pSlot->DisFromCarToObj[WrIndex]  = pObjPt->ObjDis;
    pSlot->ObjPt[WrIndex].x          = pObjPt->Pt.x;
    pSlot->ObjPt[WrIndex].y          = pObjPt->Pt.y;
    pSlot->CarSpeed[WrIndex]         = pObjPt->CarSpeed;

    // pSlot->ObjType[WrIndex] = ObjTypeTemp;

    // Check if the slot start or end index is removed?

    ObjPtCnt = WrIndex + 1;
  }
  // pSlot->WrIndex  = WrIndex;
  pSlot->ObjPtCnt = ObjPtCnt;

}

void APASlotProcSaveObjPointToSlotBufRearSideSnsDectected(APA_ENUM_TYPE SnsIndex, APASlotObjPointType *pObjPtRSns
                                                          // APA_SPEED_CAL_FLOAT_TYPE VehSpd,
                                                          // BOOLEAN bAPACarIsRunningBackwards
) {
  // Input Par:
  // SnsDtdObjDis: APA Sensor detected object distance
  // pCurCarPos: current car position.
  // VehSpd: current car speed.
  //
  // Output Par:
  // pObjPtRSns: Object Point which need to be saved to the Object Buffer outside this function.

  APA_ENUM_TYPE Index, ObjIndex2, ObjPtCntRSns, WrIndexRSns, ObjTypeTemp, Index2;
  APASlotOutlineDtcdByRearSideSnsCoordinateDataType *pSlot;
  APA_DISTANCE_TYPE L, LTemp;
  UCHAR ObjIsBigEnough1, ObjIsBigEnough2;

  pSlot = &USSPar.Slot[SnsIndex].SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor;
  // Insert the current object point to the buffer.
  // WrIndexRSns  = pSlot->WrIndexRSns;
  ObjPtCntRSns = pSlot->ObjPtCntRSns;
  if (ObjPtCntRSns <= 0) {
    // WrIndexRSns = 0;
    /*			APATrajCalCopyMemory((UCHAR *)(&(APAObjInfo.SnsObjPtRSnsBuf[SnsIndex].ObjPtRSnsBuf[WrIndexRSns])),
     (UCHAR *)(pObjPtRSns), sizeof(APASlotObjPointType));*/

    pSlot->CarCenterPointRSns[0].x = pObjPtRSns->CarPos.Coordinate.x;
    pSlot->CarCenterPointRSns[0].y = pObjPtRSns->CarPos.Coordinate.y;
    pSlot->CarAngRSns[0]           = pObjPtRSns->CarPos.CarAng;
    pSlot->DisFromCarToObjRSns[0]  = pObjPtRSns->ObjDis;
    pSlot->ObjPtRSns[0].x          = pObjPtRSns->Pt.x;
    pSlot->ObjPtRSns[0].y          = pObjPtRSns->Pt.y;
    // pSlot->ObjType[0] = pObjPtRSns->ObjType;
    pSlot->bObjIsBigEnoughRSns[0] = 0;
    ObjPtCntRSns                  = 1;
    pSlot->CarSpeedRSns[0]         = pObjPtRSns->CarSpeed;

  } else {
    // Check where should the new object point be inserted.
    if (ObjPtCntRSns >= APA_SLOT_SUPPORT_REAR_SIDE_MAX_SAMPLE_POINT_NUM) {
      ObjPtCntRSns = APA_SLOT_SUPPORT_REAR_SIDE_MAX_SAMPLE_POINT_NUM;
    }
    WrIndexRSns = ObjPtCntRSns - 1;
    if (pSlot->CarCenterPointRSns[WrIndexRSns].y == pObjPtRSns->CarPos.Coordinate.y) {
      // Ok, the car is static.
      if (APASlotVehicleStaticTimer >= APA_SLOT_VEHICLE_STATIC_UPDATE_SLOT_PT_TIME) {
        // Vehicle is static now.
        // search back and remove the point which is within the APA Sns FOV.
        L = pObjPtRSns->CarPos.Coordinate.y - APACal.APASlotHFOVWidthBySeg[0] / 4; // 5cm
        for (ObjIndex2 = WrIndexRSns - 1; ObjIndex2 > 0; ObjIndex2--) {
          if (pSlot->CarCenterPointRSns[ObjIndex2].y <= L) {
            // Ok, Out of FOV scope just remove it.
            break;
          }
        }
        WrIndexRSns = ObjIndex2 + 1;
      } else {
        WrIndexRSns++;
      }
    } else if (pSlot->CarCenterPointRSns[WrIndexRSns].y < pObjPtRSns->CarPos.Coordinate.y) {
      // Ok, the car pos is in increasing sequence.
      WrIndexRSns++;
    } else if (WrIndexRSns > 0) {
      // The car is driving backwards now.
      for (ObjIndex2 = WrIndexRSns - 1; ObjIndex2 >= 0; ObjIndex2--) {
        if (pSlot->CarCenterPointRSns[ObjIndex2].y <= pObjPtRSns->CarPos.Coordinate.y) {
          // Ok, the car pos is in increasing sequence.
          break;
        }
      }
      if (ObjIndex2 <= 0) {
        WrIndexRSns = 0;
      } else {
        if (MATH_FABS(pSlot->CarAngRSns[ObjIndex2] - pObjPtRSns->CarPos.CarAng) > APACal.APASlotMaxDeltaCarAngBetObjPt) {
          // Invalid car angle
          // It may cause data error.
          WrIndexRSns = 0;
        } else {
          WrIndexRSns = ObjIndex2 + 1;
        }
      }
    } else {
      WrIndexRSns = 0;
    }
    // Check if there is space in the buffer to save the new object point.
    if (WrIndexRSns < 0) {
      WrIndexRSns = 0;
    } else if (WrIndexRSns < APA_SLOT_SUPPORT_REAR_SIDE_MAX_SAMPLE_POINT_NUM) {
      // Buffer is not full, just save the current point.
    } else {
      // Buffer is full.
      // Actually the code will never reach, since the function
      // APASlotProcRemoveUselessObjPtRSnsFromSlotBuffer will make sure it will not happen.
      WrIndexRSns = APA_SLOT_SUPPORT_REAR_SIDE_MAX_SAMPLE_POINT_NUM - 1;
    }

    pSlot->CarCenterPointRSns[WrIndexRSns].x = pObjPtRSns->CarPos.Coordinate.x;
    pSlot->CarCenterPointRSns[WrIndexRSns].y = pObjPtRSns->CarPos.Coordinate.y;
    pSlot->CarAngRSns[WrIndexRSns]           = pObjPtRSns->CarPos.CarAng;
    pSlot->DisFromCarToObjRSns[WrIndexRSns]  = pObjPtRSns->ObjDis;
    pSlot->ObjPtRSns[WrIndexRSns].x          = pObjPtRSns->Pt.x;
    pSlot->ObjPtRSns[WrIndexRSns].y          = pObjPtRSns->Pt.y;

    ObjPtCntRSns = WrIndexRSns + 1;
    pSlot->CarSpeedRSns[WrIndexRSns]                   = pObjPtRSns->CarSpeed;
  }
  pSlot->ObjPtCntRSns = ObjPtCntRSns;
}

#if 1
APA_ENUM_TYPE APASlotProcCheckSlotObjTypeParallelOrAngularCarTypeCheck(APA_ENUM_TYPE EndOfObj,
                                                                       APA_DISTANCE_TYPE ObjTotalWidth,
                                                                       APA_DISTANCE_TYPE FlatShapeWidth,
                                                                       APA_DISTANCE_TYPE RisingShapeWidth,
                                                                       APA_SLOT_PT_SLOPE_TYPE ObjAverageSlope,
                                                                       APA_SLOT_PT_SLOPE_TYPE StartPtSlope) {
  // EndOfObj = 1: End Of Obj is flat, check if it is parallel car.
  APA_ENUM_TYPE ObjType;
  APA_DISTANCE_TYPE MinFlatShapeWidth;

  // Obj width > 3.2m,
  // parallel vehicle.
  // Check flat width

  ObjType = APA_SLOT_OBJ_TYPE_UNKNOWN;

  if (EndOfObj == 1) {
    // End of obj is flat, it may be a parallel or angular car.
    MinFlatShapeWidth = APACal.APASlotObjTypeCheckRegardedAsAngularCarMinFlatShapeWidth1;
  } else {
    MinFlatShapeWidth = APACal.APASlotObjTypeCheckRegardedAsAngularCarMinFlatShapeWidth2;
  }
  if (FlatShapeWidth > MinFlatShapeWidth) {
    // flat shape > 1.5m
    if (ObjAverageSlope > (APACal.APASlotObjTypeCheckRegardedAsParallelCarMaxSlope)) {
      // > 7.6deg.
      if (RisingShapeWidth < APACal.APASlotObjTypeCheckAngularCarSmallRisingShapeMaxWidth) {
        // < 10cm,
        // the start point is also flat.
        if (ObjAverageSlope <= (APACal.APASlotObjTypeCheckRegardedAsAngularCarDevidedSlope1)) {
          // 7.6 ~ 11.3 deg.
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_10DEG_FLAT_SHAPE_AT_START;
        } else if (ObjAverageSlope <= (APACal.APASlotObjTypeCheckRegardedAsAngularCarDevidedSlope2)) {
          // 11.3 ~ 20deg
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_20DEG_FLAT_SHAPE_AT_START;
        } else if (ObjAverageSlope <= (APACal.APASlotObjTypeCheckRegardedAsAngularCarMaxSlope)) {
          // 20deg ~ 50deg.
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_30DEG_FLAT_SHAPE_AT_START;
        } else {
          // data error ??
          // return FALSE;
        }
      } else if (StartPtSlope < ObjAverageSlope) {
        // the objAverageSlope is great than 0.
        // start point slope is less than average slope.
        if (ObjAverageSlope <= (APACal.APASlotObjTypeCheckRegardedAsAngularCarDevidedSlope1)) {
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_10DEG_RISING_SHAPE_AT_START;
        } else if (ObjAverageSlope <= (APACal.APASlotObjTypeCheckRegardedAsAngularCarDevidedSlope2)) {
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_20DEG_RISING_SHAPE_AT_START;
        } else if (ObjAverageSlope <= (APACal.APASlotObjTypeCheckRegardedAsAngularCarMaxSlope)) {
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_30DEG_RISING_SHAPE_AT_START;
        } else {
          // data error ??
          // return FALSE;
        }
      } else {
        // data error ??
        // return FALSE;
      }
    } else if (ObjAverageSlope >= (-APACal.APASlotObjTypeCheckRegardedAsParallelCarMaxSlope)) {
      // -7.6 ~ 7.6 deg.
      // regarded as parallel vehicle shape.
      if (RisingShapeWidth < APACal.APASlotObjTypeCheckParallelCarSmallRisingShapeMaxWidth) { // 20cm
        // 0 ~ 20cm.
        ObjType = APA_SLOT_OBJ_TYPE_PARALLEL_CAR_WITH_SMALL_RISING_SHAPE;
      } else if (RisingShapeWidth < APACal.APASlotObjTypeCheckParallelCarNormalRisingShapeMaxWidth) { // 40cm,
        // 20 ~ 40cm.
        ObjType = APA_SLOT_OBJ_TYPE_PARALLEL_CAR_WITH_NORMAL_RISING_SHAPE;
      } else if (RisingShapeWidth < APACal.APASlotObjTypeCheckParallelCarBigRisingShapeMaxWidth) { // 60cm
        // 40 ~ 60cm.
        ObjType = APA_SLOT_OBJ_TYPE_PARALLEL_CAR_WITH_BIG_RISING_SHAPE;
      } else {
        // > 60cm,
        ObjType = APA_SLOT_OBJ_TYPE_PARALLEL_CAR_WITH_VERY_BIG_RISING_SHAPE;
      }
    } else {
      // regarded as a car with a small angle.
      // < -7.6 deg.
      if (RisingShapeWidth < APACal.APASlotObjTypeCheckAngularCarSmallRisingShapeMaxWidth) {
        // the start point is also flat. < 10cm
        if (ObjAverageSlope >= (-APACal.APASlotObjTypeCheckRegardedAsAngularCarDevidedSlope1)) {
          // - 7.6 ~ - 11.3 deg
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_10DEG_FLAT_SHAPE_AT_START;
        } else if (ObjAverageSlope >= (-APACal.APASlotObjTypeCheckRegardedAsAngularCarDevidedSlope2)) {
          // -11.3 deg - - 20deg.
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_20DEG_FLAT_SHAPE_AT_START;
        } else if (ObjAverageSlope >= (-APACal.APASlotObjTypeCheckRegardedAsAngularCarMaxSlope)) {
          // - 20deg - -55deg.
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_30DEG_FLAT_SHAPE_AT_START;
        } else {
          // data error ??
          // return FALSE;
        }
      } else if (StartPtSlope < ObjAverageSlope) {
        // the objAverageSlope is less than 0.
        // start point slope is big than average slope.
        if (ObjAverageSlope >= (-APACal.APASlotObjTypeCheckRegardedAsAngularCarDevidedSlope1)) {
          // - 7.6 ~ - 11.3 deg
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_10DEG_RISING_SHAPE_AT_START;
        } else if (ObjAverageSlope >= (-APACal.APASlotObjTypeCheckRegardedAsAngularCarDevidedSlope2)) {
          // -11.3 deg - - 20deg.
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_20DEG_RISING_SHAPE_AT_START;
        } else if (ObjAverageSlope >= (-APACal.APASlotObjTypeCheckRegardedAsAngularCarMaxSlope)) {
          // - 20deg - -55deg.
          ObjType = APA_SLOT_OBJ_TYPE_CAR_ANGULAR_30DEG_RISING_SHAPE_AT_START;
        } else {
          // data error ??
          // return FALSE;
        }
      } else {
        // data error ??
        // return FALSE;
      }
    }
  } else {
    // Flat shape is small. rising shape is big
    // Unknown ??
    if (ObjTotalWidth < APACal.APASlotObjTypeCheckRegardedAsPerpendicularCarMaxWidth2) {
      // check if it is per pendicular ?
      ObjType =
          APASlotProcCheckSlotObjTypePerpendicularCarTypeCheck(0, ObjTotalWidth, FlatShapeWidth, RisingShapeWidth, ObjAverageSlope, StartPtSlope);
    }
  }
  return ObjType;
}

APA_ENUM_TYPE APASlotProcCheckSlotObjTypePerpendicularCarTypeCheck(APA_ENUM_TYPE EndOfObj,
                                                                   APA_DISTANCE_TYPE ObjTotalWidth,
                                                                   APA_DISTANCE_TYPE FlatShapeWidth,
                                                                   APA_DISTANCE_TYPE RisingShapeWidth,
                                                                   APA_SLOT_PT_SLOPE_TYPE ObjAverageSlope,
                                                                   APA_SLOT_PT_SLOPE_TYPE StartPtSlope) {
  // EndOfObj = 1: end point is flat, check if it is per pendicular car.
  //          != 1: just check perpendicular,

  APA_DISTANCE_TYPE Dis1;
  APA_ENUM_TYPE ObjType;

  ObjType = APA_SLOT_OBJ_TYPE_UNKNOWN;
  if (EndOfObj == 1) {
    ObjType = APASlotProcCheckSlotObjTypeParallelOrAngularCarTypeCheck(
        EndOfObj, ObjTotalWidth, FlatShapeWidth, RisingShapeWidth, ObjAverageSlope, StartPtSlope);
  }
  if (ObjType == APA_SLOT_OBJ_TYPE_UNKNOWN) {

    // Vertical vehicle or with angle
    Dis1 = ObjTotalWidth / 100;
    if (Dis1 > 0) {
      Dis1 = FlatShapeWidth / Dis1;
      if (ObjTotalWidth < APACal.APASlotObjTypeCheckPerpendicularCarSmallWidth) {
        if (Dis1 < APACal.APASlotObjTypeCheckPerpendicularCarSmallFlatShapeMaxPercentage) {
          // a car with big angle.
          ObjType = APA_SLOT_OBJ_TYPE_PER_CAR_WITH_SMALL_FLAT_SMALL_WIDTH;
        } else if (Dis1 < APACal.APASlotObjTypeCheckPerpendicularCarNormalFlatShapeMaxPercentage) {
          // a car with round head.
          ObjType = APA_SLOT_OBJ_TYPE_PER_CAR_WITH_NORMAL_FLAT_SMALL_WIDTH;
        } else {
          // a car with flat head or rear of the car.
          ObjType = APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_SMALL_WIDTH;
        }
      } else if (ObjTotalWidth < APACal.APASlotObjTypeCheckPerpendicularCarNormalWidth) {
        if (Dis1 < APACal.APASlotObjTypeCheckPerpendicularCarSmallFlatShapeMaxPercentage) {
          // a car with big angle.
          ObjType = APA_SLOT_OBJ_TYPE_PER_CAR_WITH_SMALL_FLAT_NORMAL_WIDTH;
        } else if (Dis1 < APACal.APASlotObjTypeCheckPerpendicularCarNormalFlatShapeMaxPercentage) {
          // a car with round head.
          ObjType = APA_SLOT_OBJ_TYPE_PER_CAR_WITH_NORMAL_FLAT_NORMAL_WIDTH;
        } else {
          // a car with flat head or rear of the car.
          ObjType = APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_NORMAL_WIDTH;
        }
      } else {
        if (Dis1 < APACal.APASlotObjTypeCheckPerpendicularCarSmallFlatShapeMaxPercentage) {
          // a car with big angle.
          ObjType = APA_SLOT_OBJ_TYPE_PER_CAR_WITH_SMALL_FLAT_BIG_WIDTH;
        } else if (Dis1 < APACal.APASlotObjTypeCheckPerpendicularCarNormalFlatShapeMaxPercentage) {
          // a car with round head.
          ObjType = APA_SLOT_OBJ_TYPE_PER_CAR_WITH_NORMAL_FLAT_BIG_WIDTH;
        } else {
          // a car with flat head or rear of the car.
          ObjType = APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_BIG_WIDTH;
        }
      }
    }
  }
  return ObjType;
}

BOOLEAN APASlotProcCheckSlotObjTypeSaveObjPtToBufAndCalObjPtSlope(APA_INDEX_TYPE ObjPtIndexBuf[APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM],
                                                                  APA_SLOT_PT_SLOPE_TYPE ObjPtSlopeBuf[APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM - 1],
                                                                  APASlotOutlineCoordinateDataType *pSlot,
                                                                  APA_INDEX_TYPE ObjPtIndex,
                                                                  APA_INDEX_TYPE ObjPtIndexNum) {

  APA_INDEX_TYPE n, m;
  APA_SLOT_PT_SLOPE_TYPE PtSlope, PtSlope2;
  APA_DISTANCE_TYPE DeltaDis, DeltaY;
  APA_SLOT_PT_SLOPE_TYPE DeltaSlope;
  APA_DISTANCE_CAL_INT_TYPE DisIntTemp;

  if (ObjPtIndexNum >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM) {
    return FALSE;
  }
  if (ObjPtIndex<0 || ObjPtIndex>=100)
  {
    return FALSE;
  }
  n = ObjPtIndexNum - 1;
  if (n < 0 || n>=25)
  {
    return FALSE;
  }
  m = ObjPtIndexBuf[n];
  if (m < 0 || m>=100)
  {
    return FALSE;
  }

  PtSlope = APASlotProcCalTwoObjPtSlope(
      pSlot->CarCenterPoint[ObjPtIndex], pSlot->CarCenterPoint[m], pSlot->DisFromCarToObj[ObjPtIndex], pSlot->DisFromCarToObj[m]);

  if (PtSlope == APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_LONG) {
    // data error ??
    return FALSE;
  }
  if (PtSlope == APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT) {
    // regarded as the same with previous one.
    if (n > 0) {
      ObjPtSlopeBuf[n] = ObjPtSlopeBuf[n - 1];
    } else {
      if (pSlot->DisFromCarToObj[ObjPtIndex] > pSlot->DisFromCarToObj[m]) {
        ObjPtSlopeBuf[n] = APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT_DEF_VALUE;
      } else {
        ObjPtSlopeBuf[n] = -APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT_DEF_VALUE;
      }
    }
  } else {
    ObjPtSlopeBuf[n] = PtSlope;
    if (n > 0) {
      DeltaSlope = PtSlope - ObjPtSlopeBuf[n - 1];
      if ((DeltaSlope < (-APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope)) ||
          (DeltaSlope > (APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope))) {
        DeltaDis = MATH_ABS(pSlot->DisFromCarToObj[ObjPtIndex] - pSlot->DisFromCarToObj[m]);
        if (DeltaDis <= APACal.APASlotObjTypeCheckRegardedAsSamePtTolCarToObjDis) {
          DisIntTemp = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndex], pSlot->CarCenterPoint[m]);
          DeltaY     = (APA_DISTANCE_TYPE)DisIntTemp;
          if (DeltaY <= APACal.APASlotObjTypeCheckRegardedAsSamePtTolCarDrvDis) {
            m = ObjPtIndexBuf[n - 1];
            if (m < 0 || m>100)
            {
              return FALSE;
            }
            PtSlope2 = APASlotProcCalTwoObjPtSlope(
                pSlot->CarCenterPoint[ObjPtIndex], pSlot->CarCenterPoint[m], pSlot->DisFromCarToObj[ObjPtIndex], pSlot->DisFromCarToObj[m]);

            if ((PtSlope2 != APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_LONG) && (PtSlope2 != APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT)) {
              // regarded as the same with previous one.
              ObjPtSlopeBuf[n] = PtSlope2;
            }
          }
        }
      }
    }
  }
  ObjPtIndexBuf[ObjPtIndexNum] = ObjPtIndex;
  return TRUE;
}

APA_ENUM_TYPE APASlotProcCheckSlotObjTypeAndStartPtAndCompDis(APA_INDEX_TYPE ObjStartIndex,
                                                              APA_INDEX_TYPE ObjEndIndex,
                                                              APA_INDEX_TYPE SpeedIndex,
                                                              UCHAR CarCurrentSpd,
                                                              APA_INDEX_TYPE *pSlotStartIndex,
                                                              APA_INDEX_TYPE *pObjStartIndex,
                                                              APA_INDEX_TYPE *pObjEndIndex,
                                                              APASlotOutlineCoordinateDataType *pSlot,
                                                              APA_DISTANCE_TYPE *pObjWidth,
                                                              APA_DISTANCE_TYPE *pAPASlotDetectionCompensateLength) {
  // input par:

  // output par:

  // return value:
  // Object type

  APA_ENUM_TYPE ObjType;
  APA_INDEX_TYPE ObjPtIndexBuf[APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM];
  APA_SLOT_PT_SLOPE_TYPE ObjPtSlopeBuf[APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM - 1];
  APA_INDEX_TYPE ObjPtIndexNum;
  APA_DISTANCE_TYPE NearestObjDis1;
  APA_INDEX_TYPE NearestObjDisIndex1;
  APA_INDEX_TYPE ObjStPtDisIndex;
  APA_INDEX_TYPE FirstInflexionPtIndex;
  APA_INDEX_TYPE CarToObjDisCmpIndex;
  APA_CAL_FLOAT_TYPE X1, X2, Y1, Y2;
  APA_CAL_FLOAT_TYPE fDis1, fDis2;

  APA_INDEX_TYPE i, j, k, m, n, g, h, p, Obj1Or2Index;
  APA_INDEX_TYPE TotalIndexNum;
  APA_DISTANCE_TYPE Dis1, Dis2, Dis3, Dis4, CompensateDis1, CompensateDis2, CompensateDis3;
  APA_DISTANCE_TYPE PrevPointToBeCmpDis, PrevPointToBeCmpDis2;
  APA_INDEX_TYPE PrevPointToBeCmpDisIndex;
  APA_ENUM_TYPE ObjEndPtType, ObjEndPtType2;
  APA_SLOT_PT_SLOPE_TYPE ObjPtSlope2;
  APA_DISTANCE_TYPE FlatShapeWidth, FlatJumpWidth;
  APA_DISTANCE_TYPE FlatShapeWidthBasedOnZeroSlope;
  APA_DISTANCE_TYPE FallingShapeWidth;
  APA_DISTANCE_TYPE RisingShapeWidth;
  APA_DISTANCE_TYPE RisingShapeWidthBasedOnZeroSlope;
  APA_DISTANCE_TYPE ObjTotalWidthTemp, ObjTypeCarToObjDisCal;
  APA_DISTANCE_TYPE PrevDefineCarToObjDis, DeltaCarToObjDis;
  APA_DISTANCE_CAL_FLOAT_TYPE RisingStartPtCarDrvDisX, RisingStartPtCarDrvDisY, DeltaCarDrvDisX, DeltaCarDrvDisY, DeltaCarAng;
  APA_ENUM_TYPE SmallRisingShapeIndex1;
  APA_ENUM_TYPE SmallRisingShapeIndex2;
  APA_ENUM_TYPE SmallRisingShapeIndex3; // in the algorithm, it will max allow 3 rising shape.
  APA_ENUM_TYPE SmallFallingShapeIndex1;
  APA_ENUM_TYPE SmallFallingShapeIndex2; // in the algorithm, it will max allow 3 falling shape.
  APA_ENUM_TYPE EndOfObj;
  APA_ENUM_TYPE ObjSizeType; // 0 - small obj, 1 - vertical car, 2 - parallel car.
  APA_SLOT_PT_SLOPE_CAL_TYPE ObjAverageSlope, ObjAverageSlope2;
  APA_SLOT_PT_SLOPE_CAL_TYPE ObjPtSlope1;
  BOOLEAN bNoiseChecked, bCheckObjSmallEndWidth;

  // 1. search the nearest obj dis and index.
  if (ObjStartIndex > ObjEndIndex) {
    // Obj1
    TotalIndexNum = ObjStartIndex - ObjEndIndex;
    Obj1Or2Index  = 0; // Obj1.
  } else {
    // Obj2
    TotalIndexNum = ObjEndIndex - ObjStartIndex;
    Obj1Or2Index  = 1; // Obj2.
  }

  TotalIndexNum++;
  ObjType = APA_SLOT_OBJ_TYPE_UNKNOWN; // def to unknown

  if (TotalIndexNum < APACal.APASlotObjTypeCheckRegardedAsObjMinObjPtNum) {
    // obj point is too little
    // regarded as a noise
    return ObjType;

  } else if (TotalIndexNum > APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM) {
    i = (TotalIndexNum - APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM);
    if (Obj1Or2Index == 0) {
      ObjEndIndex += i;
    } else {
      ObjEndIndex -= i;
    }
    TotalIndexNum -= i;
  }

  NearestObjDis1           = pSlot->DisFromCarToObj[ObjStartIndex];
  NearestObjDisIndex1      = ObjStartIndex;
  ObjStPtDisIndex          = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  PrevPointToBeCmpDis      = NearestObjDis1;
  PrevPointToBeCmpDisIndex = ObjStartIndex;
  FirstInflexionPtIndex    = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  i                        = ObjStartIndex;
  FlatShapeWidth           = 0;
  FallingShapeWidth        = 0;
  RisingShapeWidth         = 0;

  SmallRisingShapeIndex1  = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  SmallRisingShapeIndex2  = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  SmallRisingShapeIndex3  = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  SmallFallingShapeIndex1 = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  SmallFallingShapeIndex2 = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  EndOfObj                = 0; // Not the end of obj.

  ObjPtIndexNum = 0;

  for (k = 0; k < TotalIndexNum; k++) {
    if (pSlot->DisFromCarToObj[i] == NO_OBJ_DISTANCE) {
      // case 1
    } else if (ObjStPtDisIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
      ObjStPtDisIndex              = i;
      PrevPointToBeCmpDis          = pSlot->DisFromCarToObj[i];
      PrevPointToBeCmpDisIndex     = i;
      ObjPtIndexBuf[ObjPtIndexNum] = i;
      ObjPtIndexNum++;
    } else {
      // case 2
      if (ObjPtIndexNum >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM) {
        // buffer full
        break;
      }
      if (i < 0)
      {
        i = 0;
      }
      else if (i >= 100)
      {
        i = 99;
      }
      if (APASlotProcCheckSlotObjTypeSaveObjPtToBufAndCalObjPtSlope(ObjPtIndexBuf, ObjPtSlopeBuf, pSlot, i, ObjPtIndexNum) == FALSE) {
        return ObjType;
      }
      ObjPtIndexNum++;

      Dis1 = pSlot->DisFromCarToObj[i] - PrevPointToBeCmpDis;
      Dis2 = MATH_ABS(Dis1);

      if (Dis2 < APACal.APASlotObjTypeCheckRegardedAsFlatShapeTolDis) {
        // flat shape.
        // case 2.1
        // Cal the flat shape width

        // search from i to start pt.
        n                    = PrevPointToBeCmpDisIndex; // flat obj st pt.
        PrevPointToBeCmpDis2 = PrevPointToBeCmpDis;      // pSlot->DisFromCarToObj[i];

        // search from i to end pt.
        if (ObjStartIndex > ObjEndIndex) {
          // Obj1
          j = i - 1;
        } else {
          // Obj2
          j = i + 1;
        }
        g = i; // flat obj end pt.
        ObjEndPtType  = 0; // def to End pt is flat shape
        bNoiseChecked = FALSE;
        // m = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // noise st pt.
        h    = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // no obj dt st pt
        Dis3 = APACal.APASlotObjTypeCheckFlatShapeRegardedAsNoObjDtMinWidth2;
        while (((ObjStartIndex > ObjEndIndex) && (j >= ObjEndIndex)) || ((ObjStartIndex < ObjEndIndex) && (j <= ObjEndIndex))) {

          if (Dis3 >= APACal.APASlotObjTypeCheckFlatShapeRegardedAsNoObjDtMinWidth1) {
            Dis2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjStPtDisIndex], pSlot->CarCenterPoint[j]);
            if (Dis2 > APACal.APASlotObjTypeCheckFlatShapeRegardedAsSmallObjMaxWidth2) {
              // > 1.5m,
              // big obj.
              Dis3 = APACal.APASlotObjTypeCheckFlatShapeRegardedAsNoObjDtMinWidth0; // 25cm.
            } else if (Dis2 > APACal.APASlotObjTypeCheckFlatShapeRegardedAsSmallObjMaxWidth1) {
              // > 1m.
              // big obj.
              Dis3 = APACal.APASlotObjTypeCheckFlatShapeRegardedAsNoObjDtMinWidth1; // 50cm.
            } else {
              // Small obj.
              //
            }
          }

          Dis1 = pSlot->DisFromCarToObj[j] - PrevPointToBeCmpDis2;
          Dis2 = MATH_ABS(Dis1);
          if (Dis2 < APACal.APASlotObjTypeCheckRegardedAsFlatShapeTolDis) {
            // flat shape.
            // case 2.1
            // keep searching

            if (h == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            } else {
              if (ObjStartIndex > ObjEndIndex) {
                // Obj 1.
                // keep searching
              } else {
                // Obj 2.
                Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[j]);

                if (Dis1 < Dis3) {
                  // keep searching

                } else {
                  if (pSlot->DisFromCarToObj[j] == NO_OBJ_DISTANCE) {
                    // No object detected is confirmed.
                    ObjEndPtType = 1; // end pt is no obj detected.
                    break;
                  } else {
                    ObjEndPtType = 2; // end pt is falling or rising shape.
                    break;
                  }
                }
              }
              h = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
            }
            if (APASlotProcCheckSlotObjTypeSaveObjPtToBufAndCalObjPtSlope(ObjPtIndexBuf, ObjPtSlopeBuf, pSlot, j, ObjPtIndexNum) == FALSE) {
              return ObjType;
            }
            ObjPtIndexNum++;
            i = j;
            g = j;
          } else {
            // j: Out of tol
            // Check the following case:
            /*
             *
             *
             noise   ->||      *
             **    *
             *
             */
            if (pSlot->DisFromCarToObj[j] == NO_OBJ_DISTANCE) {
              // Keep searching.
            } else {
              if (Dis1 > 0) {
                if (bNoiseChecked == FALSE) {
                  bNoiseChecked = TRUE;
                  if (ObjStartIndex > ObjEndIndex) {
                    // Obj 1.
                    m = g;
                  } else {
                    // Obj 2.
                    m = j;
                  }
                  ObjTotalWidthTemp = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[m], pSlot->CarCenterPoint[ObjStPtDisIndex]);

                  if (ObjTotalWidthTemp < APACal.APASlotObjTypeCheckRegardedAsFallingShapeNoiseMaxFallingObjWidth) {
                    // It may be a noise.
                    m    = j;
                    Dis2 = pSlot->DisFromCarToObj[m];
                    while (((ObjStartIndex > ObjEndIndex) && (m > ObjEndIndex)) || ((ObjStartIndex < ObjEndIndex) && (m < ObjEndIndex))) {

                      if (ObjStartIndex > ObjEndIndex) {
                        // Obj1
                        m--;
                      } else {
                        // Obj2
                        m++;
                      }
                      if (pSlot->DisFromCarToObj[m] == NO_OBJ_DISTANCE) {
                        // case 1
                        break;
                      } else {

                        if (pSlot->DisFromCarToObj[m] < Dis2) {
                          // rising shape.
                          // case 2.1
                          // keep searching
                          Dis2 = pSlot->DisFromCarToObj[m];
                        } else {
                          // flat or falling shape.
                          break;
                        }
                      }
                    }
                    if (ObjStartIndex > ObjEndIndex) {
                      // Obj1
                      m++;
                    } else {
                      // Obj2
                    }
                    RisingShapeWidth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[j], pSlot->CarCenterPoint[m]);
                    if ((RisingShapeWidth > APACal.APASlotObjTypeCheckRegardedAsFallingShapeNoiseMinRisingObjWidth) &&
                        (RisingShapeWidth > ObjTotalWidthTemp)) {
                      // Noise confirmed.
                      // keep searching.
                      // from the start of j;
                      PrevPointToBeCmpDis      = pSlot->DisFromCarToObj[j];
                      PrevPointToBeCmpDisIndex = j;
                      ObjPtIndexNum            = 1;
                      ObjPtIndexBuf[0]         = j;
                      ObjEndPtType             = 2; // end pt is falling or rising shape.
                      i                        = j;
                      break;
                    } else {
                      // unknown ??
                    }
                  } else {
                    // unknow ??
                  }
                }
              } else {
              }
              // just end of searching
              ObjEndPtType = 2; // end pt is falling or rising shape.
              break;
            }
            if (h == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
              if (ObjStartIndex > ObjEndIndex) {
                // Obj 1.
                h    = j + 1;
                Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[j]);

                if (Dis1 < Dis3) {
                  // keep searching

                } else {
                  if (pSlot->DisFromCarToObj[j] == NO_OBJ_DISTANCE) {
                    // No object detected is confirmed.
                    ObjEndPtType = 1; // end pt is no obj detected.
                    break;
                  } else {
                    ObjEndPtType = 2; // end pt is falling or rising shape.
                    break;
                  }
                }

              } else {
                // Obj 2.
                // Ok keep searching
                h = j;
              }
            } else {
              Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[j]);

              if (Dis1 < Dis3) {
                // keep searching

              } else {
                // No object detected is confirmed.
                if (pSlot->DisFromCarToObj[j] == NO_OBJ_DISTANCE) {
                  // No object detected is confirmed.
                  ObjEndPtType = 1; // end pt is no obj detected.
                  break;
                } else {
                  ObjEndPtType = 2; // end pt is falling or rising shape.
                  break;
                }
              }
            }
          }
          if (ObjStartIndex > ObjEndIndex) {
            // Obj1
            j--;
          } else {
            // Obj2
            j++;
          }
        }

        if (ObjEndPtType <= 1) {
          // end pt is flat.
          // or end pt is no obj detected.
          EndOfObj = ObjEndPtType + 1; // 1: end pt is flat, 2: end pt is flat and no obj detected.
          break;
        } else {
          // Keep searching
        }

      } else {
        // Out of tol
        // case 2.2

        if (Dis1 > 0) {
          // falling shape.
          // case 2.2.1

          // search the falling shape width.
          // search from i to end pt.
          if (ObjStartIndex > ObjEndIndex) {
            // Obj1
            j = i - 1;
          } else {
            // Obj2
            j = i + 1;
          }

          n = PrevPointToBeCmpDisIndex; // Falling shape start index.
          g = i;                        // falling shape end pt.

          ObjEndPtType         = 0; // def to End pt is falling shape
          PrevPointToBeCmpDis2 = pSlot->DisFromCarToObj[i];
          h                    = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // no obj dt st pt

          Dis2 = APACal.APASlotObjTypeCheckFallingShapeRegardedAsNoObjDtMinWidth2;
          while (((ObjStartIndex > ObjEndIndex) && (j >= ObjEndIndex)) || ((ObjStartIndex < ObjEndIndex) && (j <= ObjEndIndex))) {

            if (Dis2 == APACal.APASlotObjTypeCheckFallingShapeRegardedAsNoObjDtMinWidth2) {
              Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjStPtDisIndex], pSlot->CarCenterPoint[j]);
              if (Dis1 > APACal.APASlotObjTypeCheckFallingShapeRegardedAsSmallObjMaxWidth) {
                // big obj.
                Dis2 = APACal.APASlotObjTypeCheckFallingShapeRegardedAsNoObjDtMinWidth1; // 40cm.
              } else {
                // Small obj.
              }
            }

            if (pSlot->DisFromCarToObj[j] == NO_OBJ_DISTANCE) {
              // case 1
              // keep searching
              if (h == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
                if (ObjStartIndex > ObjEndIndex) {
                  // Obj 1.
                  h    = j + 1;
                  Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[j]);

                  if (Dis1 < Dis2) {
                    // keep searching

                  } else {
                    // No object detected is confirmed.
                    ObjEndPtType = 1; // end pt is no obj detected.
                    break;
                  }

                } else {
                  // Obj 2.
                  // Ok keep searching
                  h = j;
                }
              } else {
                Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[j]);

                if (Dis1 < Dis2) {
                  // keep searching

                } else {
                  // No object detected is confirmed.
                  ObjEndPtType = 1; // end pt is no obj detected.
                  break;
                }
              }
            } else {
              if (h == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
              } else {

                if (ObjStartIndex > ObjEndIndex) {
                  // Obj 1.
                  // keep searching
                } else {
                  // Obj 2.
                  Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[j]);

                  if (Dis1 < Dis2) {
                    // keep searching

                  } else {
                    // No object detected is confirmed.
                    ObjEndPtType = 1; // end pt is no obj detected.

                    break;
                  }
                }
                h = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
              }

              if (pSlot->DisFromCarToObj[j] > PrevPointToBeCmpDis2) {
                // falling shape.
                // case 2.1
                // keep searching
                g                    = j;
                PrevPointToBeCmpDis2 = pSlot->DisFromCarToObj[j];
              } else {
                // flat or rising shape.
                ObjEndPtType = 2; // end pt is flat or rising shape.

                break;
              }

              if (APASlotProcCheckSlotObjTypeSaveObjPtToBufAndCalObjPtSlope(ObjPtIndexBuf, ObjPtSlopeBuf, pSlot, j, ObjPtIndexNum) == FALSE) {
                return ObjType;
              }
              ObjPtIndexNum++;
              i = j;
            }

            if (ObjStartIndex > ObjEndIndex) {
              // Obj1
              j--;
            } else {
              // Obj2
              j++;
            }
          }

          // Check if it is the end of searhing (or end of obj shape)
          if (ObjEndPtType <= 1) {
            // end pt is falling shape or no object detected.
            // end of object
            EndOfObj = 3; // end pt is falling shape or no object detected.
            break;
          }
          FallingShapeWidth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g], pSlot->CarCenterPoint[n]);
          ObjTotalWidthTemp = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g], pSlot->CarCenterPoint[ObjStPtDisIndex]);

          if (((ObjTotalWidthTemp > APACal.APASlotObjTypeCheckFallingShapeRegardedAsObjEndedMinObjWidth1) &&
               (FallingShapeWidth > APACal.APASlotObjTypeCheckRegardedAsFallingShapeMinObjWidth1)) ||
              (ObjTotalWidthTemp > APACal.APASlotObjTypeCheckFallingShapeRegardedAsObjEndedMinObjWidth2)) {
            // regarded as end of object ??
            EndOfObj = 4; // end pt is falling shape and not the end of object.
            break;
          }

          // keep searching
          // ??? unknown shape
          if (ObjTotalWidthTemp < APACal.APASlotObjTypeCheckRegardedAsFallingShapeNoiseMaxFallingObjWidth) {
            // It may be a noise.
            /*
             *
             *
             noise->	*  *
             *

             */
            while (((ObjStartIndex > ObjEndIndex) && (j >= ObjEndIndex)) || ((ObjStartIndex < ObjEndIndex) && (j <= ObjEndIndex))) {

              if (pSlot->DisFromCarToObj[j] == NO_OBJ_DISTANCE) {
                // case 1
                break;
              } else {

                if (pSlot->DisFromCarToObj[j] <= PrevPointToBeCmpDis2) {
                  // rising shape.
                  // case 2.1
                  // keep searching
                  PrevPointToBeCmpDis2 = pSlot->DisFromCarToObj[j];
                } else {
                  // flat or falling shape.
                  break;
                }
              }
              if (ObjStartIndex > ObjEndIndex) {
                // Obj1
                j--;
              } else {
                // Obj2
                j++;
              }
            }
            if (ObjStartIndex > ObjEndIndex) {
              // Obj1
              j++;
            } else {
              // Obj2
              if (j > ObjEndIndex) {
                j = ObjEndIndex;
              }
            }
            RisingShapeWidth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[i], pSlot->CarCenterPoint[j]);
            if ((RisingShapeWidth > APACal.APASlotObjTypeCheckRegardedAsFallingShapeNoiseMinRisingObjWidth) &&
                (RisingShapeWidth > ObjTotalWidthTemp)) {
              // Noise confirmed.
              // keep searching.
              // from the start of i;
              PrevPointToBeCmpDis      = pSlot->DisFromCarToObj[i];
              PrevPointToBeCmpDisIndex = i;
              ObjPtIndexNum            = 1;
              ObjPtIndexBuf[0]         = i;
            } else {
              // unknown ??
              return ObjType;
            }
          } else {
            // unknow ??
            return ObjType;
          }

#if 0
					if(SmallFallingShapeIndex1 == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
						// it is first rising shape
						SmallFallingShapeIndex1 = n;
					} else /*if(SmallFallingShapeIndex2 == INVALID_APA_SLOT_BUFFER_VALUE_INDEX)*/{
						// it is second rising shape
						SmallFallingShapeIndex2 = n;
					}

					ObjProfileState2 = 2; // falling shape.
#endif

        } else {
          // rising shape.
          // case 2.2.2

          // search the rising shape width.
          // search from i to end pt.
          if (ObjStartIndex > ObjEndIndex) {
            // Obj1
            j = i - 1;
          } else {
            // Obj2
            j = i + 1;
          }

          n = PrevPointToBeCmpDisIndex; // rising shape start index.
          g = i;                        // rising shape end pt.

          ObjEndPtType         = 0; // def to End pt is rising shape
          PrevPointToBeCmpDis2 = pSlot->DisFromCarToObj[i];
          h                    = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // no obj dt st pt

          Dis3 = APACal.APASlotObjTypeCheckRisingShapeRegardedAsNoObjDtMinWidth2; // 100cm.

          while (((ObjStartIndex > ObjEndIndex) && (j >= ObjEndIndex)) || ((ObjStartIndex < ObjEndIndex) && (j <= ObjEndIndex))) {

            if (Dis3 >= APACal.APASlotObjTypeCheckRisingShapeRegardedAsNoObjDtMinWidth1) {
              Dis2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjStPtDisIndex], pSlot->CarCenterPoint[j]);
              if (Dis2 > APACal.APASlotObjTypeCheckRisingShapeRegardedAsSmallObjMaxWidth2) {
                // > 1.5m,
                // big obj.
                Dis3 = APACal.APASlotObjTypeCheckRisingShapeRegardedAsNoObjDtMinWidth0; // 25cm.
              } else if (Dis2 > APACal.APASlotObjTypeCheckRisingShapeRegardedAsSmallObjMaxWidth1) {
                // > 1m.
                // big obj.
                Dis3 = APACal.APASlotObjTypeCheckRisingShapeRegardedAsNoObjDtMinWidth1; // 50cm.
              } else {
                // Small obj.
                //
              }
            }
            if (pSlot->DisFromCarToObj[j] >= PrevPointToBeCmpDis2) {
              // flat or Falling shape.
              // case 2.1

              if (h == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
                if (ObjStartIndex > ObjEndIndex) {
                  // Obj 1.
                  h    = j + 1;
                  Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[j]);

                  if (Dis1 < Dis3) {
                    // keep searching

                  } else {
                    if (pSlot->DisFromCarToObj[j] == NO_OBJ_DISTANCE) {
                      // No object detected is confirmed.
                      ObjEndPtType = 1; // end pt is no obj detected.
                      break;
                    } else {
                      ObjEndPtType = 2; // end pt is falling or flat shape.
                      break;
                    }
                  }

                } else {
                  // Obj 2.
                  // Ok keep searching
                  h = j;
                }
              } else {
                Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[j]);

                if (Dis1 < Dis3) {
                  // keep searching
                } else {
                  // No object detected is confirmed.
                  if (pSlot->DisFromCarToObj[j] == NO_OBJ_DISTANCE) {
                    // No object detected is confirmed.
                    ObjEndPtType = 1; // end pt is no obj detected.
                    break;
                  } else {
                    ObjEndPtType = 2; // end pt is falling or flat shape.
                    break;
                  }
                }
              }
              if (j == ObjEndIndex) {
                // j is the last point.
                ObjEndPtType = 2; // end pt is falling or flat shape.
                break;
              }
            } else {
              // rising shape.
              if (h == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
              } else {
                if (ObjStartIndex > ObjEndIndex) {
                  // Obj 1.
                  // keep searching
                } else {
                  // Obj 2.
                  Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[j]);

                  if (Dis1 < Dis3) {
                    // keep searching

                  } else {
                    if (pSlot->DisFromCarToObj[j] == NO_OBJ_DISTANCE) {
                      // No object detected is confirmed.
                      ObjEndPtType = 1; // end pt is no obj detected.
                      break;
                    } else {
                      ObjEndPtType = 2; // end pt is falling or rising shape.
                      break;
                    }
                  }
                }
                h = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
              }

              // keep searching
              PrevPointToBeCmpDis2 = pSlot->DisFromCarToObj[j];
              g                    = j;

              if (APASlotProcCheckSlotObjTypeSaveObjPtToBufAndCalObjPtSlope(ObjPtIndexBuf, ObjPtSlopeBuf, pSlot, j, ObjPtIndexNum) == FALSE) {
                return ObjType;
              }

              ObjPtIndexNum++;

              i = j;
            }

            if (ObjStartIndex > ObjEndIndex) {
              // Obj1
              j--;
            } else {
              // Obj2
              j++;
            }
          }

          // RisingShapeWidth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g],
          //		pSlot->CarCenterPoint[n]);

          if (ObjEndPtType <= 1) {
            // end pt is rising shape or no object detected.
            // End of object.
            EndOfObj = ObjEndPtType + 5; // end pt is rising shape or no object detected.
            break;
          }

#if 0
					if(SmallRisingShapeIndex1 == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
						// it is first rising shape
						SmallRisingShapeIndex1 = n;
					} else if(SmallRisingShapeIndex2 == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
						// it is second rising shape
						SmallRisingShapeIndex2 = n;
					} else /*if(SmallRisingShapeIndex3 == INVALID_APA_SLOT_BUFFER_VALUE_INDEX)*/{
						SmallRisingShapeIndex3 = n;
					}
#endif

          if (SmallRisingShapeIndex1 == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            // it is first rising shape
            SmallRisingShapeIndex1 = n;
          } else {

            // Unknown shape:
            return ObjType;
          }
        }
        PrevPointToBeCmpDis      = pSlot->DisFromCarToObj[i];
        PrevPointToBeCmpDisIndex = i;
      }
    }

    if (ObjStartIndex > ObjEndIndex) {
      // Obj1
      i--;
    } else {
      // Obj2
      i++;
    }
  }

  if ((EndOfObj == 0) || (ObjPtIndexNum < 2)) {

    // data error ??
    // or unknown shape ??
    return ObjType;
  }
  // cal object total width

  // add for debug 20141128 start
  if (ObjPtIndexNum > APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM) {
    return APA_SLOT_OBJ_TYPE_UNKNOWN;
  }
  // add for debug 20141128 end

  // stack overflow here 20141128
  ObjTotalWidthTemp =
      APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[ObjPtIndexNum - 1]], pSlot->CarCenterPoint[ObjStPtDisIndex]);

  // check the object inflexion pt
  // cal the slope of the object profile (line)
  // 1. search to the 1/3 point
  // 2. search to the 2/3 point
  g    = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // the 1/3 point pointer
  h    = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // the 2/3 point pointer
  Dis2 = ObjTotalWidthTemp / 3;
  Dis3 = Dis2 + Dis2;
  for (m = 0; m < ObjPtIndexNum; m++) {
    Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[m]], pSlot->CarCenterPoint[ObjStPtDisIndex]);
    if (g == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
      if (Dis1 > Dis2) {
        if (m > 0) {
          g = m - 1;
        } else {
          g = 0;
        }
        if (m == (ObjPtIndexNum - 1)) {
          h = m;
        }
      }
    } else {
      if (Dis1 > Dis3) {
        h = m;
        break;
      }
    }
  }

  // 3. cal the average slope
  if ((g != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) && (h != INVALID_APA_SLOT_BUFFER_VALUE_INDEX)) {
    ObjAverageSlope = 0;
    for (m = g; m < h; m++) {
      ObjAverageSlope += ObjPtSlopeBuf[m];
    }
    h = h - g; // total points.
    ObjAverageSlope /= h;
  } else {
    // code should never reach.
    // Data error.
    return ObjType;
  }

  // check the inflexion pt: m is the inflexion pt.
  g = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // Within the delta dis slope1 start (10deg), flat shape start
  h = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // within the delta dis slope1 end

  m = ObjPtIndexNum / 2;
  while (m > 0) {
    m--;
    ObjPtSlope1 = (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjPtSlopeBuf[m] - (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjAverageSlope;
    if ((ObjPtSlope1 >= (-APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope)) &&
        (ObjPtSlope1 <= (APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope))) {
      // OK, within the tolerance.
      g = m;
    } else {
      if (g != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        // found
        break;
      }
    }
  }
  ObjPtIndexNum--; // Notes: The last obj index.

  if (g != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
    // found
    m = g + 1;
  } else {
    m = 0;
  }

  for (; m < ObjPtIndexNum; m++) {
    ObjPtSlope1 = (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjPtSlopeBuf[m] - (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjAverageSlope;
    if ((ObjPtSlope1 >= (-APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope)) &&
        (ObjPtSlope1 <= (APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope))) {
      // OK, within the tolerance.
      if (g == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        g = m;
      }
    } else {
      if (g != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        h = m;
        break;
      }
    }
  }

  ObjEndPtType = 0;
  if ((g != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) && (h == INVALID_APA_SLOT_BUFFER_VALUE_INDEX)) {
    if (m == ObjPtIndexNum) {
      // End point is flat
      h = m;
      if (ObjStartIndex > ObjEndIndex) {
        // Obj1
      } else {
        // Obj2
        if (pSlot->DisFromCarToObj[ObjEndIndex] != NO_OBJ_DISTANCE) {
          // obj end pt is not the actual end of the object, and the obj end pt is
          // also a flat point.
          ObjEndPtType = 1;
        }
      }
    }
  }
  if ((g != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) && (g > 0)) {

    // add for debug 20141128 start
    if (g >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM) {
      return APA_SLOT_OBJ_TYPE_UNKNOWN;
    }
    // add for debug 20141128 end

    RisingShapeWidth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[g]], pSlot->CarCenterPoint[ObjStPtDisIndex]);
  } else {
    RisingShapeWidth = 0;
  }

  if ((g != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) && (h != INVALID_APA_SLOT_BUFFER_VALUE_INDEX)) {
    // Both start and end point is ok.
    FlatShapeWidth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[g]], pSlot->CarCenterPoint[ObjPtIndexBuf[h]]);
  } else {
    FlatShapeWidth = 0;
  }

  FlatShapeWidthBasedOnZeroSlope   = 0;
  RisingShapeWidthBasedOnZeroSlope = 0;
  if (ObjTotalWidthTemp < APACal.APASlotObjTypeCheckRegardedAsPerpendicularCarMinWidth) {
    // Small obj. ( < 1m)
    ObjSizeType = 0;

    // cal the RisingShapeWidthBasedOnZeroSlope
    k = 0;
    for (m = 0; m < ObjPtIndexNum; m++) {
      ObjPtSlope2 = ObjPtSlopeBuf[m];
      if (ObjPtSlope2 < (-APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope)) {
        // OK, out of the tolerance.
      } else {
        if ((m > 0) && (RisingShapeWidthBasedOnZeroSlope == 0)) {
          RisingShapeWidthBasedOnZeroSlope =
              APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[m]], pSlot->CarCenterPoint[ObjPtIndexBuf[0]]);
          k = m;
        }
        if (ObjPtSlope2 < (APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope)) {
          // OK within tol
        } else {
          if (m > k) {
            FlatShapeWidthBasedOnZeroSlope =
                APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[m]], pSlot->CarCenterPoint[ObjPtIndexBuf[k]]);
          }
          break;
        }
      }
    }
  } else {
    if (ObjTotalWidthTemp < APACal.APASlotObjTypeCheckRegardedAsPerpendicularCarMaxWidth1) {
      // 3.2m,
      // Vertical vehicle or with angle
      ObjSizeType = 1;
    } else {
      // parallel vehicle.
      ObjSizeType = 2;
    }

    ObjAverageSlope2 = 0;
    k                = g + 1;
    for (m = k; m < ObjPtIndexNum; m++) {
      ObjAverageSlope2 += ObjPtSlopeBuf[m];
    }
    p = ObjPtIndexNum - k; // total points.
    if (p > 2) {
      ObjAverageSlope2 /= p;

      // check the inflexion pt: m is the inflexion pt.
      i = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // Within the delta dis slope1 start (10deg), flat shape start
      j = INVALID_APA_SLOT_BUFFER_VALUE_INDEX; // within the delta dis slope1 end
      for (m = k; m < ObjPtIndexNum; m++) {
        ObjPtSlope1 = (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjPtSlopeBuf[m] - (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjAverageSlope2;
        if ((ObjPtSlope1 >= (-APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope)) &&
            (ObjPtSlope1 <= (APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope))) {
          // OK, within the tolerance.
          if (i == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            i = m;
          }
        } else {
          if (i != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            j = m;
            break;
          }
        }
      }

      ObjEndPtType2 = 0;
      if ((i != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) && (j == INVALID_APA_SLOT_BUFFER_VALUE_INDEX)) {
        if (m == ObjPtIndexNum) {
          // End point is flat
          j = m;
          if (ObjStartIndex > ObjEndIndex) {
            // Obj1
          } else {
            // Obj2
            if (pSlot->DisFromCarToObj[ObjEndIndex] != NO_OBJ_DISTANCE) {
              // obj end pt is not the actual end of the object, and the obj end pt is
              // also a flat point.
              ObjEndPtType2 = 1;
            }
          }
        }
      }
      if ((i != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) && (j != INVALID_APA_SLOT_BUFFER_VALUE_INDEX)) {
        // Both start and end point is ok.
        Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[i]], pSlot->CarCenterPoint[ObjPtIndexBuf[j]]);
        if ((Dis1 > FlatShapeWidth) ||
            ((ObjEndPtType2 == 1) && (ObjEndPtType == 0) && (Dis1 > APACal.APASlotObjTypeCheckRegardedAsAngularCarMinFlatShapeWidth1))) {
          // Dis1 is the actual flat shape.
          FlatShapeWidth   = Dis1;
          RisingShapeWidth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[i]], pSlot->CarCenterPoint[ObjStPtDisIndex]);
          g                = i;
          h                = j; // Not used.
          ObjEndPtType     = ObjEndPtType2;
          ObjAverageSlope  = ObjAverageSlope2;
        }
      }
    }
  }

  if ((RisingShapeWidth > 0) && (g > 0)) {

    Y1                    = (APA_DISTANCE_CAL_FLOAT_TYPE)APACal.APASlotObjTypeCheckObjRisingShapeEndPtMinDeltaDis[Obj1Or2Index];
    Y2                    = (APA_DISTANCE_CAL_FLOAT_TYPE)APACal.APASlotObjTypeCheckObjRisingShapeEndPtMaxDeltaDis[Obj1Or2Index];
    X1                    = (APA_DISTANCE_CAL_FLOAT_TYPE)APACal.APASlotObjTypeCheckObjRisingShapeEndPtMinRisingWidth;
    X2                    = (APA_DISTANCE_CAL_FLOAT_TYPE)APACal.APASlotObjTypeCheckObjRisingShapeEndPtMaxRisingWidth;
    fDis1                 = (APA_DISTANCE_CAL_FLOAT_TYPE)RisingShapeWidth;
    fDis1                 = APATrajCalTwoPointInterpolationCalculation(Y1, Y2, X1, X2, fDis1);
    PrevDefineCarToObjDis = (pSlot->DisFromCarToObj[ObjPtIndexBuf[g]] + (APA_DISTANCE_TYPE)fDis1);

    m = g - 1;
    while (m >= 0) {
      i = ObjPtIndexBuf[m];
      if (pSlot->DisFromCarToObj[i] >= PrevDefineCarToObjDis) {
        break;
      }
      m--;
    }

    if (m <= -1) {
      RisingShapeWidth = 0;
    } else {
      i                = ObjPtIndexBuf[m];     // start pt
      j                = ObjPtIndexBuf[m + 1]; // end pt
      DeltaCarToObjDis = pSlot->DisFromCarToObj[i] - pSlot->DisFromCarToObj[j];
      if ((DeltaCarToObjDis) > 0) {

        Y1 = (APA_DISTANCE_CAL_FLOAT_TYPE)APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[i], pSlot->CarCenterPoint[j]);
        X1 = (APA_DISTANCE_CAL_FLOAT_TYPE)(PrevDefineCarToObjDis - pSlot->DisFromCarToObj[j]);
        X2 = (APA_DISTANCE_CAL_FLOAT_TYPE)DeltaCarToObjDis;
        Y2 = X1 / X2 * Y1;
        Y1 -= Y2;

        RisingShapeWidth = (APA_DISTANCE_TYPE)APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[0]], pSlot->CarCenterPoint[i]);
        RisingShapeWidth += (APA_DISTANCE_TYPE)Y1;
      } else {
        RisingShapeWidth = 0;
      }
    }
  }
  if ((g != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) && (h != INVALID_APA_SLOT_BUFFER_VALUE_INDEX)) {
    // g : start point index.
    // h : end point index.

    p = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;

    for (m = h; m < ObjPtIndexNum; m++) {
      ObjPtSlope1 = (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjPtSlopeBuf[m] - (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjAverageSlope;
      if ((ObjPtSlope1 >= (-APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope)) &&
          (ObjPtSlope1 <= (APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope))) {
        p = m;
        break;
      }
    }
    /*
     *
     *
     * ------- g
     *
     *
     *
     *
     * ------- h
        *  |
          * | -------> FlatJumpWidth
        *  |
     * ------- p
     *
     *
     *
     *

     */
    if (p != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
      FlatJumpWidth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[h]], pSlot->CarCenterPoint[ObjPtIndexBuf[p]]);
      if (FlatJumpWidth < APACal.APASlotObjTypeCheckFlatShapeJumpWidthTol) {
        for (m = p + 1; m < ObjPtIndexNum; m++) {
          ObjPtSlope1 = (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjPtSlopeBuf[m] - (APA_SLOT_PT_SLOPE_CAL_TYPE)ObjAverageSlope;
          if ((ObjPtSlope1 >= (-APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope)) &&
              (ObjPtSlope1 <= (APACal.APASlotObjTypeCheckRegardedAsObjStartMaxDeltaDisSlope))) {
            p = m;
          } else {
            break;
          }
        }
        h              = p;
        FlatShapeWidth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[g]], pSlot->CarCenterPoint[ObjPtIndexBuf[h]]);
      }
    }
  }

  // check the object shape.
  ObjPtSlope2 = (APA_SLOT_PT_SLOPE_TYPE)ObjAverageSlope;
  if (SmallRisingShapeIndex1 == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
    // no rising shape
    if (SmallFallingShapeIndex1 == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
      if ((EndOfObj == 1) || (EndOfObj == 2)) {
        // end pt is flat or end pt is no obj detected.
        // square obj ??
        // it may be a parallel car.
        if (ObjSizeType == 0) {
          // Small obj. ( < 1m)
          ObjType = APA_SLOT_OBJ_TYPE_SQUARE_OBJ;
        } else if (ObjSizeType == 1) {
          // 1~ 3.2m.
          // Vertical vehicle or with angle
          ObjType = APASlotProcCheckSlotObjTypePerpendicularCarTypeCheck(
              ObjEndPtType, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);

        } else {
          // Obj width > 3.2m,
          // parallel vehicle.
          // Check flat width
          ObjType = APASlotProcCheckSlotObjTypeParallelOrAngularCarTypeCheck(
              0, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);
        }
      } else if ((EndOfObj == 3) || (EndOfObj == 4)) {
        // end pt is falling or end pt is no obj detected.
        // square obj with Angle shape.
        if (ObjSizeType == 0) {
          // Small obj. ( < 1m)
          if (RisingShapeWidthBasedOnZeroSlope <= APACal.APASlotObjTypeCheckSquareObjMaxRisingShapeWidth) { // obj start point is flat.
            ObjType = APA_SLOT_OBJ_TYPE_SQUARE_OBJ_WITH_FALLING_SHAPE;
          } else {
            ObjType = APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_SMALL_RISING_AND_FALLING_SHAPE;
          }
        } else if (ObjSizeType == 1) {
          // 1~ 3.2m.
          // Vertical vehicle or with angle
          ObjType = APASlotProcCheckSlotObjTypePerpendicularCarTypeCheck(
              ObjEndPtType, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);

        } else {
          // Obj width > 3.2m,
          // parallel vehicle.
          // Check flat width
          ObjType = APASlotProcCheckSlotObjTypeParallelOrAngularCarTypeCheck(
              0, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);
        }

      } else {
        // End pt is rising shape or no obj det.
        // square obj with Angle shape.
        if (ObjSizeType == 0) {
          // Small obj. ( < 1m)
          Dis1 = ObjTotalWidthTemp / 100;
          if (Dis1 > 0) {
            Dis1 = FlatShapeWidthBasedOnZeroSlope / Dis1;
          } else {
            Dis1 = 0;
          }
          if (Dis1 < APACal.APASlotObjTypeCheckRoundObjRegardedAsFlatShapeMinPercentage) {
            ObjType = APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_RISING_SHAPE_ONLY;
          } else {
            ObjType = APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_RISING_AND_FLAT_SHAPE;
          }
        } else if (ObjSizeType == 1) {
          // 1~ 3.2m.
          // Vertical vehicle or with angle
          ObjType = APASlotProcCheckSlotObjTypePerpendicularCarTypeCheck(
              ObjEndPtType, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);

        } else {
          // Obj width > 3.2m,
          // parallel vehicle.
          // Check flat width
          ObjType = APASlotProcCheckSlotObjTypeParallelOrAngularCarTypeCheck(
              0, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);
        }
      }
    } else {
      // first shape is small falling shape.
      // unknow shape
      return ObjType;
    }
  } else if (SmallRisingShapeIndex2 == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
    // first shape is rising
    // second shape may be flat, falling or still rising.

    if ((EndOfObj == 1) || (EndOfObj == 2)) {
      // 1: end pt is flat, 2: end pt is flat and no obj detected.
      // rising and flat
      if (ObjSizeType == 0) {
        // Small obj. ( < 1m)
        // Check the flat width
        // it may be a flat rear bumper or round object.
        /*
         *
         *
         ****
         */
        // check the flat shape width ??
        Dis1 = ObjTotalWidthTemp / 100;
        if (Dis1 > 0) {
          Dis1 = FlatShapeWidthBasedOnZeroSlope / Dis1;
        } else {
          Dis1 = 0;
        }
        if (Dis1 < APACal.APASlotObjTypeCheckRoundObjRegardedAsFlatShapeMinPercentage) {
          ObjType = APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_RISING_SHAPE_ONLY;
        } else {
          ObjType = APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_RISING_AND_FLAT_SHAPE;
        }
      } else if (ObjSizeType == 1) {
        // 1~ 3.2m.
        // Vertical vehicle or with angle
        ObjType = APASlotProcCheckSlotObjTypePerpendicularCarTypeCheck(
            ObjEndPtType, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);

      } else {
        // Obj width > 3.2m,
        // parallel vehicle.
        // Check flat width
        ObjType = APASlotProcCheckSlotObjTypeParallelOrAngularCarTypeCheck(
            0, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);
      }
    } else if ((EndOfObj == 3) || (EndOfObj == 4)) {
      // end pt is falling or end pt is no obj detected.
      // square obj with Angle shape.
      if (ObjSizeType == 0) {
        // Small obj. ( < 1m)
        // Check the flat width
        // it may be a flat rear bumper or round object.
        /*
         *
         *     *
         **
         */
        // check the flat shape width ??
        if (RisingShapeWidthBasedOnZeroSlope < APACal.APASlotObjTypeCheckRoundObjSmallRisingShapeMaxWidth) {
          ObjType = APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_SMALL_RISING_AND_FALLING_SHAPE;
        } else if (RisingShapeWidthBasedOnZeroSlope < APACal.APASlotObjTypeCheckRoundObjBigRisingShapeMaxWidth) {
          ObjType = APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_NORMAL_RISING_AND_FALLING_SHAPE;
        } else {
          ObjType = APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_BIG_RISING_AND_FALLING_SHAPE;
        }
      } else if (ObjSizeType == 1) {
        // 1~ 3.2m.
        // perpendicular vehicle or with angle

        ObjType = APASlotProcCheckSlotObjTypePerpendicularCarTypeCheck(
            ObjEndPtType, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);

      } else {
        // Obj width > 3.2m,
        // parallel vehicle or angular.
        // Check flat width
        ObjType = APASlotProcCheckSlotObjTypeParallelOrAngularCarTypeCheck(
            0, ObjTotalWidthTemp, FlatShapeWidth, RisingShapeWidth, ObjPtSlope2, ObjPtSlopeBuf[0]);
      }

    } else {
      // End pt is rising shape or no obj det.
      // unknown??
      return ObjType;
    }
  }
  if (ObjType != APA_SLOT_OBJ_TYPE_UNKNOWN) {
    // search back, cal the obj pt start.
    //
    //
    // search for the nearest dis to cal the object start point.
    if (ObjStartIndex > ObjEndIndex) {
      // Obj1
      Obj1Or2Index = 0;
    } else {
      // Obj2
      Obj1Or2Index = 1;
    }

    NearestObjDis1      = pSlot->DisFromCarToObj[ObjPtIndexBuf[0]];
    NearestObjDisIndex1 = 0;
    if (ObjType <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_BIG_WIDTH) {
      // square, round, perpendicular car
      Dis2 = APACal.APASlotObjTypeCheckObjStartPtCalSearchBackWidthSmallObj[Obj1Or2Index];
    } else {
      Dis2 = APACal.APASlotObjTypeCheckObjStartPtCalSearchBackWidthParallelCar[Obj1Or2Index];
    }
    for (m = 1; m <= ObjPtIndexNum; m++) {

      // add for debug 20141128 start
      if ((m >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
        return APA_SLOT_OBJ_TYPE_UNKNOWN;
      }
      // add for debug 20141128 end

      Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[m]], pSlot->CarCenterPoint[ObjPtIndexBuf[0]]);

      if (Dis1 > Dis2) {
        break;
      }

      // add for debug 20141128 start
      if ((m >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
        return APA_SLOT_OBJ_TYPE_UNKNOWN;
      }
      // add for debug 20141128 end

      if (NearestObjDis1 > pSlot->DisFromCarToObj[ObjPtIndexBuf[m]]) {
        NearestObjDis1      = pSlot->DisFromCarToObj[ObjPtIndexBuf[m]];
        NearestObjDisIndex1 = m;
      }
    }
    if (ObjType <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_SMALL_FLAT_SMALL_WIDTH) {
      // small obj or car with sharp head.
    } else if (ObjType > APA_SLOT_OBJ_TYPE_PER_CAR_WITH_NORMAL_FLAT_BIG_WIDTH) {
      // With a rather big flat shape object.
      if (NearestObjDisIndex1 > g) {
        NearestObjDisIndex1 = g;

        // add for debug 20141128 start
        if ((g >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
          return APA_SLOT_OBJ_TYPE_UNKNOWN;
        }
        // add for debug 20141128 end

        NearestObjDis1 = pSlot->DisFromCarToObj[ObjPtIndexBuf[g]];
      }
    }

#ifdef APA_SLOT_OBJ2_COMPENSATE_DIS_DEBUG
    ObjPtSlope2 = 0;
#endif

    Dis2 = APACal.APASlotObjTypeCheckObjStartPtCalDeltaObjDisObj[Obj1Or2Index][ObjType - 1];

#if 0
		if((NearestObjDisIndex1 > 1)
				&& ((pSlot->DisFromCarToObj[ObjPtIndexBuf[0]] - NearestObjDis1)
						> Dis2)
				&& (RisingShapeWidth > Dis2)) {
#if 0
			ObjAverageSlope2 = 0;
			k = NearestObjDisIndex1;
			while(k > 0) {
				k --;
				ObjAverageSlope2 += ObjPtSlopeBuf[k];

				if((k > 0)
						&& (ObjPtSlopeBuf[k - 1] > ObjPtSlopeBuf[k])) {
					break;
				}
			}
			ObjAverageSlope2 /= (NearestObjDisIndex1 - k);
			if(ObjAverageSlope2 < 0) {
				ObjAverageSlope2 = -ObjAverageSlope2;
			}
			Dis3 = Dis2 * 2 / 3;
			Dis1 = Dis2 * ObjAverageSlope2 * APACal.APASlotObjTypeCheckObjStartPtCalDeltaObjDisSlopeRatio[Obj1Or2Index] / (APA_SLOT_OBJ_PT_SLOPE_ZOOM_TIMES * 10) + Dis3;
			if(Dis1 < Dis2) {
				Dis2 = Dis3;
			}
#else
			k = NearestObjDisIndex1;
			while(k > 0) {
				k --;
				if((k > 0)
						&& (ObjPtSlopeBuf[k - 1] > ObjPtSlopeBuf[k])) {
					break;
				}
			}
			if(k == 0) {
				k ++;
			}
			if(k < (NearestObjDisIndex1 - 2)) {
				ObjPtSlope2 = APASlotProcCalTwoObjPtSlope(
						pSlot->CarCenterPoint[ObjPtIndexBuf[k]],
						pSlot->CarCenterPoint[ObjPtIndexBuf[NearestObjDisIndex1]],
						pSlot->DisFromCarToObj[ObjPtIndexBuf[k]],
						NearestObjDis1);
				if((ObjPtSlope2 > 10)
						&& (ObjPtSlope2 < 30)) {
					// slope = 20 ~ 45 deg.
					ObjAverageSlope2 = ObjPtSlope2;
					Dis3 = Dis2 * 2 / 3;
					Dis1 = Dis2 * ObjAverageSlope2 * APACal.APASlotObjTypeCheckObjStartPtCalDeltaObjDisSlopeRatio[Obj1Or2Index] / (APA_SLOT_OBJ_PT_SLOPE_ZOOM_TIMES * 10) + Dis3;
					if(Dis1 < Dis2) {
						Dis2 = Dis1;
					}
				}
			}
#endif
		}

#endif
#ifdef APA_SLOT_OBJ2_COMPENSATE_DIS_DEBUG
    if (Obj1Or2Index == 1) {
      APASlotObj2CompensateDisCalDeltaObjDisDebug = Dis2;
      APASlotPTSlopeDebug                         = ObjPtSlope2;
    }
#endif

    FirstInflexionPtIndex = ObjPtIndexBuf[0];
    for (m = 0; m < NearestObjDisIndex1; m++) {

      // add for debug 20141128 start
      if ((m >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
        return APA_SLOT_OBJ_TYPE_UNKNOWN;
      }
      // add for debug 20141128 end

      Dis1 = pSlot->DisFromCarToObj[ObjPtIndexBuf[m]] - NearestObjDis1;
      if (Dis1 <= Dis2) {
        break;
      }
    }
#if 0
		if(ObjType <= APA_SLOT_OBJ_TYPE_SQUARE_OBJ_WITH_FALLING_SHAPE) {
			k = APA_SLOT_OBJ_COMP_TYPE_SQUARE_OBJ;
		} else if(ObjType <= APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_RISING_AND_FLAT_SHAPE) {
			k = APA_SLOT_OBJ_COMP_TYPE_ROUND_OBJ_WITH_RISING_SHAPE_ONLY;
		} else if(ObjType == APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_SMALL_RISING_AND_FALLING_SHAPE) {
			k = APA_SLOT_OBJ_COMP_TYPE_ROUND_OBJ_WITH_SMALL_RISING_AND_FALLING_SHAPE;
		} else if(ObjType <= APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_BIG_RISING_AND_FALLING_SHAPE) {
			k = APA_SLOT_OBJ_COMP_TYPE_ROUND_OBJ_WITH_NORMAL_RISING_AND_FALLING_SHAPE;
		} else if(ObjType <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_NORMAL_FLAT_BIG_WIDTH) {
			k = APA_SLOT_OBJ_COMP_TYPE_PER_CAR_WITH_SMALL_FLAT_SMALL_WIDTH
			+ ObjType - APA_SLOT_OBJ_TYPE_PER_CAR_WITH_SMALL_FLAT_SMALL_WIDTH;
		} else if(ObjType == APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_BIG_WIDTH) {
			k = APA_SLOT_OBJ_COMP_TYPE_PER_CAR_WITH_NORMAL_FLAT_BIG_WIDTH;
		} else if(ObjType <= APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_30DEG_FLAT_SHAPE_AT_START) {
			k = APA_SLOT_OBJ_COMP_TYPE_CAR_ANGULAR_NEG_10DEG_RISING_SHAPE_AT_START
			+ ((ObjType - APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_10DEG_RISING_SHAPE_AT_START) & 0x01);
		} else if(ObjType <= APA_SLOT_OBJ_TYPE_CAR_ANGULAR_30DEG_FLAT_SHAPE_AT_START) {
			k = APA_SLOT_OBJ_COMP_TYPE_CAR_ANGULAR_10DEG_RISING_SHAPE_AT_START
			+ ((ObjType - APA_SLOT_OBJ_TYPE_CAR_ANGULAR_10DEG_RISING_SHAPE_AT_START) & 0x01);
		} else {
			k = APA_SLOT_OBJ_COMP_TYPE_PARALLEL_CAR_WITH_SMALL_RISING_SHAPE
			+ ObjType - APA_SLOT_OBJ_TYPE_PARALLEL_CAR_WITH_SMALL_RISING_SHAPE;
		}
		CompensateDis1 = APACal.APASlotObjTypeCheckObjStartPtCompensateDis[Obj1Or2Index][k][SpeedIndex];
#else
    if (ObjType <= APA_SLOT_OBJ_TYPE_SQUARE_OBJ_WITH_FALLING_SHAPE) {
      k = APA_SLOT_OBJ_COMP_TYPE_SQUARE_OBJ;
    } else if (ObjType <= APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_RISING_AND_FLAT_SHAPE) {
      k = APA_SLOT_OBJ_COMP_TYPE_ROUND_OBJ_WITH_RISING_SHAPE_ONLY;
    } else if (ObjType == APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_SMALL_RISING_AND_FALLING_SHAPE) {
      k = APA_SLOT_OBJ_COMP_TYPE_ROUND_OBJ_WITH_SMALL_RISING_AND_FALLING_SHAPE;
    } else if (ObjType <= APA_SLOT_OBJ_TYPE_ROUND_OBJ_WITH_BIG_RISING_AND_FALLING_SHAPE) {
      k = APA_SLOT_OBJ_COMP_TYPE_ROUND_OBJ_WITH_NORMAL_RISING_AND_FALLING_SHAPE;
    } else if (ObjType <= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_NORMAL_FLAT_BIG_WIDTH) {
      k = APA_SLOT_OBJ_COMP_TYPE_PER_CAR_WITH_SMALL_FLAT_SMALL_WIDTH + ObjType - APA_SLOT_OBJ_TYPE_PER_CAR_WITH_SMALL_FLAT_SMALL_WIDTH;
    } else if (ObjType == APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_BIG_WIDTH) {
      k = APA_SLOT_OBJ_COMP_TYPE_PARALLEL_CAR_WITH_SMALL_RISING_SHAPE;
    } else if (ObjType <= APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_30DEG_FLAT_SHAPE_AT_START) {
      k = APA_SLOT_OBJ_COMP_TYPE_CAR_ANGULAR_NEG_10DEG_RISING_SHAPE_AT_START +
          ((ObjType - APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_10DEG_RISING_SHAPE_AT_START) & 0x01);
    } else if (ObjType <= APA_SLOT_OBJ_TYPE_CAR_ANGULAR_30DEG_FLAT_SHAPE_AT_START) {
      k = APA_SLOT_OBJ_COMP_TYPE_CAR_ANGULAR_10DEG_RISING_SHAPE_AT_START +
          ((ObjType - APA_SLOT_OBJ_TYPE_CAR_ANGULAR_10DEG_RISING_SHAPE_AT_START) & 0x01);
    } else {
      k = APA_SLOT_OBJ_COMP_TYPE_PARALLEL_CAR_WITH_SMALL_RISING_SHAPE + ObjType - APA_SLOT_OBJ_TYPE_PARALLEL_CAR_WITH_SMALL_RISING_SHAPE;
    }
    for (CarToObjDisCmpIndex = 0; CarToObjDisCmpIndex < APA_SLOT_OBJ_CAR_TO_OBJ_DIS_COMPENSATE_TYPE_NUM; CarToObjDisCmpIndex++) {
      if (NearestObjDis1 < APACal.APASlotDetectionCompensateCarToObjDisDevidedThreshold[CarToObjDisCmpIndex]) {
        break;
      }
    }
    if ((SpeedIndex == 0) || (SpeedIndex == APA_SLOT_SUPPORT_SLOT_LENGTH_COMPENSATE_SPEED_DEVIDED_NUM)) {
      // 7 kph >= speed || speed > 25 kph
      if (SpeedIndex == APA_SLOT_SUPPORT_SLOT_LENGTH_COMPENSATE_SPEED_DEVIDED_NUM) {
        SpeedIndex--;
      }
      if ((CarToObjDisCmpIndex == 0) || (CarToObjDisCmpIndex == APA_SLOT_OBJ_CAR_TO_OBJ_DIS_COMPENSATE_TYPE_NUM)) {
        if (CarToObjDisCmpIndex == APA_SLOT_OBJ_CAR_TO_OBJ_DIS_COMPENSATE_TYPE_NUM) {
          CarToObjDisCmpIndex--;
        }
        CompensateDis1 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisBySpdAndCarToObjDis[Obj1Or2Index][k][CarToObjDisCmpIndex][SpeedIndex];
      } else {
        X1 = APACal.APASlotDetectionCompensateCarToObjDisDevidedThreshold[CarToObjDisCmpIndex - 1];
        X2 = APACal.APASlotDetectionCompensateCarToObjDisDevidedThreshold[CarToObjDisCmpIndex];
        Y1 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisBySpdAndCarToObjDis[Obj1Or2Index][k][CarToObjDisCmpIndex - 1][SpeedIndex];
        Y2 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisBySpdAndCarToObjDis[Obj1Or2Index][k][CarToObjDisCmpIndex][SpeedIndex];
        CompensateDis1 = (APA_DISTANCE_TYPE)APATrajCalTwoPointInterpolationCalculation(Y1, Y2, X1, X2, NearestObjDis1);
      }
    } else {
      // 7 kph <= speed < 25 kph
      if ((CarToObjDisCmpIndex == 0) || (CarToObjDisCmpIndex == APA_SLOT_OBJ_CAR_TO_OBJ_DIS_COMPENSATE_TYPE_NUM)) {
        if (CarToObjDisCmpIndex == APA_SLOT_OBJ_CAR_TO_OBJ_DIS_COMPENSATE_TYPE_NUM) {
          CarToObjDisCmpIndex--;
        }
        X1 = APACal.APASlotDetectionCompensateSpeedDevidedThreshold[SpeedIndex - 1];
        X2 = APACal.APASlotDetectionCompensateSpeedDevidedThreshold[SpeedIndex];
        Y1 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisBySpdAndCarToObjDis[Obj1Or2Index][k][CarToObjDisCmpIndex][SpeedIndex - 1];
        Y2 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisBySpdAndCarToObjDis[Obj1Or2Index][k][CarToObjDisCmpIndex][SpeedIndex];
        CompensateDis1 = APATrajCalTwoPointInterpolationCalculation(Y1, Y2, X1, X2, CarCurrentSpd);
      } else {
        X1 = APACal.APASlotDetectionCompensateSpeedDevidedThreshold[SpeedIndex - 1];
        X2 = APACal.APASlotDetectionCompensateSpeedDevidedThreshold[SpeedIndex];
        Y1 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisBySpdAndCarToObjDis[Obj1Or2Index][k][CarToObjDisCmpIndex - 1][SpeedIndex - 1];
        Y2 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisBySpdAndCarToObjDis[Obj1Or2Index][k][CarToObjDisCmpIndex - 1][SpeedIndex];
        fDis1 = APATrajCalTwoPointInterpolationCalculation(Y1, Y2, X1, X2, CarCurrentSpd);

        X1 = APACal.APASlotDetectionCompensateSpeedDevidedThreshold[SpeedIndex - 1];
        X2 = APACal.APASlotDetectionCompensateSpeedDevidedThreshold[SpeedIndex];
        Y1 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisBySpdAndCarToObjDis[Obj1Or2Index][k][CarToObjDisCmpIndex][SpeedIndex - 1];
        Y2 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisBySpdAndCarToObjDis[Obj1Or2Index][k][CarToObjDisCmpIndex][SpeedIndex];
        fDis2 = APATrajCalTwoPointInterpolationCalculation(Y1, Y2, X1, X2, CarCurrentSpd);

        X1 = APACal.APASlotDetectionCompensateCarToObjDisDevidedThreshold[CarToObjDisCmpIndex - 1];
        X2 = APACal.APASlotDetectionCompensateCarToObjDisDevidedThreshold[CarToObjDisCmpIndex];
        Y1 = fDis1;
        Y2 = fDis2;
        CompensateDis1 = (APA_DISTANCE_TYPE)APATrajCalTwoPointInterpolationCalculation(Y1, Y2, X1, X2, NearestObjDis1);
      }
    }
#endif

    // cal slot compensate dis
    if (ObjType < APA_SLOT_OBJ_TYPE_PER_CAR_WITH_SMALL_FLAT_BIG_WIDTH) {
      // Obj1: Small obj with flat or rising end. obj width < 2.3m,
      j = 0;
    } else if (ObjType < APA_SLOT_OBJ_TYPE_PER_CAR_WITH_BIG_FLAT_BIG_WIDTH) {
      // Obj1: per car big width 2.3 ~ 3.2m.
      j = 1;
    } else {
      // Obj1: per car big flat or angular car or parallel car.
      j = 2;
    }
    CompensateDis2 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisWithFlatEnd[Obj1Or2Index][j];
    CompensateDis3 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisRatioWithSmallRising[Obj1Or2Index][j];

    if ((m == 0) && ((NearestObjDisIndex1 == 0) || ((pSlot->DisFromCarToObj[ObjPtIndexBuf[0]] - NearestObjDis1) <=
                                                    APACal.APASlotObjTypeCheckObjStartPtCalRegardedAsFlatStartPtMaxDeltaObjDis))) {
      // it is a flat end or rising end object.
      /*

       * <- flat end. or   * <- rising end.
       *                    *
       *                    *
       *                    *

       */
      CompensateDis1 = CompensateDis2;
    } else {
      bCheckObjSmallEndWidth = FALSE;
      if (m > 0) {
        h = m - 1;

        // add for debug 20141128 start
        if ((h >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
          return APA_SLOT_OBJ_TYPE_UNKNOWN;
        }
        // add for debug 20141128 end

        Dis1 = pSlot->DisFromCarToObj[ObjPtIndexBuf[h]] - NearestObjDis1;
        if (Dis1 < APACal.APASlotObjTypeCheckObjStartPtCalRegardedAsObjStartPtMaxDeltaObjDis[Obj1Or2Index]) {
          // OK, regarded m as the obj start point to be compensated.
          /*

           *
           * <- h

           + <- the actual pos to be started compensation.
           * <- m
           * <- nearest dis.
           *
           *
           */

          // add for debug 20141128 start
          if ((NearestObjDisIndex1 >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM) || (m >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
            return APA_SLOT_OBJ_TYPE_UNKNOWN;
          }
          // add for debug 20141128 end

          Dis3 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[NearestObjDisIndex1]],
                                                      pSlot->CarCenterPoint[ObjPtIndexBuf[m]]);
          if (Dis3 <= CompensateDis3) {
            // The width between obj start pt and nearest dis pt (inflexion pt) is too short.
            bCheckObjSmallEndWidth = TRUE;
            if (Dis3 < APACal.APASlotObjTypeCheckObjStartPtCalRegardAsCompStPtTooShortDis[Obj1Or2Index][j]) {

              // add for debug 20141128 start
              if ((NearestObjDisIndex1 >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM) || (h >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
                return APA_SLOT_OBJ_TYPE_UNKNOWN;
              }
              // add for debug 20141128 end

              Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[NearestObjDisIndex1]],
                                                          pSlot->CarCenterPoint[ObjPtIndexBuf[h]]);
              if (Dis1 < APACal.APASlotObjTypeCheckObjStartPtCalRegardAsCompStPtMaxWidth[Obj1Or2Index][j]) {
                // OK, regarded m as the obj start point to be compensated.
                /*
                 *
                 * <- h: compensate start pt.
                 * <- nearest dis. 'm'
                 *
                 *
                 */

                m = h;
              } else {
                // still use m to cal.
              }
            } else {
              // Still use m to cal.
            }
          } else {
            // The obj end width is enough to be compensated. just use the m as the start comp pt.
            /*

             *
             * <- h

             * <- m: the actual pos to be started compensation.

             * <- nearest dis.
             *
             *
             */
            if (Obj1Or2Index == 0) {
              // Obj1.
              // just compensate CompensateDis1 start from m.
            } else {
              // Obj2.
              // check the following: a very big rising shape due to a big round car and sensor sensitivity is big.
              /*
               * <- nearest dis.
               *

               *

               *

               * <- m.

               *
               */
              if ((ObjType >= APA_SLOT_OBJ_TYPE_PER_CAR_WITH_SMALL_FLAT_NORMAL_WIDTH) &&
                  (ObjType < APA_SLOT_OBJ_TYPE_PARALLEL_CAR_WITH_SMALL_RISING_SHAPE) &&
                  (Dis3 > APACal.APASlotObjTypeCheckObjStartPtCalRegardedAsObj2BigPerCarRisingShapeWidth)) {
                // > 1.1m
                // expended the compensated dis. due to very big rising shape.
                if (ObjType < APA_SLOT_OBJ_TYPE_CAR_ANGULAR_NEG_10DEG_RISING_SHAPE_AT_START) {
                  // per car.
                  CompensateDis1 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisWithObj2BigPerCarRisingShapeWidth[0];
                } else {
                  // angular car.
                  CompensateDis1 = APACal.APASlotObjTypeCheckObjStartPtCompensateDisWithObj2BigPerCarRisingShapeWidth[1];
                }
              }
            }
          }
        } else {
          /*
           *
           * <- h out of tol.

           * <- or 'm'
           *<- nearest dis. 'm'
           *
           */
          if (m == NearestObjDisIndex1) {
            // m is the nearest dis.
            // regarded 'NearestObjDisIndex1' as the obj start point to be compensated.
            // regarded as flat end point ??
            /*
             *
             * <- h out tol.

             * <- nearest dis. 'm'
             *
             *
             */

            CompensateDis1 = CompensateDis2;
          } else {
            /*
             *
             * <- h out of tol.

             * <- m
             *<- nearest dis.
             *
             */
            bCheckObjSmallEndWidth = TRUE;
          }
        }
        // add for debug 20141128 start
        if ((m >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
          return APA_SLOT_OBJ_TYPE_UNKNOWN;
        }
        // add for debug 20141128 end

        FirstInflexionPtIndex = ObjPtIndexBuf[m];
      } else {
        // m == 0.
        /*

         * <- m
         *
         * <- nearest dis.
         *
         *

         */
        bCheckObjSmallEndWidth = TRUE;

        // check the following case:

        /*
         * <- m (noise)


         *
         *
         * <- nearest dis
         *
         *

         */

        if ((NearestObjDisIndex1 > m) && (ObjPtSlopeBuf[0] > APACal.APASlotObjTypeCheckObjStartPtCalRegardedAsNoiseMinObjEndPtSlope) &&
            ((ObjPtSlopeBuf[0] - ObjPtSlopeBuf[1]) > APACal.APASlotObjTypeCheckObjStartPtCalRegardedAsNoiseMinObjEndPtDeltaSlope)) {
          // Noise confirmed. remove it.
          m++;

          // add for debug 20141128 start
          if ((m >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
            return APA_SLOT_OBJ_TYPE_UNKNOWN;
          }
          // add for debug 20141128 end

          FirstInflexionPtIndex = ObjPtIndexBuf[m];
        }
      }
      if (bCheckObjSmallEndWidth == TRUE) {

        // Not a flat end,
        // a very short end.
        /*

         * <- obj end. obj compensate start pt.
         * <- nearest obj dis.
         *
         *

         */

        // add for debug 20141128 start
        if ((NearestObjDisIndex1 >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM) || (m >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
          return APA_SLOT_OBJ_TYPE_UNKNOWN;
        }
        // add for debug 20141128 end

        Dis1 =
            APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjPtIndexBuf[NearestObjDisIndex1]], pSlot->CarCenterPoint[ObjPtIndexBuf[m]]);
        Dis1 = CompensateDis1 * Dis1 / CompensateDis3;
        if (Dis1 < CompensateDis1) {
          CompensateDis1 = Dis1;
        } else {
          // just comp Dis3.
          /*

           * <- obj st pt.         ---
           | rising width is big than the compensate width.
           |
           * <- nearest dis index   ---
           *
           *
           */
        }
      }
    }
    // cal dis to Obj :pSlot->DisFromCarToObj[FirstInflexionPtIndex]
    // obj st index
    (*pSlotStartIndex)    = FirstInflexionPtIndex;
    (*pObjStartIndex)     = ObjPtIndexBuf[0];

    // add for debug 20141128 start
    if ((ObjPtIndexNum >= APA_SLOT_OBJ_TYPE_CHECK_OBJ_PT_BUF_NUM)) {
      return APA_SLOT_OBJ_TYPE_UNKNOWN;
    }
    // add for debug 20141128 end

    // stack overflow here 20141128
    (*pObjEndIndex) = ObjPtIndexBuf[ObjPtIndexNum];
    (*pObjWidth)    = ObjTotalWidthTemp;
    ObjTotalWidthTemp /= 2;
    if (CompensateDis1 > ObjTotalWidthTemp) {
      CompensateDis1 = ObjTotalWidthTemp;
    }
    (*pAPASlotDetectionCompensateLength) = CompensateDis1;
  }
  return ObjType;
}

#endif


APA_ENUM_TYPE APASlotProcCheckSlotLengthIsLargeEnough(APA_INDEX_TYPE *pSlotStartPtIndex,
                                                      APA_INDEX_TYPE *pSlotEndPtIndex,
                                                      APASlotOutlineCoordinateDataType *pSlot,
                                                      APA_DISTANCE_TYPE *pSlotCalDisCarToObj1,
                                                      APA_DISTANCE_TYPE *pSlotCalDisCarToObj2,
                                                      APA_ENUM_TYPE APACalObjPtSnsIndex,
#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
                                                      BOOLEAN bSlotHeadCompensated,
                                                      BOOLEAN bSlotTailCOmpensated,
#endif
                                                      APA_DISTANCE_TYPE SlotDepth,
                                                      APA_DISTANCE_TYPE *APASlotDetectionCompensateLengthHead,
                                                      APA_DISTANCE_TYPE *APASlotDetectionCompensateLengthTail,
                                                      APA_DISTANCE_TYPE *pSlotLen, // Total slot len,
                                                      APA_DISTANCE_TYPE SlotDepth1,
                                                      APA_DISTANCE_TYPE SlotDepth2,
                                                      APA_DISTANCE_TYPE SlotDepth3,
                                                      APA_DISTANCE_TYPE *pSlotLen1,
                                                      APA_DISTANCE_TYPE *pSlotLen2,
                                                      APA_DISTANCE_TYPE *pSlotLen3,
                                                      APA_INDEX_TYPE Obj1BdStartIndex,
                                                      APA_INDEX_TYPE Obj1BdEndIndex,
                                                      APA_INDEX_TYPE Obj2BdStartIndex,
                                                      APA_INDEX_TYPE Obj2BdEndIndex,
                                                      APA_ENUM_TYPE *pObj1StartIndex,
                                                      APA_ENUM_TYPE *pObj1EndIndex,
                                                      APA_ENUM_TYPE *pObj2StartIndex,
                                                      APA_ENUM_TYPE *pObj2EndIndex,
                                                      APA_DISTANCE_TYPE *pObj1Width,
                                                      APA_DISTANCE_TYPE *pObj2Width,
                                                      APA_ENUM_TYPE *pObj1Type,
                                                      APA_ENUM_TYPE *pObj2Type

) {
  if (DebugLargeEnough == 0)
  {
    return APA_SLOT_TYPE_INVALID;
  }
  // Notes:
  // (*pSlotCalDisCarToObj1) should not equal to NO_OBJ_DISTANCE,
  // (*pSlotCalDisCarToObj2) should not equal to NO_OBJ_DISTANCE.
  APA_DISTANCE_TYPE L, LTemp, SlotLen, CarPosDeltaDis, SlotDepthRefCarSide, Dis1;
  APA_DISTANCE_TYPE MinLen, MaxLen, MinSlotDepth, SlotHeadCompDis, SlotTailCompDis;
  APA_INDEX_TYPE CmpIndex, i, j, NoObjDisCnt;
  APA_INDEX_TYPE Index, ObjStIndex, Index2, NoObjStartIndex, NearestDistObjIndex;
  APA_ENUM_TYPE Obj1Type, Obj2Type;
  APA_CAL_FLOAT_TYPE fTemp, fTemp2;
  APACoordinateDataCalFloatType Pt1, Pt2, CarCenterPt;
  BOOLEAN bRecorrectSlotLen, bSlotFound;
  APACoordinateDataType StPt;
  UCHAR CarCurrentSpd;

  /*
   Scenario1:
   if the DisFromCarToObj1 of Pt1 is equal to NO_OBJ_DISTANCE
   and the the DisFromCarToObj2 of Pt2 is equal to
   NO_OBJ_DISTANCE, it will return APA_SLOT_TYPE_INVALID.

   Scenario2:
   if the DisFromCarToObj1 of Pt1 is equal to NO_OBJ_DISTANCE
   and the the DisFromCarToObj2 of Pt2 isn't equal to
   NO_OBJ_DISTANCE, a point will be made up as Pt1 by the
   Pt1 coordinate passed from exterior and DisFromCarToObj2.
   the slot length will calculate by new Pt1 and Pt2.


   DisFromCarToObj2|
   -------->|
   +_______
   Pt2 	|
   |
   _______			  		|
   |	  |					|
   |	  |---------------->|
   |	  |					|
   | Car |			  		|
   |	  |					|
   |_____|				  	|
   |
   Pt1	+		|
   |
   DisFromCarToObj1 = NO_OBJ_DISTANCE
   ---------------->


   Scenario3:

   if the DisFromCarToObj1 of Pt1 isn't equal to NO_OBJ_DISTANCE
   and the the DisFromCarToObj2 of Pt2 is equal to NO_OBJ_DISTANCE,
   a point will be made up as Pt2 by the Pt2 coordinate passed
   from exterior and DisFromCarToObj1.
   the slot length will calculate by Pt1 and new Pt2.

   DisFromCarToObj2 = NO_OBJ_DISTANCE
   ---------------->|
   Pt2  + 		|
   |
   _______			  		|
   |	  |					|
   |	  |---------------->|
   |	  |					|
   | Car |			  		|
   |	  |					|
   |_____|				  	|
   |
   |
   Pt1 ______|
   +
   DisFromCarToObj1|
   -------->|
   |
   |


   Scenario4:
   if the DisFromCarToObj1 of Pt1 isn't equal to NO_OBJ_DISTANCE
   and the the DisFromCarToObj2 of Pt2 isn't equal to NO_OBJ_DISTANCE,
   the slot length will calculate by Pt1 and Pt2
   */

  fTemp = USSPar.APAVehicleSpeed;

  fTemp *= 3.6; // => km/h.

  if (fTemp > 250) {
    fTemp = 250; // 250kph
  }

  CarCurrentSpd = (APA_ENUM_TYPE)fTemp;
  for (CmpIndex = 0; CmpIndex < (APA_SLOT_SUPPORT_SLOT_LENGTH_COMPENSATE_SPEED_DEVIDED_NUM); CmpIndex++) {
    if (CarCurrentSpd < APACal.APASlotDetectionCompensateSpeedDevidedThreshold[CmpIndex]) {
      break;
    }
  }

  (*pObj1StartIndex) = (*pSlotStartPtIndex);
  (*pObj1EndIndex)   = (*pSlotStartPtIndex);

  (*pObj2StartIndex) = (*pSlotEndPtIndex);
  (*pObj2EndIndex)   = (*pSlotEndPtIndex);
  (*pObj1Width)      = 0;
  (*pObj2Width)      = 0;

  Obj1Type = APA_SLOT_OBJ_TYPE_UNKNOWN;
  Obj2Type = APA_SLOT_OBJ_TYPE_UNKNOWN;

  // cal obj1 cmp dis
  if ((*pSlotCalDisCarToObj1) != NO_OBJ_DISTANCE) {
    // Cal obj1 bd end index.
    ObjStIndex = (*pSlotStartPtIndex);
    StPt       = pSlot->CarCenterPoint[ObjStIndex];
    if (Obj1BdEndIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
      Obj1BdEndIndex = 0;
      LTemp          = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[0], StPt);
      if (LTemp > APACal.APASLotObjTypeCheckMaxObjWidth) {
        Index          = ObjStIndex / 2;
        Obj1BdEndIndex = Index;
        while (Index > 0) {
          LTemp = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[Obj1BdEndIndex], StPt);

          Index /= 2;
          if (LTemp > APACal.APASLotObjTypeCheckMaxObjWidth) {
            Obj1BdEndIndex += Index;
          } else if (LTemp > (APACal.APASLotObjTypeCheckMaxObjWidth - 500)) {
            // OK
            break;
          } else {
            Obj1BdEndIndex -= Index;
          }
        }
      }
    }
    // get rid of the points with very big delta sns det obj dis.
    ObjStIndex = (*pSlotStartPtIndex);
    Index      = ObjStIndex - 5;
    if (Index < 0) {
      Index = 0;
    }
    Index2 = ObjStIndex;
    LTemp  = pSlot->DisFromCarToObj[Index2];
    while (ObjStIndex > Index) {
      ObjStIndex--;
      Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjStIndex], StPt);
      if (Dis1 > APACal.APASlotObjTypeCheckObjStPtAllowSearchDisFromSlotStPt) {
        break;
      }

      if (LTemp > pSlot->DisFromCarToObj[ObjStIndex]) {
        LTemp  = pSlot->DisFromCarToObj[ObjStIndex];
        Index2 = ObjStIndex;
      }
    }
    while (Obj1BdStartIndex > Index2) {
      if ((pSlot->DisFromCarToObj[Obj1BdStartIndex] - LTemp) < APACal.APASlotObjTypeCheckAllowMaxDeltaSnsDtObjDisFromObjStPt) {
        break;
      }
      Obj1BdStartIndex--;
    }

    LTemp               = pSlot->DisFromCarToObj[Obj1BdStartIndex];
    Index               = Obj1BdStartIndex;
    NearestDistObjIndex = Obj1BdStartIndex;
    while (Index > Obj1BdEndIndex) {
      Index--;
      L = pSlot->DisFromCarToObj[Index];
      if (L < LTemp) {
        LTemp               = L;
        NearestDistObjIndex = Index;
      }
    }
    for (i = NearestDistObjIndex; i > Obj1BdEndIndex; i--) {
      L = pSlot->DisFromCarToObj[i];
      if ((L - LTemp) > APACal.APASLotObjTypeCheckMaxCarToObjDeltaDis) {
        j           = i;
        NoObjDisCnt = 0;
        while (j >= Obj1BdEndIndex) {
          j--;
          L = pSlot->DisFromCarToObj[j];
          if ((L - LTemp) > APACal.APASLotObjTypeCheckMaxCarToObjDeltaDis) {
            NoObjDisCnt++;
          } else {
            break;
          }
        }
        if ((NoObjDisCnt > 3) || (NoObjDisCnt == (i - Obj1BdEndIndex))) {
          break;
        }
      }
    }
    if ((i != Obj1BdEndIndex) && (i > 0)) {
      Obj1BdEndIndex = i + 1;
    }
    Obj1Type = APASlotProcCheckSlotObjTypeAndStartPtAndCompDis(Obj1BdStartIndex,
                                                               Obj1BdEndIndex,
                                                               CmpIndex,
                                                               CarCurrentSpd,
                                                               pSlotStartPtIndex,
                                                               pObj1StartIndex,
                                                               pObj1EndIndex,
                                                               pSlot,
                                                               pObj1Width,
                                                               &SlotTailCompDis);
#ifdef APA_SLOT_SUPPORT_DEBUG1

    if ((Obj1Type != APA_SLOT_OBJ_TYPE_UNKNOWN) && (((*pSlotStartPtIndex) < (*pObj1EndIndex)) || ((*pSlotStartPtIndex) > (*pObj1StartIndex)))) {

      // Data error ??
      cSlotDebug = 1;
    }

#endif

  } else {
    (*pSlotCalDisCarToObj1) = (*pSlotCalDisCarToObj2);
  }
  if ((*pSlotCalDisCarToObj2) != NO_OBJ_DISTANCE) {
    ObjStIndex = (*pSlotEndPtIndex);
    StPt       = pSlot->CarCenterPoint[ObjStIndex];
    if (Obj2BdEndIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
      Obj2BdEndIndex = pSlot->ObjPtCnt - 1;
      LTemp          = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[Obj2BdEndIndex], StPt);
      if (LTemp > APACal.APASLotObjTypeCheckMaxObjWidth) {
        Index          = Obj2BdEndIndex / 2;
        Obj2BdEndIndex = Index;
        while (Index > 0) {
          LTemp = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[Obj2BdEndIndex], StPt);

          Index /= 2;
          if (LTemp > APACal.APASLotObjTypeCheckMaxObjWidth) {
            Obj2BdEndIndex -= Index;
          } else if (LTemp > (APACal.APASLotObjTypeCheckMaxObjWidth - 600)) {
            // OK
            break;
          } else {
            Obj2BdEndIndex += Index;
          }
        }
      }
    }
    ObjStIndex = (*pSlotEndPtIndex);
    while (Obj2BdStartIndex < ObjStIndex) {
      if ((pSlot->DisFromCarToObj[Obj2BdStartIndex] -
           (*pSlotCalDisCarToObj2)) //(pSlot->DisFromCarToObj[Obj2BdStartIndex] - pSlot->DisFromCarToObj[ObjStIndex])
          < APACal.APASlotObjTypeCheckAllowMaxDeltaSnsDtObjDisFromObjStPt) {
        break;
      }
      Obj2BdStartIndex++;
    }
    LTemp               = pSlot->DisFromCarToObj[Obj2BdStartIndex];
    Index               = Obj2BdStartIndex;
    NearestDistObjIndex = Obj2BdStartIndex;
    while (Index < Obj2BdEndIndex) {
      Index++;
      L = pSlot->DisFromCarToObj[Index];
      if (L < LTemp) {
        LTemp               = L;
        NearestDistObjIndex = Index;
      }
    }
    for (i = NearestDistObjIndex; i < Obj2BdEndIndex; i++) {
      L = pSlot->DisFromCarToObj[i];
      if ((L - LTemp) > APACal.APASLotObjTypeCheckMaxCarToObjDeltaDis) {
        j           = i;
        NoObjDisCnt = 0;
        while (j <= Obj2BdEndIndex) {
          j++;
          L = pSlot->DisFromCarToObj[j];
          if ((L - LTemp) > APACal.APASLotObjTypeCheckMaxCarToObjDeltaDis) {
            NoObjDisCnt++;
          } else {
            break;
          }
        }
        if ((NoObjDisCnt > 3) || (NoObjDisCnt == (Obj2BdEndIndex - i))) {
          break;
        }
      }
    }
    if ((i < Obj2BdEndIndex) && (i > 0)) {
      Obj2BdEndIndex = i - 1;
    }
    Obj2Type = APASlotProcCheckSlotObjTypeAndStartPtAndCompDis(Obj2BdStartIndex,
                                                               Obj2BdEndIndex,
                                                               CmpIndex,
                                                               CarCurrentSpd,
                                                               pSlotEndPtIndex,
                                                               pObj2StartIndex,
                                                               pObj2EndIndex,
                                                               pSlot,
                                                               pObj2Width,
                                                               &SlotHeadCompDis);
#ifdef APA_SLOT_SUPPORT_DEBUG1

    if ((Obj2Type != APA_SLOT_OBJ_TYPE_UNKNOWN) && (((*pSlotEndPtIndex) < (*pObj2EndIndex)) || ((*pSlotEndPtIndex) > (*pObj2StartIndex)))) {

      // Data error ??
      cSlotDebug = 2;
    }
#endif

  } else {
    (*pSlotCalDisCarToObj2) = (*pSlotCalDisCarToObj1);
  }
  SlotDepthRefCarSide = (*pSlotCalDisCarToObj1);
  if (SlotDepthRefCarSide > (*pSlotCalDisCarToObj2)) {
    SlotDepthRefCarSide = (*pSlotCalDisCarToObj2);
  }

  bRecorrectSlotLen = FALSE;
  LTemp             = MATH_ABS((*pSlotCalDisCarToObj1) - (*pSlotCalDisCarToObj2));
  if (LTemp > APACal.APASlotMaxOffsetDisBetweenObj1AndObj2ForParallel) {
    // The obj1 or obj2 will be regarded as invalid obj.
    // Slot length will be recorrected.
    bRecorrectSlotLen = TRUE;
  }
  if (SlotDepth <= (SlotDepthRefCarSide + APACal.APASlotMaxSlotDepth)) {
    // Curb detected.
    // bCurbFound = TRUE;
    // Use a straight line along curb to cal the slot len.
    /*if((*pSlotCalDisCarToObj1) > (*pSlotCalDisCarToObj2)){
     (*pSlotCalDisCarToObj1) = (*pSlotCalDisCarToObj2);
     } else {
     (*pSlotCalDisCarToObj2) = (*pSlotCalDisCarToObj1);
     }*/
    bRecorrectSlotLen = TRUE;

  } else {
    // bCurbFound = FALSE;
  }

  // Cal the car pos distance between the start and end pt.
  CarPosDeltaDis = APATrajCalGetTwoPointDisInt(pSlot->CarCenterPoint[(*pSlotStartPtIndex)].x,
                                               pSlot->CarCenterPoint[(*pSlotStartPtIndex)].y,
                                               pSlot->CarCenterPoint[(*pSlotEndPtIndex)].x,
                                               pSlot->CarCenterPoint[(*pSlotEndPtIndex)].y);

  Pt1           = APASlotProcCalSlotRelativeToCarCoordinateBySlotDisToCar((*pSlotCalDisCarToObj1), APACalObjPtSnsIndex);
  CarCenterPt.x = pSlot->CarCenterPoint[(*pSlotStartPtIndex)].x;
  CarCenterPt.y = pSlot->CarCenterPoint[(*pSlotStartPtIndex)].y;

  Pt1 = APATrajCalPointPosWithAngAndCenterPt(Pt1, pSlot->CarAng[(*pSlotStartPtIndex)], CarCenterPt);

  Pt2           = APASlotProcCalSlotRelativeToCarCoordinateBySlotDisToCar((*pSlotCalDisCarToObj2), APACalObjPtSnsIndex);
  CarCenterPt.x = pSlot->CarCenterPoint[(*pSlotEndPtIndex)].x;
  CarCenterPt.y = pSlot->CarCenterPoint[(*pSlotEndPtIndex)].y;

  Pt2 = APATrajCalPointPosWithAngAndCenterPt(Pt2, pSlot->CarAng[(*pSlotEndPtIndex)], CarCenterPt);

  fTemp = APATrajCalGetTwoPointDisFloat(Pt1, Pt2);
  if (bRecorrectSlotLen == TRUE) {
    /*
     recorrect the slot len:

     *------------>+++
     /	|
     Slot Len  /	|
     /		|
     /		|
     /		|
     *----->++++++++++

     ||
     \/

     *-------.----->++
     .		|
     .   	|
     Slot Len.  		|
     . 		|
     .		|
     *------>.++++++++

     */

    fTemp2 = LTemp;
    fTemp  = fTemp * fTemp - fTemp2 * fTemp2;
    if (fTemp > fTemp2) {
      fTemp = MATH_SQRT(fTemp);
    }
  }
  SlotLen = (APA_DISTANCE_TYPE)fTemp;
  if (Obj1Type == APA_SLOT_OBJ_TYPE_UNKNOWN) {
#if 0

#else
    Obj1Type = APA_SLOT_SIMPLE_OBJ_TYPE_UNKNOWN;
#endif

    // Check Obj1/2 width:
    NoObjStartIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
    Index           = (*pSlotStartPtIndex);
    ObjStIndex      = 0;
    while (Index >= 0) {
      if (ObjStIndex == 0) {
        if (pSlot->DisFromCarToObj[Index] == NO_OBJ_DISTANCE) {
        } else {
          ObjStIndex = Index;
        }
      } else {
        if (pSlot->DisFromCarToObj[Index] == NO_OBJ_DISTANCE) {
          if (NoObjStartIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            NoObjStartIndex = Index + 1;
            Dis1            = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[NoObjStartIndex], pSlot->CarCenterPoint[Index]);

            if (Dis1 < APACal.APASlotObjTypeCheckFlatShapeRegardedAsSmallObjMaxWidth1) {
              // keep searching
            } else {
              // No object detected is confirmed.
              break;
            }
          } else {
            Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[NoObjStartIndex], pSlot->CarCenterPoint[Index]);

            if (Dis1 < APACal.APASlotObjTypeCheckFlatShapeRegardedAsSmallObjMaxWidth1) {
              // keep searching
            } else {
              // No object detected is confirmed.
              break;
            }
          }
        } else {
          NoObjStartIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
        }
      }
      Index--;
    }
    Index++;
    (*pObj1Width)      = 0;
    (*pObj1StartIndex) = ObjStIndex;
    (*pObj1EndIndex)   = Index;
    SlotTailCompDis    = APACal.APASlotDetectionCompensateLengthTail[Obj1Type][CmpIndex];
    if ((Index < ObjStIndex)) {
      LTemp         = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[Index], pSlot->CarCenterPoint[ObjStIndex]);
      (*pObj1Width) = LTemp;
      LTemp /= 2;
      if (LTemp < SlotTailCompDis) {
        SlotTailCompDis = LTemp;
      }
    }
  } else {
    (*pSlotCalDisCarToObj1) = pSlot->DisFromCarToObj[(*pSlotStartPtIndex)];
  }
  //SlotTailCompDis = 0; /* 20200826 */
  if (Obj2Type == APA_SLOT_OBJ_TYPE_UNKNOWN) {
#if 0

		Obj2Type = pSlot->ObjType[(*pSlotEndPtIndex)];

		if(Obj2Type >= APA_SLOT_SUPPORT_SIMPLE_OBJ_TYPE_NUM) {
			Obj2Type = APA_SLOT_SIMPLE_OBJ_TYPE_UNKNOWN;
		}

#else

    Obj2Type = APA_SLOT_SIMPLE_OBJ_TYPE_UNKNOWN;
#endif

    // Check Obj1/2 width:
    ObjStIndex      = 0;
    NoObjStartIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
    for (Index = (*pSlotEndPtIndex); Index < pSlot->ObjPtCnt; Index++) {
      if (ObjStIndex == 0) {
        if (pSlot->DisFromCarToObj[Index] == NO_OBJ_DISTANCE) {
        } else {
          ObjStIndex = Index;
        }
      } else {
        if (pSlot->DisFromCarToObj[Index] == NO_OBJ_DISTANCE) {
          if (NoObjStartIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            NoObjStartIndex = Index;
          } else {
            Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[NoObjStartIndex], pSlot->CarCenterPoint[Index + 1]);

            if (Dis1 < APACal.APASlotObjTypeCheckFlatShapeRegardedAsSmallObjMaxWidth1) {
              // keep searching
            } else {
              // No object detected is confirmed.
              break;
            }
          }
        } else {
          if (NoObjStartIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
          } else {
            Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[NoObjStartIndex], pSlot->CarCenterPoint[Index]);

            if (Dis1 < APACal.APASlotObjTypeCheckFlatShapeRegardedAsSmallObjMaxWidth1) {
              // keep searching
            } else {
              // No object detected is confirmed.
              break;
            }
          }
          NoObjStartIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
        }
      }
    }
    (*pObj2Width) = 0;
    if (ObjStIndex == 0) {
      (*pObj2StartIndex) = Index;
    } else {
      (*pObj2StartIndex) = ObjStIndex;
    }
    (*pObj2EndIndex) = Index;
    SlotHeadCompDis  = APACal.APASlotDetectionCompensateLengthHead[Obj2Type][CmpIndex];
    if ((Index > ObjStIndex) && (ObjStIndex != 0)) {
      LTemp         = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[Index], pSlot->CarCenterPoint[ObjStIndex]);
      (*pObj2Width) = LTemp;
      LTemp /= 2;
      if (LTemp < SlotHeadCompDis) {
        SlotHeadCompDis = LTemp;
      }
    }
  } else {
    (*pSlotCalDisCarToObj2) = pSlot->DisFromCarToObj[(*pSlotEndPtIndex)];
  }
//SlotHeadCompDis = 0; /* 20200826 */
  (*pObj1Type) = Obj1Type;
  (*pObj2Type) = Obj2Type;

  Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[Obj1BdStartIndex], pSlot->CarCenterPoint[Obj2BdStartIndex]);

  if (Dis1 < APACal.APASLotMinObj1AndObj2BdStartPtWidth) {
    // slot length is too small
    (*pSlotLen) = 0;
    return APA_SLOT_TYPE_INVALID;
  }

#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
  if (bSlotHeadCompensated == FALSE)
#endif
  {
    CarPosDeltaDis += SlotHeadCompDis;
    SlotLen += SlotHeadCompDis;
    if ((*pSlotLen1) != 0) {
      (*pSlotLen1) += SlotHeadCompDis;
    }
    /*if((*pSlotLen2) != 0){
     (*pSlotLen2) += SlotHeadCompDis;
     }*/
    if ((*pSlotLen3) != 0) {
      (*pSlotLen3) += SlotHeadCompDis;
    }
  }
#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
  if (bSlotTailCOmpensated == FALSE)
#endif
  {
    CarPosDeltaDis += SlotTailCompDis;
    SlotLen += SlotTailCompDis;
    if ((*pSlotLen1) != 0) {
      (*pSlotLen1) += SlotTailCompDis;
    }
    /*if((*pSlotLen2) != 0){
     (*pSlotLen2) += SlotTailCompDis;
     }*/
    if ((*pSlotLen3) != 0) {
      (*pSlotLen3) += SlotTailCompDis;
    }
  }
  bSlotFound = FALSE;
  for (Index = 0; Index < 2; Index++) {
    if (Index == 0) {
      // Search the Parallel parking slot first.

      MinLen       = APACal.APASlotMinSmallSlotLen - APACal.APASlotDetectionToleranceDis;
      MaxLen       = APACal.APASlotMaxSlotLength + APACal.APASlotDetectionToleranceDis;
      MinSlotDepth = APACal.APASlotMinSlotDepth;
      L            = SlotLen;

      if ((SlotDepth >= MinSlotDepth) && (L >= MinLen) && (L <= MaxLen)) {
        // slot is found
        bSlotFound = TRUE;
      }
    } else {
      // Search for the perpendicular slot

      MinLen       = APACal.APASlotPMinSmallSlotLen - APACal.APASlotDetectionToleranceDis;
      MaxLen       = APACal.APASlotPMaxSlotLength + APACal.APASlotDetectionToleranceDis;
      MinSlotDepth = APACal.APASlotPMinSlotDepth;
      L            = CarPosDeltaDis;
      if (((SlotDepth >= MinSlotDepth) && (L >= MinLen) && (L <= MaxLen)) ||
          ((SlotDepth1 >= MinSlotDepth) && ((*pSlotLen1) >= MinLen) && ((*pSlotLen1) <= MaxLen)) ||
          ((SlotDepth2 >= MinSlotDepth) && ((*pSlotLen2) >= MinLen) && ((*pSlotLen2) <= MaxLen)) ||
          ((SlotDepth3 >= MinSlotDepth) && ((*pSlotLen3) >= MinLen) && ((*pSlotLen3) <= MaxLen))) {
        // slot is found
        bSlotFound = TRUE;
      }
    }
    if (bSlotFound == TRUE) {
      // slot is found

      if (L <= MinLen + APACal.APASlotDetectionToleranceDis) {
        L += APACal.APASlotDetectionToleranceDis;
      } else {
      }
      (*APASlotDetectionCompensateLengthHead) = SlotHeadCompDis;
      (*APASlotDetectionCompensateLengthTail) = SlotTailCompDis;

      // slot found
      if ((Index == 0) && ((*pSlotCalDisCarToObj1) == NO_OBJ_DISTANCE)) {
        // Obj1 does not exist,
        LTemp = APACal.APASlotMaxSlotLengthWithInvalidObj2 - APACal.APASlotSlotLengthCompensatedDisWithInvalidObj1;
        if (L < LTemp) {
          L += APACal.APASlotSlotLengthCompensatedDisWithInvalidObj1;
        } else if (L < APACal.APASlotMaxSlotLengthWithInvalidObj2) {
          L = APACal.APASlotMaxSlotLengthWithInvalidObj2;
        }
      }
      (*pSlotLen) = L;

      if (Index == 0) {
        return APA_SLOT_TYPE_PARALLEL;
      } else {
        return APA_SLOT_TYPE_PERPENDICULAR;
      }
    }
  }
  (*pSlotLen) = L;
  return APA_SLOT_TYPE_INVALID;
}

BOOLEAN APASlotProcStartCheckingCurbOffsetLengthIsLargeEnough(APACoordinateDataType Pt1, APACoordinateDataType Pt2) {
  APA_DISTANCE_TYPE X1, Y1, L;

  L = APASlotProcCalTwoPtApproximateDisInt(Pt1, Pt2);
  if (L >= (APACal.APASlotMinStartCheckingCurbOffsetLen)) {
    // slot found.
    return TRUE;
  }
  return FALSE;
}

BOOLEAN APASlotProcCheckIfSlotObjIsBigEnough(APASlotInfoDataType *pSlotInfo,
                                             BOOLEAN SlotIsDetectedByRearSideSns,
                                             //	APASlotOutlineCoordinateDataType *  pSlot,
                                             // APA_ENUM_TYPE CheckType,
                                             // APA_ENUM_TYPE StartPtIndex,
                                             // APA_ENUM_TYPE EndPtIndex,
                                             APA_ENUM_TYPE CurPtIndex,
                                             APA_ENUM_TYPE ObjType) {
  //
  // CurPtIndex: should not be NO_OBJ_DISTANCE
  //
  // StartPtIndex <= CurPtIndex <= EndPtIndex
  //
  // ObjType: 0 - Obj1 or Obj2. APASlotObjIsBigEnoughCheckType_Obj = 0,
  //          1 - Curb. APASlotObjIsBigEnoughCheckType_Curb
  //

  // Check Type:
  // 0 - Slot Check Start With Obj1 and Check Obj1
  // 1 - Slot Check Start With Obj1 and Check Obj2 With Obj1 Exist
  // 2 - Slot Check Start With Obj1 and Check Obj2 Withou Obj1 Exist
  // 3 - Slot Check Start With Obj2 and Check Obj2
  // 4 - Slot Check Start With Obj2 and Check Obj1 With Obj2 Exist
  // 5 - Slot Check Start With Obj2 and Check Obj1 Withou Obj2 Exist
  // 6 - Obj In Slot (Curb or Object in slot)

  APA_CAL_FLOAT_TYPE fTemp;
  APA_INDEX_TYPE SpdIndex, DisIndex, ObjIndex, ObjStartIndex, ObjEndIndex;
  APA_INDEX_TYPE ConObjStartIndex1, ConObjStartIndex2;
  APA_ENUM_TYPE ObjDtPtNum, ObjContinuouslyDtPtNum, MaxObjContinuouslyDtPtNum;
  APA_DISTANCE_TYPE DeltaDis, PrevObjDis;
  BOOLEAN bCheckConObjStarIndex;
  BOOLEAN bConObjIsBigEnough;

  APA_ENUM_TYPE StartPtIndex;
  APA_ENUM_TYPE EndPtIndex;

  APACoordinateDataType *pCarCenterPoint;
  APA_DISTANCE_TYPE *pDisFromCarToObj;
  // APACoordinateDataType pObjPt;
  // APA_ANGLE_TYPE pCarAng;
  // UCHAR pbObjIsBigEnough;
  APA_ENUM_TYPE *pObjPtCnt;

  if (SlotIsDetectedByRearSideSns == FALSE) {
    pCarCenterPoint  = pSlotInfo->SlotOutline.Lane.CarCenterPoint;
    pDisFromCarToObj = pSlotInfo->SlotOutline.Lane.DisFromCarToObj;
    pObjPtCnt        = &(pSlotInfo->SlotOutline.Lane.ObjPtCnt);
  } else {
    pCarCenterPoint  = pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarCenterPointRSns;
    pDisFromCarToObj = pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.DisFromCarToObjRSns;
    pObjPtCnt        = &(pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtCntRSns);
  }

  // search from the cur pt to start pt.
  if (pDisFromCarToObj[CurPtIndex] == NO_OBJ_DISTANCE) {
    return FALSE;
  }
  if ((pDisFromCarToObj[CurPtIndex] > 2500) && (ObjType == APASlotObjIsBigEnoughCheckType_Obj) && (SlotIsDetectedByRearSideSns == FALSE)) // yys
  {
    return 0;
  }

  StartPtIndex              = 0;
  EndPtIndex                = (*pObjPtCnt) - 1;
  ObjStartIndex             = CurPtIndex;
  ObjDtPtNum                = 1;
  PrevObjDis                = pDisFromCarToObj[CurPtIndex];
  ObjContinuouslyDtPtNum    = 1;
  MaxObjContinuouslyDtPtNum = 1;
  ConObjStartIndex1         = CurPtIndex;
  ConObjStartIndex2         = CurPtIndex;
  bCheckConObjStarIndex     = TRUE;
  bConObjIsBigEnough        = FALSE;
  for (ObjIndex = CurPtIndex - 1; ObjIndex >= StartPtIndex; ObjIndex--) {
    if ((pDisFromCarToObj[ObjIndex] == NO_OBJ_DISTANCE) ||
        (MATH_ABS(pDisFromCarToObj[ObjIndex] - PrevObjDis) > APACal.APASlotObjCheckRegardAsSameObjMaxDeltaObjDis[ObjType]) // 500 , 700
    ) {
      DeltaDis = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPoint[ObjStartIndex], pCarCenterPoint[ObjIndex]);
      if (DeltaDis > APACal.APASlotObjCheckMaxSearchDisForNoObjDetected[ObjType]) { // 500 , 1300
        break;
      }
      bCheckConObjStarIndex  = FALSE;
      ObjContinuouslyDtPtNum = 1;
      ConObjStartIndex2      = ObjIndex;
    } else {
      if (bCheckConObjStarIndex == TRUE) {
        ConObjStartIndex1 = ObjIndex;
      }
      ObjStartIndex = ObjIndex;
      ObjDtPtNum++;
      ObjContinuouslyDtPtNum++;
      if (MaxObjContinuouslyDtPtNum < ObjContinuouslyDtPtNum) {
        MaxObjContinuouslyDtPtNum = ObjContinuouslyDtPtNum;

        if (bConObjIsBigEnough == FALSE) {
          DeltaDis = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPoint[ConObjStartIndex2], pCarCenterPoint[ObjIndex]);
          if (DeltaDis >= APACal.APASlotObjCheckRegardAsObjOrCurbIsBigEnoughMinObjWidth[ObjType]) { // 500 ,600
            // OK, obj point num is big enough.
            bConObjIsBigEnough = TRUE;
          }
        }
      }
      if ((ObjDtPtNum >= APACal.APASlotObjCheckRegardAsObjOrCurbIsBigEnoughMinPointNum[ObjType]) &&
          (MaxObjContinuouslyDtPtNum >= APACal.APASlotObjCheckRegardAsObjOrCurbIsBigEnoughMinContinuousPointNum[ObjType]) // 2
          && (bConObjIsBigEnough == TRUE)) {

        // OK, obj point num is big enough.
        return TRUE;
      }
    }
  }

  // search from the cur pt to end pt.
  ObjEndIndex            = CurPtIndex;
  ObjContinuouslyDtPtNum = CurPtIndex - ConObjStartIndex1 + 1;
  for (ObjIndex = CurPtIndex + 1; ObjIndex <= EndPtIndex; ObjIndex++) {
    if ((pDisFromCarToObj[ObjIndex] == NO_OBJ_DISTANCE) ||
        (MATH_ABS(pDisFromCarToObj[ObjIndex] - PrevObjDis) > APACal.APASlotObjCheckRegardAsSameObjMaxDeltaObjDis[ObjType])) {
      DeltaDis = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPoint[ObjIndex], pCarCenterPoint[ObjEndIndex]);
      if (DeltaDis > APACal.APASlotObjCheckMaxSearchDisForNoObjDetected[ObjType]) {
        break;
      }
      ObjContinuouslyDtPtNum = 1;
      ConObjStartIndex1      = ObjIndex;
    } else {
      ObjEndIndex = ObjIndex;
      ObjDtPtNum++;
      ObjContinuouslyDtPtNum++;
      if (MaxObjContinuouslyDtPtNum < ObjContinuouslyDtPtNum) {
        MaxObjContinuouslyDtPtNum = ObjContinuouslyDtPtNum;
        if (bConObjIsBigEnough == FALSE) {
          DeltaDis = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPoint[ConObjStartIndex1], pCarCenterPoint[ObjIndex]);
          if (DeltaDis >= APACal.APASlotObjCheckRegardAsObjOrCurbIsBigEnoughMinObjWidth[ObjType]) {
            // OK, obj point num is big enough.
            bConObjIsBigEnough = TRUE;
          }
        }
      }
      if ((ObjDtPtNum >= APACal.APASlotObjCheckRegardAsObjOrCurbIsBigEnoughMinPointNum[ObjType]) &&
          (MaxObjContinuouslyDtPtNum >= APACal.APASlotObjCheckRegardAsObjOrCurbIsBigEnoughMinContinuousPointNum[ObjType]) &&
          (bConObjIsBigEnough == TRUE)) {
        // OK, obj point num is big enough.
        return TRUE;
      }
    }
  }

  if ((MaxObjContinuouslyDtPtNum < APACal.APASlotObjCheckRegardAsObjOrCurbIsBigEnoughMinContinuousPointNum[ObjType]) ||
      (bConObjIsBigEnough == FALSE)) {
    return FALSE;
  }

  // Check the obj width and points num.
  DeltaDis = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPoint[ObjEndIndex], pCarCenterPoint[ObjStartIndex]);
  if (ObjType == APASlotObjIsBigEnoughCheckType_Obj) {
    fTemp = USSPar.APAVehicleSpeed;
    fTemp = fTemp * (3.6 / 5.0);
    SpdIndex = (APA_INDEX_TYPE)fTemp;
    if (SpdIndex >= APA_SLOT_SUPPORT_OBJ_CHECK_SPEED_DEVIDED_NUM) {
      SpdIndex = APA_SLOT_SUPPORT_OBJ_CHECK_SPEED_DEVIDED_NUM - 1;
    }

    for (DisIndex = 0; DisIndex < (APA_SLOT_SUPPORT_OBJ_CHECK_OBJ_DIS_DEVIDED_NUM); DisIndex++) {
      if (pDisFromCarToObj[CurPtIndex] < APACal.APASlotObjCheckDevidedObjDis[DisIndex]) {
        break;
      }
    }

    if (ObjDtPtNum >= APACal.APASlotObjCheckMinObjPointNum[SpdIndex][DisIndex]) {
      // Obj Point num is ok.
      if (DeltaDis >= APACal.APASlotObjCheckMinObjWidth[SpdIndex][DisIndex]) {
        // OK, obj width is large enough.
        return TRUE;
      }
    }
  } else {
    // Curb.
    if (ObjDtPtNum >= APACal.APASlotObjCheckMinCurbPointNum) {
      // Obj Point num is ok.
      if (DeltaDis >= APACal.APASlotObjCheckMinCurbWidth) { // 500 mm
        // OK, obj width is large enough.
        return TRUE;
      }
    }
  }
  return FALSE;
}

APA_ENUM_TYPE APASlotProcCheckSlotCheckDisToCarPtIndexByKnownIndex(APASlotOutlineCoordinateDataType *pSlot,
                                                                   APA_ENUM_TYPE KnownDisToCarPtIndex,
                                                                   APA_ENUM_TYPE StIndex,
                                                                   APA_ENUM_TYPE EndIndex,
                                                                   APA_ENUM_TYPE *pFlatObjEndIndex) {

  APA_ENUM_TYPE ObjPtNum, k, m, j, FlatObjDisIndex, FlatObjPtNum, MinObjDisIndex, MinDisToCarIndex;
  APA_ENUM_TYPE FlatObjStIndex, ObjStIndex, ValidObjStartIndex;
  APA_DISTANCE_TYPE L, MinObjDis, FlatObjDis, Dis1, MinDisToCar, ValidObjWidth, LTemp2;
  BOOLEAN bRegardObj1Or2AsInvalid;
  APA_SLOT_PT_SLOPE_TYPE PtSlope;

  MinDisToCar      = pSlot->DisFromCarToObj[KnownDisToCarPtIndex];
  MinDisToCarIndex = KnownDisToCarPtIndex;
  L                = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[KnownDisToCarPtIndex], pSlot->CarCenterPoint[StIndex]);

  (*pFlatObjEndIndex) = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  if (L < APACal.APASlotDisToCarCheckCarDrvDis1) {
    // Dis < 1m, It is OK. just regarded the min dis to car index temp as car to obj dis pt.
    return KnownDisToCarPtIndex;
  } else {
    /*
     check the following case:

     *******

     ****** <- this should be regarded as the start of the obj2. flat shape.
     | 1m  |

     -------
     */

    if (L > APACal.APASlotDisToCarCheckCarDrvDis2) {
      // OK, search for the min dis to car index.
      MinDisToCar      = (pSlot->DisFromCarToObj[StIndex]);
      MinDisToCarIndex = StIndex;
      if (StIndex > EndIndex) {
        // obj 1.
        ObjPtNum = StIndex - EndIndex;
        k        = StIndex - 1;
      } else {
        // Obj 2.
        ObjPtNum = EndIndex - StIndex;
        k        = StIndex + 1;
      }
      while (ObjPtNum > 0) {
        ObjPtNum--;
        if ((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) {
          // OK, obj is big enough.
          L = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[k], pSlot->CarCenterPoint[StIndex]);
          if (L > APACal.APASlotDisToCarCheckCarDrvDis2) {
            break;
          }
          if (MinDisToCar > (pSlot->DisFromCarToObj[k])) {
            MinDisToCar      = (pSlot->DisFromCarToObj[k]);
            MinDisToCarIndex = k;
          }
        }
        if (StIndex > EndIndex) {
          // obj 1.
          k--;
        } else {
          // Obj 2.
          k++;
        }
      }
    }

    // search for the first 50cm and get the min dis to car.
    MinObjDis       = (pSlot->DisFromCarToObj[StIndex]);
    MinObjDisIndex  = StIndex;
    FlatObjDis      = MinObjDis;
    FlatObjDisIndex = StIndex;
    FlatObjStIndex  = StIndex;
    if (StIndex > EndIndex) {
      // obj 1.
      ObjPtNum   = StIndex - MinDisToCarIndex;
      k          = StIndex - 1;
      ObjStIndex = k;
    } else {
      // Obj 2.
      ObjPtNum   = MinDisToCarIndex - StIndex;
      k          = StIndex + 1;
      ObjStIndex = StIndex;
    }

    if ((pSlot->DisFromCarToObj[ObjStIndex] - MinDisToCar) > APACal.WidthOfCar) {
      // regard the start point as no object.
      bRegardObj1Or2AsInvalid = TRUE;
    } else {
      bRegardObj1Or2AsInvalid = FALSE;
    }

    ValidObjStartIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
    ValidObjWidth      = 0;

    while (ObjPtNum > 0) {
      ObjPtNum--;
      if ((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) {
        // OK, obj is big enough.
        if (ValidObjStartIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
          ValidObjStartIndex = k;
        }

        if (bRegardObj1Or2AsInvalid == TRUE) {
          if ((pSlot->DisFromCarToObj[k] - MinDisToCar) > APACal.WidthOfCar) {
            // regard the start point as no object.
          } else {
            bRegardObj1Or2AsInvalid = FALSE;
            if (StIndex > EndIndex) {
              // obj 1.
              FlatObjStIndex = k + 1;
            } else {
              // Obj 2.
              FlatObjStIndex = k;
            }
          }
        }
        if (bRegardObj1Or2AsInvalid == FALSE) {
          L = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[k], pSlot->CarCenterPoint[FlatObjStIndex]);

          if (L < APACal.APASlotDisToCarCheckObjIsFlatMaxCarDrvDis) {
            // check the flat obj dis.
            if (FlatObjDis > (pSlot->DisFromCarToObj[k])) {
              FlatObjDis      = (pSlot->DisFromCarToObj[k]);
              FlatObjDisIndex = k;
            }
          } else if (FlatObjDisIndex != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            Dis1 = FlatObjDis - pSlot->DisFromCarToObj[k];
            if (Dis1 > APACal.APASlotDisToCarCheckObjIsFlatTolDis) {
              // check the flat obj width.
              if (StIndex > EndIndex) {
                // obj 1.
                FlatObjPtNum = StIndex - FlatObjDisIndex;
                m            = FlatObjDisIndex + 1;
              } else {
                // Obj 2.
                FlatObjPtNum = FlatObjDisIndex - StIndex;
                m            = FlatObjDisIndex - 1;
              }
              while (FlatObjPtNum > 0) {
                FlatObjPtNum--;
                Dis1 = pSlot->DisFromCarToObj[m] - FlatObjDis;
                if (Dis1 > APACal.APASlotDisToCarCheckObjIsFlatTolDis) {
                  // Flat obj end.
                  break;
                } else {
                  FlatObjDisIndex = m;
                }
                if (StIndex > EndIndex) {
                  // obj 1.
                  m++;
                } else {
                  // Obj 2.
                  m--;
                }
              }
              // Check if the flat width is big enough.
              if (StIndex > EndIndex) {
                // obj 1.
                // k + 1 is the first flat point.
                // FlatObjDisIndex + 1 is the end of the flat point.
                m = k + 1;
                FlatObjDisIndex++;
                j = m;
                if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                  // It is not a object.
                  j++;
                  if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                    // Just use k.
                    j = k;
                  }
                }
              } else {
                // Obj 2.
                // k is the end of the flat point.
                // FlatObjDisIndex is the first flat point.
                m = k;
                j = k - 1;
                if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                  // It is not a object.
                  j--;
                  if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                    // Just use k.
                    j = k;
                  }
                }
              }

              Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[m], pSlot->CarCenterPoint[FlatObjDisIndex]);
              if (Dis1 > APACal.APASlotDisToCarCheckObjIsFlatMinWidth) {
                // The flat obj width is big enough, just regarded as an obj.
                if (ValidObjStartIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
                } else {
                  // cal the obj width
                  //
                  if (StIndex > EndIndex) {
                    // obj 1.
                    ValidObjStartIndex += 1;
                  } else {
                    // Obj 2.
                  }
                  LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ValidObjStartIndex], pSlot->CarCenterPoint[k]);
                  if (LTemp2 > ValidObjWidth) {
                    ValidObjWidth = LTemp2;
                  }
                }
                if ((ValidObjWidth > APACal.APASlotDisToCarCheckObjIsFlatMinValidObjWidth) && (j != MinDisToCarIndex)) {
                  // check the slope between the end pt and the min dis to car point.

                  PtSlope = APASlotProcCalTwoObjPtSlope(
                      pSlot->CarCenterPoint[MinDisToCarIndex], pSlot->CarCenterPoint[j], MinDisToCar, pSlot->DisFromCarToObj[j]);

                  if ((PtSlope > APACal.APASlotDisToCarCheckObjIsFlatMinSlope) && (PtSlope < 5)) {
                    // Ok, it is parallel car.
                    // keep searching
                  } else {
                    (*pFlatObjEndIndex) = m;
                    break;
                  }
                }
              }
              // do not need to check the flat obj width again.
              FlatObjDisIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
            }
          }
        }
        if (MinObjDis > (pSlot->DisFromCarToObj[k])) {
          MinObjDis      = (pSlot->DisFromCarToObj[k]);
          MinObjDisIndex = k;
        }
      } else {
        if (ValidObjStartIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        } else {
          // cal the obj width
          //
          if (StIndex > EndIndex) {
            // obj 1.
            ValidObjStartIndex += 1;
            m = k - 1;
          } else {
            // Obj 2.
            m = k;
          }
          LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ValidObjStartIndex], pSlot->CarCenterPoint[m]);
          if (LTemp2 > ValidObjWidth) {
            ValidObjWidth = LTemp2;
          }
          ValidObjStartIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
        }
      }
      if (StIndex > EndIndex) {
        // obj 1.
        k--;
      } else {
        // Obj 2.
        k++;
      }
    }
    return MinObjDisIndex;
  }
}

BOOLEAN APASlotProcCheckSlotCheckDisToCarPtIndexWithoutKnownIndex(APASlotOutlineCoordinateDataType *pSlot,
                                                                  APA_DISTANCE_TYPE MinDisToCar,
                                                                  APA_ENUM_TYPE StIndex,
                                                                  APA_ENUM_TYPE EndIndex,
                                                                  APA_ENUM_TYPE *pFlatObjEndIndex,
                                                                  APA_ENUM_TYPE *pMinDisToCarIndex,
                                                                  APA_ENUM_TYPE *pObjEndPtIndex) {

  APA_ENUM_TYPE ObjPtNum, k, m, FlatObjDisIndex, FlatObjPtNum, MinObjDisIndex, FlatObjStIndex, ObjStIndex;
  APA_DISTANCE_TYPE LTemp, LTemp2, MinObjDis, FlatObjDis, Dis1, ValidObjWidth;
  BOOLEAN bRegardObj1Or2AsInvalid;
  APA_INDEX_TYPE ValidObjStartIndex, n, j, i, g;
  APA_SLOT_PT_SLOPE_TYPE PtSlope;

  MinObjDis       = (pSlot->DisFromCarToObj[StIndex]);
  MinObjDisIndex  = StIndex;
  FlatObjDis      = MinObjDis;
  FlatObjDisIndex = StIndex;
  if (StIndex > EndIndex) {
    // obj 1.
    ObjPtNum   = StIndex - EndIndex + 1;
    ObjStIndex = StIndex + 1;
    k          = StIndex;
  } else {
    // Obj 2.
    ObjPtNum   = EndIndex - StIndex;
    ObjStIndex = StIndex;
    k          = StIndex + 1;
  }

  (*pFlatObjEndIndex) = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;

  if ((pSlot->DisFromCarToObj[ObjStIndex] - MinDisToCar) > APACal.WidthOfCar) {
    // regard the start point as no object.
    bRegardObj1Or2AsInvalid = TRUE;
    LTemp                   = APA_SLOT_DIS_TO_CAR_CHECK_CAR_TRAVELLING_DIS_REGARD_NO_OBJ1OR2;
  } else {
    bRegardObj1Or2AsInvalid = FALSE;
    FlatObjStIndex          = ObjStIndex;
  }
  ValidObjStartIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
  ValidObjWidth      = 0;
  while (ObjPtNum > 0) {
    ObjPtNum--;
    if ((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) {
      if (ValidObjStartIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
        ValidObjStartIndex = k;
      }
      LTemp = APACal.APASlotDisToCarCheckCarDrvDis2;
      if (bRegardObj1Or2AsInvalid == TRUE) {
        if ((pSlot->DisFromCarToObj[k] - MinDisToCar) > APACal.WidthOfCar) {
          // regard the start point as no object.
          LTemp = APA_SLOT_DIS_TO_CAR_CHECK_CAR_TRAVELLING_DIS_REGARD_NO_OBJ1OR2;
        } else {
          bRegardObj1Or2AsInvalid = FALSE;
          if (StIndex > EndIndex) {
            // obj 1.
            FlatObjStIndex = k + 1;
          } else {
            // Obj 2.
            FlatObjStIndex = k;
          }
        }
      }

      LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ObjStIndex], pSlot->CarCenterPoint[k]);
      if (LTemp2 < LTemp) {
        if (bRegardObj1Or2AsInvalid == FALSE) {
          if (FlatObjStIndex != ObjStIndex) {
            LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[FlatObjStIndex], pSlot->CarCenterPoint[k]);
          }
          if (LTemp2 < APACal.APASlotDisToCarCheckObjIsFlatMaxCarDrvDis) {
            // check the flat obj dis.
            if (FlatObjDis > (pSlot->DisFromCarToObj[k])) {
              FlatObjDis      = (pSlot->DisFromCarToObj[k]);
              FlatObjDisIndex = k;
            }
          } else if (FlatObjDisIndex != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            Dis1 = FlatObjDis - pSlot->DisFromCarToObj[k];
            if (Dis1 > APACal.APASlotDisToCarCheckObjIsFlatTolDis) {
              // check the flat obj width.
              if (StIndex > EndIndex) {
                // obj 1.
                FlatObjPtNum = StIndex - FlatObjDisIndex;
                m            = FlatObjDisIndex + 1;
              } else {
                // Obj 2.
                FlatObjPtNum = FlatObjDisIndex - StIndex;
                m            = FlatObjDisIndex - 1;
              }
              while (FlatObjPtNum > 0) {
                FlatObjPtNum--;
                Dis1 = pSlot->DisFromCarToObj[m] - FlatObjDis;
                if (Dis1 > APACal.APASlotDisToCarCheckObjIsFlatTolDis) {
                  // Flat obj end.
                  break;
                } else {
                  FlatObjDisIndex = m;
                }
                if (StIndex > EndIndex) {
                  // obj 1.
                  m++;
                } else {
                  // Obj 2.
                  m--;
                }
              }
              // Check if the flat width is big enough.
              if (StIndex > EndIndex) {
                // obj 1.
                // k + 1 is the first flat point.
                // FlatObjDisIndex + 1 is the end of the flat point.
                m = k + 1;
                FlatObjDisIndex++;
                j = m;
                if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                  // It is not a object.
                  j++;
                  if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                    // Just use k.
                    j = k;
                  }
                }

              } else {
                // Obj 2.
                // k is the end of the flat point.
                // FlatObjDisIndex is the first flat point.
                m = k;
                j = k - 1;
                if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                  // It is not a object.
                  j--;
                  if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                    // Just use k.
                    j = k;
                  }
                }
              }

              Dis1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[m], pSlot->CarCenterPoint[FlatObjDisIndex]);
              if (Dis1 > APACal.APASlotDisToCarCheckObjIsFlatMinWidth) {
                // The flat obj width is big enough, just regarded as an obj.
                if (ValidObjStartIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
                } else {
                  // cal the obj width
                  //
                  if (StIndex > EndIndex) {
                    // obj 1.
                    ValidObjStartIndex += 1;
                  } else {
                    // Obj 2.
                  }
                  LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ValidObjStartIndex], pSlot->CarCenterPoint[k]);
                  if (LTemp2 > ValidObjWidth) {
                    ValidObjWidth = LTemp2;
                  }
                }
                if (ValidObjWidth > APACal.APASlotDisToCarCheckObjIsFlatMinValidObjWidth) {
                  // check the slope between the end pt and the min dis to car point.
                  n      = ObjPtNum;
                  g      = j;
                  i      = j; // the nearest dis obj index.
                  LTemp2 = pSlot->DisFromCarToObj[k];
                  while (n > 1) {
                    n--;
                    if (StIndex > EndIndex) {
                      // obj 1.
                      g--;
                    } else {
                      // Obj 2.
                      g++;
                    }
                    if (LTemp2 > pSlot->DisFromCarToObj[g]) {
                      LTemp2 = pSlot->DisFromCarToObj[g];
                      i      = g;
                    }
                    Dis1 = MATH_ABS(pSlot->CarCenterPoint[g].x - pSlot->CarCenterPoint[j].x) +
                           MATH_ABS(pSlot->CarCenterPoint[g].y - pSlot->CarCenterPoint[j].y);
                    if (Dis1 > 800) {
                      break;
                    }
                  }
                  if (i == j) {
                    // j is the min dis to car.
                    // keep searching.
                  } else {
                    PtSlope = APASlotProcCalTwoObjPtSlope(pSlot->CarCenterPoint[i], pSlot->CarCenterPoint[j], LTemp2, pSlot->DisFromCarToObj[j]);

                    if ((PtSlope > APACal.APASlotDisToCarCheckObjIsFlatMinSlope) && (PtSlope < 5)) {
                      // Ok, it is parallel car.
                      // keep searching
                    } else {

                      (*pFlatObjEndIndex) = m;
                      break;
                    }
                  }
                }
              }
              // do not need to check the flat obj width again.
              FlatObjDisIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
            }
          }
        }
        if ((pSlot->DisFromCarToObj[k]) < MinObjDis) {
          MinObjDis      = pSlot->DisFromCarToObj[k];
          MinObjDisIndex = k;
        }

      } else {
        break;
      }

    } else {
      if (ValidObjStartIndex == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
      } else {
        // cal the obj width
        //
        if (StIndex > EndIndex) {
          // obj 1.
          ValidObjStartIndex += 1;
          m = k - 1;
        } else {
          // Obj 2.
          m = k;
        }
        LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[ValidObjStartIndex], pSlot->CarCenterPoint[m]);
        if (LTemp2 > ValidObjWidth) {
          ValidObjWidth = LTemp2;
        }
        ValidObjStartIndex = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
      }
    }

    if (StIndex > EndIndex) {
      // obj 1.
      k--;
    } else {
      // Obj 2.
      k++;
    }
  }

  if (StIndex > EndIndex) {
    // obj 1.
    if (k < EndIndex) {
      k = EndIndex;
    }
  } else {
    // Obj 2.
    if (k > EndIndex) {
      k = EndIndex;
    }
  }

  (*pObjEndPtIndex)    = k;
  (*pMinDisToCarIndex) = MinObjDisIndex;

  return bRegardObj1Or2AsInvalid;
}

UCHAR APASlotProcCheckCurbType(APA_DISTANCE_TYPE SlotDepth1,
                               APA_DISTANCE_TYPE SlotDepth2,
                               APA_DISTANCE_TYPE APASlotMinSlotDepth,
                               APA_DISTANCE_TYPE APASlotMaxDisCarToObjByPassingSlot) {
  //
  // return value:
  // 0 - No curb.
  // 1 - Pt1 is curb.
  // 2 - Pt2 is curb.
  // 3 - uncertained.
  // 4 - No curb. Pt1 is close to the car.
  // 5 - No curb. Pt2 is close to the car.
  // 6 - No curb. both Pt1 and Pt2 are within  DisCarToObjByPassingSlot
  // 7 - No curb. Pt1 is close to the car. Pt2 == no obj,
  // 8 - No curb. Pt2 is close to the car. Pt1 == no obj,

  APA_DISTANCE_TYPE X1;
  /*if(USSPar.APACarParkingMode == APA_PARKPROC_PARKING_MODE_PARALLEL){
   } else {
   }*/

  if (SlotDepth1 == NO_OBJ_DISTANCE) {
    if (SlotDepth2 == NO_OBJ_DISTANCE) {
      return 0; // No curb.
    } else {
      if (((SlotDepth2) <= APASlotMaxDisCarToObjByPassingSlot) && ((SlotDepth2) >= APACal.APASlotMinDisCarToObjByPassingSlot)) {

        // Point 2 is the object.
        return 8; // no curb. point 2 close to the car.
      } else {
        return 3; // uncertain
      }
    }
  } else {
    if (SlotDepth2 == NO_OBJ_DISTANCE) {
      if (((SlotDepth1) <= APASlotMaxDisCarToObjByPassingSlot) && ((SlotDepth1) >= APACal.APASlotMinDisCarToObjByPassingSlot)) {
        // Point 1 is the object.
        return 7; // no curb. point 1 close to the car.
      } else {
        return 3; // uncertain
      }
    } else {
      X1 = MATH_ABS(SlotDepth2 - SlotDepth1);
      if (SlotDepth1 > SlotDepth2) {
        if (APASlotMinSlotDepth > X1) {
          // no curb is found.
          return 3; // uncertain
        } else {
          // Curb found.
          if ((SlotDepth2 <= APASlotMaxDisCarToObjByPassingSlot) && (SlotDepth2 >= APACal.APASlotMinDisCarToObjByPassingSlot)) {
            if (SlotDepth1 >= APACal.APASlotMaxDisForCurbDetection) {
              //
              // curb found
              // point 1 is curb, point 2 is object.
              //                                            point 2
              //                                           +_____________
              //                                           :
              //                                           :
              //                                 no object :
              //                      +-------------------+
              //                    point 1
              //          ____________+
              //
              return 8; // no curb. point 2 close to the car.
            } else {
              //
              // curb found
              // point 1 is curb, point 2 is object.
              //                                            point 2
              //                                           +_____________
              //                                           :
              //                                           :
              //                    point 1       		 :
              //          ____________+                    :
              //                      :           no object:
              //                      +-------------------+
              //
              return 1; // point 1 is curb, point 2 is object.
            }
          } else {
            return 3; // uncertain
          }
        }
      } else {
        if (APASlotMinSlotDepth > X1) {
          // no curb is found.
          return 3; // uncertain
        } else {
          // Curb found.
          if ((SlotDepth1 <= APASlotMaxDisCarToObjByPassingSlot) && (SlotDepth1 >= APACal.APASlotMinDisCarToObjByPassingSlot)) {
            if (SlotDepth2 < APACal.APASlotMaxDisForCurbDetection) {
              // curb found
              // point 1 is Obj, point 2 is curb.
              //                             point 1
              //          ____________+
              //                      :
              //                      :
              //                      :                   point 2
              //                      :                    +_____________
              //                      :           no object:
              //                      +-------------------+
              //
              return 2; // point 1 is Obj, point 2 is curb.
            } else {
              // curb found
              // point 1 is Obj, point 2 is curb.
              //                             point 1
              //          ____________+
              //                      :
              //                      :
              //                      :           no object:
              //                      +-------------------+
              //                                         point 2
              //                                          +_____________
              //
              return 7; // no curb. point 1 close to the car.
            }
          } else {
            return 3; // uncertain
          }
        }
      }
    }
  }
  return 3; // uncertain
}

APA_DISTANCE_TYPE APASlotProcCheckIsCurbDetected(APASlotOutlineCoordinateDataType *pSlot,
                                                 APA_DISTANCE_TYPE DisCarToObj1ByPassingSlot,
                                                 APA_DISTANCE_TYPE DisCarToObj2ByPassingSlot,
                                                 APA_DISTANCE_TYPE APASlotMinSlotDepth,
                                                 APA_INDEX_TYPE SlotStartIndex,
                                                 APA_INDEX_TYPE SlotEndIndex,
                                                 APA_DISTANCE_TYPE *pSlotActualDepth,
                                                 APA_DISTANCE_TYPE *pSlotDepth1,
                                                 APA_DISTANCE_TYPE *pSlotDepth2,
                                                 APA_DISTANCE_TYPE *pSlotDepth3,
                                                 APA_DISTANCE_TYPE *pSlotLen1,
                                                 APA_DISTANCE_TYPE *pSlotLen2,
                                                 APA_DISTANCE_TYPE *pSlotLen3,
                                                 uint8 CallLocation) { /* �ú���һ��������6�Σ�����ÿ�ε��õ�λ�� */
  /*
   considering the following case:

   *                                        *
   |                                        |
   |                                        |
   |    Curb 1                              |
   +---------+                      Curb 3  |
   |                   +----------+
   |     Curb2         |
   +-------------------+

   *                                        *
   |                                        |
   |               Curb2                    |
   |         +-------------------+          |
   |         |                   |          |
   |  Curb 1 |                   |          |
   +---------+                   |   Curb 3 |
   +----------+
   */
  // return value: slot depth (car to curb)
  // pSlotActualDepth: slot depth (obj1 or obj2 to curb)
  APA_DISTANCE_TYPE X1, SlotDepth, SlotDepthTemp, Curb1Depth, Curb2Depth, Curb3Depth, Curb1Len, Curb2Len, Curb3Len;
  APA_DISTANCE_TYPE L;
  APASlotCoordinateDataType CurbStartPt, CurbEndPt;
  UCHAR CurbCheckResult1;
  APA_INDEX_TYPE i, j, k, m;
  APA_INDEX_TYPE Curb1StIndex, Curb1EndIndex, Curb2StIndex, Curb2EndIndex, Curb3StIndex, Curb3EndIndex;

  /* 20201014 Fix bug  */
  APA_DISTANCE_CAL_INT_TYPE DisPreCal;

  if ((SlotStartIndexBk == SlotStartIndex) && (SlotEndIndexBk == SlotEndIndex))
  {
    return -1; // û��·���򷵻�32767����·�صĻ�ֵ������Ϊ-1�����Է���-1��ʾ����
  }
  else
  {
    SlotStartIndexBk = SlotStartIndex;
    SlotEndIndexBk = SlotEndIndex;
  }
  DisPreCal = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[SlotStartIndex], pSlot->CarCenterPoint[SlotEndIndex]);
  if ((DisPreCal < 1500)/* || (DisPreCal > 16000)*/)
  {
    return -1;
  }

  if (CallLocation >= 1 && CallLocation <= 6)
  {
    if (IsCurbDetectMaxCnt[CallLocation - 1] >= 5) // ����5����������IsCurbDetected�������
    {
      return -1;
    }
  }
  /* 20201014 Fix bug  */

  // CurbStartPt.DisFromCarToObj = NO_OBJ_DISTANCE;
  X1 = DisCarToObj1ByPassingSlot;
  if (X1 > DisCarToObj2ByPassingSlot) {
    X1 = DisCarToObj2ByPassingSlot;
  }

  // Check curb1:
  // Perpendicular curb.
  Curb1Depth    = NO_OBJ_DISTANCE;
  Curb1Len      = 0;
  Curb1StIndex  = SlotStartIndex;
  Curb1EndIndex = SlotStartIndex;
  SlotDepthTemp = X1 + APACal.APASlotPMinSlotDepth;

  CurbStartPt.DisFromCarToObj = pSlot->DisFromCarToObj[SlotStartIndex];
  CurbStartPt.Coordinate.x    = pSlot->CarCenterPoint[SlotStartIndex].x;
  CurbStartPt.Coordinate.y    = pSlot->CarCenterPoint[SlotStartIndex].y;

  if (DisCarToObj1ByPassingSlot < APACal.APASlotMaxDisCarToObjByPassingSlotWhenObjHasOffset) {

    // Search the start point of the curb1.
    for (i = SlotStartIndex; i < SlotEndIndex; i++) {

      if (pSlot->DisFromCarToObj[i] > SlotDepthTemp) {
        // valid Slot Depth
        break;
      } else {
        if ((pSlot->bObjIsBigEnough[i] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
          // regarded as noise, NO Object detected.
          break;
        }
      }
    }
    // Cal the len between the slot start pt and curb1 start pt.
    L = 0;
    if (i > SlotStartIndex) {
      L = APASlotProcCalTwoPtApproximateDisInt(CurbStartPt.Coordinate, pSlot->CarCenterPoint[i]);
    }
    if (L < APACal.APASlotPMinStartCheckingCurbOffsetLen) {
      // OK, Offset len is within tol
      for (j = i; j < SlotEndIndex; j++) {
        if (pSlot->DisFromCarToObj[j] < SlotDepthTemp) {
          // Invalid Slot Depth
          if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
            // regarded as noise, NO Object detected.
          } else {
            break;
          }
        } else {
          if (Curb1Depth > pSlot->DisFromCarToObj[j]) {
            Curb1Depth = pSlot->DisFromCarToObj[j];
          }
        }
      }
      if (j > i) {
        Curb1Len = APATrajCalGetTwoPointDisInt(
            pSlot->CarCenterPoint[i].x, pSlot->CarCenterPoint[i].y, pSlot->CarCenterPoint[j].x, pSlot->CarCenterPoint[j].y);
        Curb1StIndex  = i;
        Curb1EndIndex = j;
      }
    }
  }

  // Check curb3:
  // Perpendicular curb.
  Curb3Depth    = NO_OBJ_DISTANCE;
  Curb3Len      = 0;
  Curb3StIndex  = SlotEndIndex;
  Curb3EndIndex = SlotEndIndex;

  CurbEndPt.DisFromCarToObj = pSlot->DisFromCarToObj[SlotEndIndex];
  CurbEndPt.Coordinate.x    = pSlot->CarCenterPoint[SlotEndIndex].x;
  CurbEndPt.Coordinate.y    = pSlot->CarCenterPoint[SlotEndIndex].y;

  if ((DisCarToObj2ByPassingSlot < APACal.APASlotMaxDisCarToObjByPassingSlotWhenObjHasOffset) && (Curb1EndIndex < (SlotEndIndex - 1))) {

    // Search the start point of the curb3.
    for (i = SlotEndIndex - 1; i > Curb1EndIndex; i--) {
      if (pSlot->DisFromCarToObj[i] > SlotDepthTemp) {
        // valid Slot Depth
        break;
      } else {
        if ((pSlot->bObjIsBigEnough[i] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
          // regarded as noise, NO Object detected.
          break;
        }
      }
    }
    // Cal the len between the slot start pt and curb1 start pt.
    L = 0;
    if (pSlot->DisFromCarToObj[i] > SlotDepthTemp) {
      i++;
      if (i < SlotEndIndex) {
        L = APASlotProcCalTwoPtApproximateDisInt(CurbEndPt.Coordinate, pSlot->CarCenterPoint[i]);
      }
      if (L < APACal.APASlotPMinStartCheckingCurbOffsetLen) {
        // OK, Offset len is within tol
        for (j = i - 2; j >= Curb1EndIndex; j--) {
          if (pSlot->DisFromCarToObj[j] < SlotDepthTemp) {
            // Invalid Slot Depth
            if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
              // regarded as noise, NO Object detected.
            } else {
              break;
            }
          } else {
            if (Curb3Depth > pSlot->DisFromCarToObj[j]) {
              Curb3Depth = pSlot->DisFromCarToObj[j];
            }
          }
        }
        j++;
        if (j > Curb1EndIndex) {
          Curb3Len = APATrajCalGetTwoPointDisInt(
              pSlot->CarCenterPoint[i].x, pSlot->CarCenterPoint[i].y, pSlot->CarCenterPoint[j].x, pSlot->CarCenterPoint[j].y);
          Curb3StIndex  = j;
          Curb3EndIndex = i;
        }
      }
    }
  }

  // Check curb2:
  // Perpendicular curb.
  Curb2Depth    = NO_OBJ_DISTANCE;
  Curb2Len      = 0;
  Curb2StIndex  = Curb1EndIndex;
  Curb2EndIndex = Curb3StIndex;

  // Search the start point of the curb1.
  j = Curb1EndIndex;
  
  if(j < 0)  //20201010
  {
    j = 0;
  }
  else if(j > 100)
  {
    j = 100;
  }
  if(Curb3StIndex > 100)
  {
    Curb3StIndex = 100;
  }
  else if(Curb3StIndex < 0)
  {
    Curb3StIndex = 0;
  }
  //20201010
  for (i = j; i < Curb3StIndex; i++) {
    if (pSlot->DisFromCarToObj[i] > SlotDepthTemp) {
      // valid Slot Depth
      break;
    } else {
      if ((pSlot->bObjIsBigEnough[i] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
        // regarded as noise, NO Object detected.
        break;
      }
    }
  }
  if (i < Curb3StIndex) {
    // Cal the len between the slot start pt and curb1 start pt.
    for (j = i; j < Curb3StIndex; j++) {
      if (pSlot->DisFromCarToObj[j] < SlotDepthTemp) {
        // Invalid Slot Depth
        if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
          // regarded as noise, NO Object detected.
        } else {
          break;
        }
      } else {
        if (Curb2Depth > pSlot->DisFromCarToObj[j]) {
          Curb2Depth = pSlot->DisFromCarToObj[j];
        }
      }
    }
	    if(i < 0)  //20201010
    {
      i = 0;
    }
    else if(i >= 100)
    {
      i = 99;
    }

    if(j >= 100)
    {
      j = 99;
    }
    else if(j <0)
    {
      j = 0;
    }//20201010

    if (j > i) {
      Curb2Len =
          APATrajCalGetTwoPointDisInt(pSlot->CarCenterPoint[i].x, pSlot->CarCenterPoint[i].y, pSlot->CarCenterPoint[j].x, pSlot->CarCenterPoint[j].y);
      Curb2StIndex  = i;
      Curb2EndIndex = j;
    }
  }

  (*pSlotDepth1) = Curb1Depth;
  (*pSlotLen1)   = Curb1Len;
  (*pSlotDepth2) = Curb2Depth;
  (*pSlotLen2)   = Curb2Len;
  (*pSlotDepth3) = Curb3Depth;
  (*pSlotLen3)   = Curb3Len;

  // Check the actual parallel slot depth
  for (i = SlotStartIndex + 1; i < SlotEndIndex; i++) {
    if (APASlotProcStartCheckingCurbOffsetLengthIsLargeEnough(CurbStartPt.Coordinate, pSlot->CarCenterPoint[i])) {
      break;
    }
  }

  if (APASlotProcStartCheckingCurbOffsetLengthIsLargeEnough(pSlot->CarCenterPoint[i - 1], pSlot->CarCenterPoint[i])) {
    i--;
  }

  for (j = SlotEndIndex - 1; j > SlotStartIndex; j--) {
    if (APASlotProcStartCheckingCurbOffsetLengthIsLargeEnough(CurbEndPt.Coordinate, pSlot->CarCenterPoint[j])) {
      break;
    }
  }

  // 1. chech curb 2 slot depth.
  // i = slot curb check start pt
  // j = slot curb check end pt
  // Search for the curb min distance to the car. treat this dis as the slot curb dis.
  SlotDepth = NO_OBJ_DISTANCE; // curb 2 depth.
  for (k = i; k <= j; k++) {
    if (pSlot->DisFromCarToObj[k] < SlotDepth) {
      if ((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
        // regarded as noise, NO Object detected.
      } else {
        SlotDepth = pSlot->DisFromCarToObj[k];
      }
    }
  }
  if (SlotDepth != NO_OBJ_DISTANCE) {
    SlotDepth -= (X1);
    if (SlotDepth > (APACal.APASlotMinSlotDepth - APACal.APASlotCurbLineTolerance)) {
      if (SlotDepth < APASlotMinSlotDepth) {
        APASlotMinSlotDepth = SlotDepth - APACal.APASlotCurbLineTolerance;
      }
    }
  }

  SlotDepth = NO_OBJ_DISTANCE;
  for (k = i; k <= j; k++) {
      //xsj 20201010

      if(k < 100 && k >= 0)
      {
        if ((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
        // regarded as noise, NO Object detected.
        } else {
          CurbCheckResult1 =
              APASlotProcCheckCurbType(X1, pSlot->DisFromCarToObj[k], APASlotMinSlotDepth, APACal.APASlotMaxDisCarToObjByPassingSlotWhenObjHasOffset);
          if (CurbCheckResult1 == 2) {
            // 2 -- Curb
            if (SlotDepth > (pSlot->DisFromCarToObj[k])) {
              SlotDepth = pSlot->DisFromCarToObj[k];
            }
          }
        }
      }
      else
      {
        
      }
    
  }
  // 2.  Check curb 1 depth.
  Curb1Depth = SlotDepth;
  m          = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM;
  for (k = i; k >= SlotStartIndex; k--) {

    if ((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
      // regarded as noise, NO Object detected.
    } else {
      if (pSlot->DisFromCarToObj[k] < APASlotMinSlotDepth) {
        break;
      }
      if (pSlot->DisFromCarToObj[k] < Curb1Depth) {
        if (m == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
          m = k;
        }
        Curb1Depth = pSlot->DisFromCarToObj[k];
      }
    }
  }
  if ((Curb1Depth < SlotDepth) && (m < APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM)) {
    // Check if the Curb1 length is large enough.
    m++;
    k++;
    Curb1Len =
        APATrajCalGetTwoPointDisInt(pSlot->CarCenterPoint[m].x, pSlot->CarCenterPoint[m].y, pSlot->CarCenterPoint[k].x, pSlot->CarCenterPoint[k].y);
    if (Curb1Len > APACal.APASlotMinRegardedAsCurbMinCurbLenAtSlotHeadAndTail) {
      // OK. regard the curb1 as a valid curb.
      SlotDepth = Curb1Depth;
    }
  }
  // 3.  Check curb 3 depth.
  Curb3Depth = SlotDepth;
  m          = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM;

  for (k = j; k < SlotEndIndex; k++) {

    if ((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_CURB_MASK) == 0) {
      // regarded as noise, NO Object detected.
    } else {
      if (pSlot->DisFromCarToObj[k] < APASlotMinSlotDepth) {
        break;
      }
      if (pSlot->DisFromCarToObj[k] < Curb3Depth) {
        if (m == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
          m = k;
        }
        Curb3Depth = pSlot->DisFromCarToObj[k];
      }
    }
  }
  if ((Curb3Depth < SlotDepth) && (m < APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM)) {
    // Check if the Curb1 length is large enough.
    k--;
    Curb3Len =
        APATrajCalGetTwoPointDisInt(pSlot->CarCenterPoint[m].x, pSlot->CarCenterPoint[m].y, pSlot->CarCenterPoint[k].x, pSlot->CarCenterPoint[k].y);
    if (Curb3Len > APACal.APASlotMinRegardedAsCurbMinCurbLenAtSlotHeadAndTail) {
      // OK. regard the curb1 as a valid curb.
      SlotDepth = Curb3Depth;
    }
  }

  if (SlotDepth == NO_OBJ_DISTANCE) {
    (*pSlotActualDepth) = NO_OBJ_DISTANCE;
  } else {
    if (DisCarToObj1ByPassingSlot > DisCarToObj2ByPassingSlot) {
      (*pSlotActualDepth) = SlotDepth - DisCarToObj2ByPassingSlot;
    } else {
      (*pSlotActualDepth) = SlotDepth - DisCarToObj1ByPassingSlot;
    }
  }
  IsCurbDetectMaxCnt[CallLocation - 1]++;

  /* 20201014 Fix bug  */
  if ((*pSlotActualDepth) < APACal.APASlotMinSlotDepth)
  {
    return -1;
  }
  else if ((*pSlotActualDepth) < APACal.APASlotPMinSlotDepth) // ������ˮƽ���������ܴ�ֱ
  {
    if (DisPreCal < 4500)
    {
      return -1;
    }
  }
  else // ����ˮƽ��ֱ
  {
    // ��ֱ��λ������DisPreCal < 2000���Ѿ�������
  }
  /* 20201014 Fix bug  */

  // return SlotDepth;
  return (*pSlotActualDepth); // 20200427
}

void APASlotProcRecheckCurb(UCHAR CurrentSlotIndex) {

  APA_DISTANCE_TYPE SlotDepth, SlotAcutalDepth, SlotDepthSearchingStep, SlotDepthSearchingStepTemp;
  APA_DISTANCE_TYPE SlotDepthDetected1, SlotLenDetected1;
  APA_DISTANCE_TYPE SlotDepthDetected2, SlotLenDetected2;
  APA_DISTANCE_TYPE SlotDepthDetected3, SlotLenDetected3;
  APA_DISTANCE_TYPE MaxDisToCar, MinDisToCar, L;
  APASlotOutlineCoordinateDataType *pSlot;
  APASlotInfoDataType *pSlotInfo;
  APA_INDEX_TYPE SlotIndex, i, SlotStartIndex, SlotEndIndex;

  SlotIndex = USSPar.Slot[CurrentSlotIndex].SlotNum;
  if (SlotIndex == 0) {
    // No Slot found.
    return;
  }

  SlotIndex--;
  pSlot     = &USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane;
  pSlotInfo = &USSPar.Slot[CurrentSlotIndex];

  if ((USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].CarPassTheSlotEndPtDistance < APACal.LenBetweenRAxisAndFBumper) ||
      (USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].bSlotCurbHasBeenRechecked == TRUE)
      /*|| (USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotDepth != NO_OBJ_DISTANCE)*/) {
    return;
  }

  USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].bSlotCurbHasBeenRechecked = TRUE;

  SlotStartIndex = pSlotInfo->SlotPar[SlotIndex].SlotStartIndex;
  SlotEndIndex   = pSlotInfo->SlotPar[SlotIndex].SlotStartIndex;

  MinDisToCar = pSlotInfo->SlotPar[SlotIndex].DisCarToObj1ByPassingSlot;
  if (MinDisToCar > pSlotInfo->SlotPar[SlotIndex].DisCarToObj2ByPassingSlot) {
    MinDisToCar = pSlotInfo->SlotPar[SlotIndex].DisCarToObj2ByPassingSlot;
  }
  MaxDisToCar = NO_OBJ_DISTANCE;
  IsCurbDetectMaxCnt[0] = 0;
  do {
    SlotDepthSearchingStep = 0;
    for (i = SlotStartIndex + 1; i < SlotEndIndex; i++) {
      if ((pSlot->DisFromCarToObj[i] > SlotDepthSearchingStep) && ((pSlot->DisFromCarToObj[i]) <= MaxDisToCar)) {
        SlotDepthSearchingStep = pSlot->DisFromCarToObj[i];
      }
    }

    if (SlotDepthSearchingStep == NO_OBJ_DISTANCE) {
      SlotDepthSearchingStep--;
      SlotDepthSearchingStepTemp = SlotDepthSearchingStep;
    } else {
      SlotDepthSearchingStep -= APACal.APASlotCurbLineTolerance;
      SlotDepthSearchingStepTemp = SlotDepthSearchingStep - MinDisToCar;
      // Default to parallel parking parameter.
      // L = (APACal.APASlotMinSlotDepth - APACal.APASlotCurbLineTolerance);
      L = (1800 - APACal.APASlotCurbLineTolerance);
      if (SlotDepthSearchingStepTemp < L) {
        break;
      }
    }
    SlotDepth = APASlotProcCheckIsCurbDetected(pSlot,
                                               pSlotInfo->SlotPar[SlotIndex].DisCarToObj1ByPassingSlot,
                                               pSlotInfo->SlotPar[SlotIndex].DisCarToObj2ByPassingSlot,
                                               SlotDepthSearchingStepTemp,
                                               SlotStartIndex,
                                               SlotEndIndex,
                                               &SlotAcutalDepth,
                                               &SlotDepthDetected1,
                                               &SlotDepthDetected2,
                                               &SlotDepthDetected3,
                                               &SlotLenDetected1,
                                               &SlotLenDetected2,
                                               &SlotLenDetected3,
                                               1);

    if (SlotAcutalDepth != NO_OBJ_DISTANCE) {
      pSlotInfo->SlotPar[SlotIndex].SlotDepthDetected1  = SlotDepthDetected1;
      pSlotInfo->SlotPar[SlotIndex].SlotDepthDetected2  = SlotDepthDetected2;
      pSlotInfo->SlotPar[SlotIndex].SlotDepthDetected3  = SlotDepthDetected3;
      pSlotInfo->SlotPar[SlotIndex].SlotLengthDetected1 = SlotLenDetected1;
      pSlotInfo->SlotPar[SlotIndex].SlotLengthDetected2 = SlotLenDetected2;
      pSlotInfo->SlotPar[SlotIndex].SlotLengthDetected3 = SlotLenDetected3;
      pSlotInfo->SlotPar[SlotIndex].SlotDepthParallel   = SlotAcutalDepth;
      pSlotInfo->SlotPar[SlotIndex].SlotDepth           = SlotAcutalDepth;
      return;
    }
    MaxDisToCar = SlotDepthSearchingStep;
    // use the parallel parking parameter to check.
    L = APACal.APASlotMinSlotDepth;

  } while (SlotDepthSearchingStep >= L);
}

void APASlotProcCheckSlot(APA_ENUM_TYPE APACalObjPtSnsIndex, UCHAR CurrentSlotIndex) {
  APA_DISTANCE_TYPE X1, Y1, MinDisToCar, MaxDisToCar, L, LTemp, LTemp2, DisToCarTemp1;
  APA_DISTANCE_TYPE SlotDepthSearchingStep, APASlotDetectionCompensateLengthHead, APASlotDetectionCompensateLengthTail;
  APA_DISTANCE_TYPE SlotDepthSearchingStepTemp, SlotLenWithFirstSlotDepth, SlotLenWithSecondSlotDepth;
  APA_DISTANCE_TYPE SlotCalDisCarToObj1;
  APA_DISTANCE_TYPE SlotCalDisCarToObj2;
  APA_INDEX_TYPE i, MinDisToCarIndex, k, m, n, g, h, MinDisToCarIndexTemp, j, p, q;
  APA_INDEX_TYPE StartIndex, MaxSlotNumIndex;
  UCHAR CurbCheckResult1, CurbCheckResult2;
  BOOLEAN bFlag, bSlotMaybeFound, bSlotAlreadyFound, bRegardObj1Or2AsInvalid, bUseTheNewSlotDepthToSearch;
  APA_ENUM_TYPE CheckedSlotType;
  BOOLEAN bSlotLengthIsGreatThanMaxLen;
  APA_DISTANCE_TYPE SlotDepth, SlotLenTotal;
  APA_DISTANCE_TYPE SlotDepthDetected1, SlotLenDetected1;
  APA_DISTANCE_TYPE SlotDepthDetected2, SlotLenDetected2;
  APA_DISTANCE_TYPE SlotDepthDetected3, SlotLenDetected3;
  BOOLEAN bTheSameSlotIsFound;

  // BOOLEAN bSlotFirstPoint, bDeletePoint;
  APASlotOutlineCoordinateDataType *pSlot;
  APASlotInfoDataType *pSlotInfo;

  APA_INDEX_TYPE Obj1BdStartIndex;
  APA_INDEX_TYPE Obj1BdEndIndex;
  APA_INDEX_TYPE Obj2BdStartIndex;
  APA_INDEX_TYPE Obj2BdEndIndex;
  APA_ENUM_TYPE Obj1StartIndex;
  APA_ENUM_TYPE Obj1EndIndex;
  APA_ENUM_TYPE Obj2StartIndex;
  APA_ENUM_TYPE Obj2EndIndex;
  APA_DISTANCE_TYPE Obj1Width;
  APA_DISTANCE_TYPE Obj2Width;
  APA_ENUM_TYPE Obj1Type;
  APA_ENUM_TYPE Obj2Type;
  APA_DISTANCE_TYPE APASlotMaxDisCarToObjByPassingSlot;
  UCHAR ObjIsBigEnough1, ObjIsBigEnough2;
  int index_tmp;
  BOOLEAN bAlreadyMaxCnt;/*�Ѿ��ﵽ���ִ�д�����ֻ��Ե�һ��ѭ��*/

  /*20201106*/
  APA_INDEX_TYPE UpdateStIndex;
  APA_DISTANCE_TYPE X0ToUpdateStIndex, Y0ToUpdateStIndex,X1ToUpdateStIndex, Y1ToUpdateStIndex,SlotLengthTempToUpdateStIndex;
  /*20201106*/
  /*20201110*/
  APA_INDEX_TYPE i_pre, m_pre;
  APA_DISTANCE_TYPE L_pre, LTemp_pre;
  BOOLEAN bFlag_pre1, bFlag_pre2;
  /*20201110*/

  SlotIndexToDebug = CurrentSlotIndex;

  APASlotDetectionCompensateLengthHead = 0;
  APASlotDetectionCompensateLengthTail = 0;
  CheckedSlotType                      = 0;
  pSlot                                = &USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane;
  pSlotInfo                            = &USSPar.Slot[CurrentSlotIndex];
  bTheSameSlotIsFound                  = FALSE;

  if (USSPar.Slot[CurrentSlotIndex].SlotNum == 0) {
    // No Slot found.
    StartIndex      = 0;
    MaxSlotNumIndex = 0;
  } else {
    // one or More than One slot found.
    bFlag           = FALSE;
    MaxSlotNumIndex = USSPar.Slot[CurrentSlotIndex].SlotNum - 1;

    // Check the obj2 width, border edge.


    if (USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].CarPassTheSlotEndPtDistance < APACal.APASlotDisToCarCheckCarDrvDis2) {
      // Get the start point of the slot and the Min dis to car
      StartIndex       = USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].SlotEndIndex;
      MinDisToCar      = (pSlot->DisFromCarToObj[StartIndex]);
      MinDisToCarIndex = StartIndex;
      m                = 0;
      // k = 0;
      SlotLenTotal = APACal.APASlotPMinSmallSlotLen / 4;
      for (i = StartIndex + 1; i < (pSlot->ObjPtCnt); i++) {

        if (m == 0) {
          if ((pSlot->DisFromCarToObj[i]) < MinDisToCar) {
            MinDisToCar      = pSlot->DisFromCarToObj[i];
            MinDisToCarIndex = i;
          }
          if (MinDisToCar != NO_OBJ_DISTANCE) {
            L = (pSlot->DisFromCarToObj[i]) - MinDisToCar;
            if (L >= APACal.APASlotPMinSlotDepth) {
              m = i;
            }
          }
        } else {
          L = (pSlot->DisFromCarToObj[i]) - MinDisToCar;
          if (L > APACal.APASlotPMinSlotDepth) {
            // A valid P slot end.
            LTemp = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[m], pSlot->CarCenterPoint[i]);
            if (LTemp > SlotLenTotal) {
              // a new slot found.
              bFlag = TRUE;
              break;
            }
          } else {
            // Keep searching
            m = i;
          }
        }
      }
    }

    if (bFlag == FALSE) {
      if (USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].SlotType == APA_SLOT_TYPE_PARALLEL) {
        if (((USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].CarPassTheSlotEndPtDistance < APACal.APASlotDisToCarCheckCarDrvDis2) ||
             (USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].CarPassTheSlotEndPtDistance < APACal.APASlotMinPathAfterSlot)) ||
            (USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].DisCarToObj2ByPassingSlot == NO_OBJ_DISTANCE)) {
          // The same slot.
          //
          /*	Senario12:

           ------------|
           |
           |						|---------------
           |						|
           |						|
           -------------------------
           */
          if (USSPar.Slot[CurrentSlotIndex].SlotNum > 1) {
            StartIndex = USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex - 1].SlotEndIndex;
          } else {
            StartIndex = 0;
          }
          bFlag = TRUE;
        } else {
          StartIndex = USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].SlotEndIndex;
        }
      } else {
        // perpendicular parking
        L = NO_OBJ_DISTANCE;
        if ((USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].DisCarToObj1ByPassingSlot != NO_OBJ_DISTANCE) &&
            (USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].DisCarToObj2ByPassingSlot != NO_OBJ_DISTANCE)) {
          L = USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].DisCarToObj1ByPassingSlot + APACal.APASlotMinSlotDepth;
        }
        if (((USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].CarPassTheSlotEndPtDistance < APACal.APASlotDisToCarCheckCarDrvDis2) ||
             (USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].CarPassTheSlotEndPtDistance < APACal.APASlotMinPathAfterSlot)) ||
            (USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].DisCarToObj2ByPassingSlot >= L)) {
          // The same slot.
          //
          /*	Senario12:

           ------------|
           |
           |						|---------------
           |						|
           |						|
           -------------------------
           */
          if (USSPar.Slot[CurrentSlotIndex].SlotNum > 1) {
            StartIndex = USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex - 1].SlotEndIndex;
          } else {
            StartIndex = 0;
          }
          bFlag = TRUE;
        } else {
          StartIndex = USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].SlotEndIndex;
        }
      }
      if ((bFlag == TRUE) &&
          ((USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].CarPassTheSlotEndPtDistance < APACal.APASlotMinPathAfterSlot) ||
           (USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].CarPassTheSlotEndPtDistance < APACal.APASlotDisToCarCheckCarDrvDis2))) {
        // Check the same slot, actually we should remove one slot
        bTheSameSlotIsFound = TRUE;
      }
    } else {
      StartIndex = USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].SlotEndIndex;
    }
  }

/*20201106����StartIndex�����µ�10m���ڣ��������ʵ��λ��11�ף�USSPar�������Ҳ�����⳵λ*/
X1ToUpdateStIndex = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.CarCenterPoint[pSlot->ObjPtCnt - 1].x;
Y1ToUpdateStIndex = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.CarCenterPoint[pSlot->ObjPtCnt - 1].y;
for(UpdateStIndex = StartIndex; UpdateStIndex < (pSlot->ObjPtCnt); UpdateStIndex++)
{
  X0ToUpdateStIndex = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.CarCenterPoint[UpdateStIndex].x;
  Y0ToUpdateStIndex = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.CarCenterPoint[UpdateStIndex].y;
  SlotLengthTempToUpdateStIndex = APATrajCalGetTwoPointDisInt(X0ToUpdateStIndex, Y0ToUpdateStIndex, X1ToUpdateStIndex, Y1ToUpdateStIndex);
  if(SlotLengthTempToUpdateStIndex < 2000)
  {
    return;
  }
  else if (SlotLengthTempToUpdateStIndex < 10000)
  {
    StartIndex = UpdateStIndex;
    break;
  }
  else
  {
  }      
}
/*20201106*/

  if (pSlot->ObjPtCnt < (StartIndex + 3)) {
    return;
  }
  if (StartIndex < 0) {
    // ?? data error ??
    // reset all the slot info.
    APASlotProcResetSlotInfo(APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM);
    return;
  }
  // Check if the obj is big enough.
  n = pSlot->ObjPtCnt - 1;
  i = 0;
  for (m = n; m >= 0; m--) {
    ObjIsBigEnough1 = APASlotProcCheckIfSlotObjIsBigEnough(pSlotInfo,
                                                           // StartIndex,
                                                           // pSlot->ObjPtCnt - 1,
                                                           FALSE,
                                                           m,
                                                           APASlotObjIsBigEnoughCheckType_Obj);

    ObjIsBigEnough2 = APASlotProcCheckIfSlotObjIsBigEnough(pSlotInfo,
                                                           // StartIndex,
                                                           // pSlot->ObjPtCnt - 1,
                                                           FALSE,
                                                           m,
                                                           APASlotObjIsBigEnoughCheckType_Curb);

    ObjIsBigEnough1 |= (ObjIsBigEnough2 << 1);
    pSlot->bObjIsBigEnough[m] = ObjIsBigEnough1;
    i++;
    if (i >= APACal.APASlotObjCheckSearchBkForCheckingObjTypeMaxObjPointNum) {
      break;
    }
    LTemp = MATH_ABS(pSlot->CarCenterPoint[n].x - pSlot->CarCenterPoint[m].x) + MATH_ABS(pSlot->CarCenterPoint[n].y - pSlot->CarCenterPoint[m].y);
    if (LTemp > APACal.APASlotObjCheckSearchBkForCheckingObjTypeDisFromCurrentObjPoint) {
      break;
    }
  }

  // Get the start point of the slot and the Min dis to car
  MinDisToCar      = NO_OBJ_DISTANCE;
  MinDisToCarIndex = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM;
  for (i = StartIndex; i < (pSlot->ObjPtCnt); i++) {
    if ((pSlot->DisFromCarToObj[i]) < MinDisToCar) {
      // check object width
      if ((pSlot->bObjIsBigEnough[i] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) {
        MinDisToCar      = pSlot->DisFromCarToObj[i];
        MinDisToCarIndex = i;
      }
    }
  }
/*20201110��ǰ��ǰ/��������Σ�����������ȴ�����ֵ�ĵ�Ŀ��ȴ���1500mm���ſ�ʼ��Do_whileѭ��*/
  m_pre = 0;
  bFlag_pre1 = FALSE;
  for (i_pre = StartIndex; i_pre < MinDisToCarIndex; i_pre++) {
    if (m_pre == 0) {
      L_pre = (pSlot->DisFromCarToObj[i_pre]) - MinDisToCar;
      if (L_pre >= APACal.APASlotMinSlotDepth) {
        m_pre = i_pre;
      }
    } else {
      L_pre = (pSlot->DisFromCarToObj[i_pre]) - MinDisToCar;
      if (L_pre > APACal.APASlotMinSlotDepth) {
        // A valid P slot end.
        LTemp_pre = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[m_pre], pSlot->CarCenterPoint[i_pre]);
        if (LTemp_pre > 1000) {
          // a new slot found.
          bFlag_pre1 = TRUE;
          break;
        }
      } else {
        // Keep searching
        m_pre = i_pre;
      }
    }
  }
  m_pre = 0;
  bFlag_pre2 = FALSE;
  for (i_pre = MinDisToCarIndex; i_pre < (pSlot->ObjPtCnt); i_pre++) {
  if (m_pre == 0) {
    L_pre = (pSlot->DisFromCarToObj[i_pre]) - MinDisToCar;
    if (L_pre >= APACal.APASlotMinSlotDepth) {
      m_pre = i_pre;
    }
  } else {
    L_pre = (pSlot->DisFromCarToObj[i_pre]) - MinDisToCar;
    if (L_pre > APACal.APASlotMinSlotDepth) {
      // A valid P slot end.
      LTemp_pre = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[m_pre], pSlot->CarCenterPoint[i_pre]);
      if (LTemp_pre > 1000) {
        // a new slot found.
        bFlag_pre2 = TRUE;
        break;
      }
    } else {
      // Keep searching
      m_pre = i_pre;
    }
  }
}
/*20201110*/

  // if ((MinDisToCar > APACal.APASlotMaxDisForCurbDetection) || (MinDisToCarIndex == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM)) {
   if ((MinDisToCar > 2300) || (MinDisToCarIndex == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM)) { 
    /*if(APASlotDefinition & APA_SLOT_ALLOW_SLOT_WITH_NO_OBJ_AT_HEAD_AND_TAIL){
     bSlotMaybeFound = APASlotProcCheckSlotLengthIsLargeEnough (
     pMainSlot->CarCenterPoint[StartIndex],
     pMainSlot->OutlinePoint[StartIndex].DisFromCarToObj,
     pMainSlot->CarAng[StartIndex],
     pMainSlot->CarCenterPoint[pMainSlot->WrIndex - 1],
     pMainSlot->OutlinePoint[pMainSlot->WrIndex - 1].DisFromCarToObj,
     pMainSlot->CarAng[pMainSlot->WrIndex - 1],
     NO_OBJ_DISTANCE,
     &L);
     if(bSlotMaybeFound == FALSE){
     } else {
     // slot found
     USSPar.Slot.SlotStartIndex = StartIndex;
     USSPar.Slot.SlotEndIndex = pMainSlot->WrIndex - 1;
     USSPar.Slot.SlotCalDisCarToObj1 = NO_OBJ_DISTANCE;
     USSPar.Slot.SlotCalDisCarToObj2 = NO_OBJ_DISTANCE;
     if(bAPASlotFoundSlotProcess == FALSE){
     // The first slot.
     USSPar.Slot.SlotLength = L;
     bSlotFound = TRUE;
     } else {
     USSPar.Slot.SlotLength = L;
     goto APACheckSlot_NewSlotFound;
     }
     }
     }*/
    goto APACheckSlot_NoSlotFound;
  }

  if (MinDisToCar > APACal.APASlotMaxDisCarToObjByPassingSlot) {
    APASlotMaxDisCarToObjByPassingSlot = APACal.APASlotMaxDisCarToObjByPassingSlot;
    n                                  = (pSlot->ObjPtCnt - 1);
    for (i = StartIndex - 1; i >= 0; i--) {
      LTemp = (pSlot->CarCenterPoint[n].y - pSlot->CarCenterPoint[i].y);
      if (LTemp < 0) {
        LTemp = -LTemp;
      }
      if (LTemp > APACal.APASlotUseMaxDisCarToObjByPassingSlotWhenObjHasOffsetCarDriveDis) {
        break;
      }
      if (pSlot->DisFromCarToObj[i] <= APACal.APASlotMaxDisCarToObjByPassingSlot) {
        // OK, car to the slot dis less than the given max dis
        APASlotMaxDisCarToObjByPassingSlot = APACal.APASlotMaxDisCarToObjByPassingSlotWhenObjHasOffset;
        break;
      }
    }
  } else {
    APASlotMaxDisCarToObjByPassingSlot = APACal.APASlotMaxDisCarToObjByPassingSlotWhenObjHasOffset;
  }

  // searching from startindex to MinDisToCarIndexTemp.
  MaxDisToCar       = NO_OBJ_DISTANCE;
  bSlotAlreadyFound = FALSE;
#if Debug_SW_COUNTLOOP
  DebugDoWhileCnt[0][0] = 0;
  DebugDoWhileCnt[1][0] = 0;
#endif
  bAlreadyMaxCnt = FALSE;
#if Debug_SW_ExeTimeTest 
  Task_LoopDoWhileExeTimeTest[0][0] = Stm_ReadTimerValue(0, 0);
#endif
  if (DebugDoWhile & 0x01) {
  do {
    if (bFlag_pre1 == FALSE)
    {
      break;
    }
    SlotStartIndexBk = -1;
    SlotEndIndexBk = -1;
#if Debug_SW_COUNTLOOP
    DebugLoopICnt[0][0] = 0;
    DebugLoopKCnt[0][0] = 0;
    if (CurrentSlotIndex == SlotIndexToDebug)
    {
      DebugDoWhileCnt[0][0]++;
      DebugDoWhileCnt[0][1] = DebugDoWhileCnt[0][1] > DebugDoWhileCnt[0][0] ? DebugDoWhileCnt[0][1] : DebugDoWhileCnt[0][0];
    }
    if (DebugDoWhileCnt[0][0] >= 3)
    {
      break;
    }
#endif
    SlotDepthSearchingStep = 0;
    MinDisToCarIndexTemp   = MinDisToCarIndex;
    MinDisToCar            = pSlot->DisFromCarToObj[MinDisToCarIndex];

    /*20201112�޸�bug:ԭ����ڶ���Do-While*/
    if (MaxDisToCar == NO_OBJ_DISTANCE) // ȷ���ǵ�һ��ִ��
    {
      for (i = MinDisToCarIndexTemp - 1; i >= StartIndex; i--)
      {
        if (((pSlot->bObjIsBigEnough[i] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0)
        && (pSlot->DisFromCarToObj[i] < NO_OBJ_DISTANCE)
        /*��С��1700���������SlotDepthSearchingStepTempͬ��������С��L������Do-whileһ��Ҳû��������32767֮�����Զ�㲻�������Ҫ��
        �޷�����������λ����ʱ��Ӧ����Ȼ��32767��Ϊ�׸������������г�λ����*/
        && ((pSlot->DisFromCarToObj[i] - MinDisToCar) >= 1700))/*1700Ҫ�������ͬ���仯*/
        {
          MaxDisToCar = NO_OBJ_DISTANCE - 1; /*����������ȡ������Զ��Ϊ��32767֮�����Զ��*/
          break;
        }
      }
    }
    /*20201112�޸�bug*/

    for (i = MinDisToCarIndexTemp - 1; i >= StartIndex; i--) {
      if (i <= 0)
      {
        i = 0;
      }
      if ((pSlot->DisFromCarToObj[i] > SlotDepthSearchingStep) && ((pSlot->DisFromCarToObj[i]) <= MaxDisToCar)) {
        SlotDepthSearchingStep = pSlot->DisFromCarToObj[i];
      }
    }
    if (SlotDepthSearchingStep == NO_OBJ_DISTANCE) {
      SlotDepthSearchingStep--;
      SlotDepthSearchingStepTemp = SlotDepthSearchingStep;
    } else {
      SlotDepthSearchingStep -= APACal.APASlotCurbLineTolerance;
      SlotDepthSearchingStepTemp = SlotDepthSearchingStep - MinDisToCar;
      // Default to parallel parking parameter.
      // L = (APACal.APASlotMinSlotDepth - APACal.APASlotCurbLineTolerance);
      L = (1700 - APACal.APASlotCurbLineTolerance);
      if (SlotDepthSearchingStepTemp < L) {
        break;
      }
    }
    // bSlotFirstPoint = TRUE;
    IsCurbDetectMaxCnt[1] = 0;
    IsCurbDetectMaxCnt[2] = 0;

    if (CurrentSlotIndex == SlotIndexToDebug)
    {
      for (index_tmp = 0; index_tmp < 2; index_tmp++)
      {
        iscurb_cnt[index_tmp][0] = 0;
      }
    }
    for (i = MinDisToCarIndexTemp - 1; i >= StartIndex; i--) {
#if Debug_SW_COUNTLOOP
      if (CurrentSlotIndex == SlotIndexToDebug)
      {
        DebugLoopICnt[0][0]++;
        DebugLoopICnt[0][1] = DebugLoopICnt[0][1] > DebugLoopICnt[0][0] ? DebugLoopICnt[0][1] : DebugLoopICnt[0][0];
      }
#endif
      if (((pSlot->bObjIsBigEnough[i] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) && (MinDisToCar >= pSlot->DisFromCarToObj[i])) {
        MinDisToCar          = pSlot->DisFromCarToObj[i];
        MinDisToCarIndexTemp = i;
      }
    if (i < 0)
    {
      i = 0;
    }
    else if (i >= 100)
    {
      i = 99;
    }
      CurbCheckResult1            = APASlotProcCheckCurbType(MinDisToCar,
                                                  pSlot->DisFromCarToObj[i], // modified by DSH 2012.2.14
                                                  SlotDepthSearchingStepTemp,
                                                  APASlotMaxDisCarToObjByPassingSlot);

      bUseTheNewSlotDepthToSearch = FALSE;
      if ((CurbCheckResult1 == 2) || (CurbCheckResult1 == 7)) {
        // 2 -- Curb
        // 7 -- no curb.
        bSlotMaybeFound = FALSE;

        // if(bSlotFirstPoint)
        {

          /*
           Consider the following:

           MinDisToCarIndexTemp
           m													+-------------------
           +---------------------------------------------------|
           +---|
           |
           |
           |
           n	+-------------------|
           i						+----
           +------------------------
           II
           II
           II
           \/

           MinDisToCarIndexTemp + 1
           m = MinDisToCarIndexTemp							+-------------------
           +---------------------------------------------------|
           +---|
           |
           |
           |
           n	+-------------------|
           i						+----
           +------------------------

           */
          for (n = i + 1; n < MinDisToCarIndexTemp; n++) {
            if ((pSlot->bObjIsBigEnough[n] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) {
              break;
            }
          }
          Obj2BdStartIndex = n;  

          m = APASlotProcCheckSlotCheckDisToCarPtIndexByKnownIndex(pSlot, MinDisToCarIndexTemp, n, MinDisToCarIndexTemp, &Obj2BdEndIndex);

          if (m == MinDisToCarIndexTemp) {
            // Dis < 1m, It is OK. just regarded the min dis to car index temp as car to obj dis pt.
            bSlotMaybeFound = TRUE;
          } else {
            /*
             check the following case:

             *******

             ****** <- this should be regarded as the start of the obj2.
             | 1m  |

             -------
             */

            MinDisToCarIndexTemp       = m;
            MinDisToCar                = pSlot->DisFromCarToObj[MinDisToCarIndexTemp];
            SlotDepthSearchingStepTemp = SlotDepthSearchingStep - MinDisToCar;

            CurbCheckResult1 = APASlotProcCheckCurbType(
                MinDisToCar, pSlot->DisFromCarToObj[i], SlotDepthSearchingStepTemp, APACal.APASlotMaxDisCarToObjByPassingSlotWhenObjHasOffset);
       
            if ((CurbCheckResult1 == 2) || (CurbCheckResult1 == 7)) {
              // 2 -- Curb
              // 7 -- no curb.
              bSlotMaybeFound = TRUE;
              // bSlotFirstPoint = FALSE;
            }
          }
          /*
           Consider the following:						k
           +-------------------
           i						n					|
           |
           |
           +-------------------+
           +-----------------------+

           II
           II
           II
           \/
           +-------------------
           |
           |
           |
           ------------------------++------------------+




           */

#if 0 // kjy delete 2013 01 09

#endif
        }

        if (bSlotMaybeFound) {
          /*
           Consider the following:									MinDisToCarIndexTemp
           m	 +--------
           +---
           |
           +-----
           |
           |
           n	|
           i											+----
           +-------------------------------------------|

           II
           II
           II
           \/														g
           +-------------------
           |
           |
           i														|
           ------------------------+-------------------------------|

           */
          // n = i + 1;
          m = n;
          while (m < MinDisToCarIndexTemp) {
            m++;
            if ((APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[m], pSlot->CarCenterPoint[n])) <
                APACal.APASlotCarToObjDisCalObj2WidthToBeConsidered) {
              if (((pSlot->bObjIsBigEnough[m] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) &&
                  ((pSlot->DisFromCarToObj[m] - MinDisToCar) < APACal.APASlotCarToObjDisCalObjToCarDisTolLen)) {
                // Ok,
                m--;
                break;
              }
            } else {
              m--;
              break;
            }
          }    
          if (((pSlot->bObjIsBigEnough[m] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) && (pSlot->DisFromCarToObj[m] != NO_OBJ_DISTANCE)) {
            g = m; // The point used to calculate the Obj2 to car distance.
          } else {
            g = m + 1;
            while (m < MinDisToCarIndexTemp) {
              m++;
              if (((pSlot->bObjIsBigEnough[m] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) &&
                  ((pSlot->DisFromCarToObj[m] - MinDisToCar) < APACal.APASlotCarToObjDisCalObjToCarDisTolLen)) { // 50 cm
                // Ok,
                break;
              }
            } 
            if ((APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[m],
                                                      pSlot->CarCenterPoint[n])) < APACal.APASlotCarToObjDisCalObj2WidthToBeConsidered) { // 1000

              // OK.
            } else {
              m = g;            
              while (m < MinDisToCarIndexTemp) {
                m++;
                if ((pSlot->DisFromCarToObj[m] - MinDisToCar) < APACal.APASlotCarToObjDisCalObjToCarDisTolLen) { // 50 cm              
                  // Ok,
                  break;
                }
              }
            }
            g = m;
          }
          // Hear k can not use i - 1 with the initial value;
          bSlotLengthIsGreatThanMaxLen = FALSE;
          for (k = i; k >= StartIndex; k--) {
#if Debug_SW_COUNTLOOP
          if (CurrentSlotIndex == SlotIndexToDebug)
          {
            DebugLoopKCnt[0][0]++;
            DebugLoopKCnt[0][1] = DebugLoopKCnt[0][1] > DebugLoopKCnt[0][0] ? DebugLoopKCnt[0][1] : DebugLoopKCnt[0][0];
          }
#endif
#if 0

						if((pSlot->bObjIsBigEnough[k]) == 0) {
							CurbCheckResult2 = 7; // regarded as no curb.
						} else {
							CurbCheckResult2 = APASlotProcCheckCurbType(MinDisToCar,
									pSlot->DisFromCarToObj[k],
									SlotDepthSearchingStepTemp,
									APASlotMaxDisCarToObjByPassingSlot);
						}

#else
            if ((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
              CurbCheckResult2 = 7; // regarded as no curb.
            } else { 
              CurbCheckResult2 =
                  APASlotProcCheckCurbType(MinDisToCar, pSlot->DisFromCarToObj[k], SlotDepthSearchingStepTemp, APASlotMaxDisCarToObjByPassingSlot);
            }

#endif
            if ((CurbCheckResult2 == 2) || (CurbCheckResult2 == 7) || (bSlotLengthIsGreatThanMaxLen == TRUE)) {           
              // 2 -- Curb
              // 7 -- no curb.
              if ((k == StartIndex) || (bSlotLengthIsGreatThanMaxLen == TRUE)) {
                // the last one.

                // if(APASlotDefinition & APA_SLOT_ALLOW_SLOT_WITH_NO_OBJ_AT_HEAD)
                {
                  m     = k;
                  LTemp = APACal.APASlotMaxSlotLengthWithInvalidObj2 - APACal.APASlotDetectionCompensateLengthTail[0][0];
                  while (m < g) {
                    m++;
                    Y1 = (pSlot->CarCenterPoint[g].y - pSlot->CarCenterPoint[m].y);
                    if (Y1 < LTemp) { 
                      LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g], pSlot->CarCenterPoint[m]);
                      if (LTemp2 < LTemp) {
                        m--;
                        break;
                      }
                    }
                  }
                  while (m > k) {
                    CurbCheckResult2 = APASlotProcCheckCurbType(
                        MinDisToCar, pSlot->DisFromCarToObj[m], SlotDepthSearchingStepTemp, APASlotMaxDisCarToObjByPassingSlot);

                    if ((CurbCheckResult2 == 2) || (CurbCheckResult2 == 7)) {
                      // curb
                      break;
                    } else {
                    }
                    m--;
                  }

#if 0

#endif
                  if (DebugIsCurbDetected == 1) {
                  SlotDepth = APASlotProcCheckIsCurbDetected(pSlot,
                                                             pSlot->DisFromCarToObj[m],
                                                             MinDisToCar,
                                                             SlotDepthSearchingStepTemp,
                                                             m,
                                                             g,
                                                             &LTemp,
                                                             &SlotDepthDetected1,
                                                             &SlotDepthDetected2,
                                                             &SlotDepthDetected3,
                                                             &SlotLenDetected1,
                                                             &SlotLenDetected2,
                                                             &SlotLenDetected3,
                                                             2);
                  }
// #if Debug_SW_COUNTLOOP /*iscurb_cnt������Ϊ�˵���ʹ�ã����ڱ��������ƴ�������˲��ܱ��ص�*/
                  if (CurrentSlotIndex == SlotIndexToDebug)
                  {
                    iscurb_cnt[0][0]++;
                    iscurb_cnt[0][1] = iscurb_cnt[0][0] > iscurb_cnt[0][1] ? iscurb_cnt[0][0] : iscurb_cnt[0][1];
                  }
// #endif
// #if Debug_SW_COUNTLOOP
                  if (iscurb_cnt[0][0] > DebugMaxCnt)
                  {
                    i = k; /*20201106 kѭ��������Ҳ��iѭ������*/
                    bAlreadyMaxCnt = TRUE;
                    break;
                  }
// #endif
                  /* 20201014 Fix bug  */
                  if (SlotDepth == -1)
                  {
                    i = k; /*20201106 kѭ��������Ҳ��iѭ������*/
                    bSlotMaybeFound = FALSE;
                    break;
                  }
                  /* 20201014 Fix bug  */

                  // Notes: g = slot end point index = obj2 index.
                  //        k = slot start point index = obj1 index.

                  Obj1BdStartIndex = k;
                  Obj1BdEndIndex   = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;

                  SlotCalDisCarToObj1 = NO_OBJ_DISTANCE;
                  SlotCalDisCarToObj2 = pSlot->DisFromCarToObj[g];
                  CheckedSlotType =
                      APASlotProcCheckSlotLengthIsLargeEnough(&m,
                                                              &g,
                                                              pSlot,
                                                              &SlotCalDisCarToObj1,
                                                              &SlotCalDisCarToObj2,
                                                              APACalObjPtSnsIndex,
#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
                                                              USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotHeadCompensated,
                                                              USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotTailCompensated,
#endif
                                                              LTemp,
                                                              &APASlotDetectionCompensateLengthHead,
                                                              &APASlotDetectionCompensateLengthTail,
                                                              &SlotLenTotal,
                                                              SlotDepthDetected1,
                                                              SlotDepthDetected2,
                                                              SlotDepthDetected3,
                                                              &SlotLenDetected1,
                                                              &SlotLenDetected2,
                                                              &SlotLenDetected3,
                                                              Obj1BdStartIndex,
                                                              Obj1BdEndIndex,
                                                              Obj2BdStartIndex,
                                                              Obj2BdEndIndex,
                                                              &Obj1StartIndex,
                                                              &Obj1EndIndex,
                                                              &Obj2StartIndex,
                                                              &Obj2EndIndex,
                                                              &Obj1Width,
                                                              &Obj2Width,
                                                              &Obj1Type,
                                                              &Obj2Type

                      );
                  if (CheckedSlotType == APA_SLOT_TYPE_INVALID) {
                    if (SlotLenTotal >= APACal.APASlotMaxSlotLength) { //18m
                      // Parallel parking slot is found.
                      CheckedSlotType = APA_SLOT_TYPE_PARALLEL;
                    } else if (SlotLenTotal >= APACal.APASlotPMaxSlotLength) {  //18m
                      CheckedSlotType = APA_SLOT_TYPE_PERPENDICULAR;
                    }
                  } else if (CheckedSlotType == APA_SLOT_TYPE_PERPENDICULAR) {
                    if (USSPar.Slot[CurrentSlotIndex].SlotNum > 0) {
                      if (m == USSPar.Slot[CurrentSlotIndex].SlotPar[USSPar.Slot[CurrentSlotIndex].SlotNum - 1].SlotEndIndex) {
                        // It is the same slot,
                        // Just remove it
                        CheckedSlotType = APA_SLOT_TYPE_INVALID;
                      }
                    }
                  }
                  if (CheckedSlotType != APA_SLOT_TYPE_INVALID) {
                    // Slot found.
                    APASlotProcSlotFoundSaveSlot(CheckedSlotType,
                                                 SlotCalDisCarToObj1,
                                                 SlotCalDisCarToObj2,
                                                 m,
                                                 g,
                                                 StartIndex,
                                                 NO_OBJ_DISTANCE,
                                                 MinDisToCar,
                                                 SlotDepth,
                                                 SlotLenTotal,
                                                 APASlotDetectionCompensateLengthHead,
                                                 APASlotDetectionCompensateLengthTail,
                                                 CurrentSlotIndex,
                                                 SlotDepthDetected1,
                                                 SlotDepthDetected2,
                                                 SlotDepthDetected3,
                                                 SlotLenDetected1,
                                                 SlotLenDetected2,
                                                 SlotLenDetected3,
                                                 bTheSameSlotIsFound,
                                                 Obj1Type,
                                                 Obj2Type,
                                                 Obj1StartIndex,
                                                 Obj1EndIndex,
                                                 Obj2StartIndex,
                                                 Obj2EndIndex,
                                                 Obj1Width,
                                                 Obj2Width);
                    i                 = k;
                    bSlotAlreadyFound = TRUE;
                    break;
                  } else {
                    bSlotMaybeFound = FALSE;
                  }
                }
                i = k;
                // bSlotFirstPoint = TRUE;
                break;
              }
            } else {
              // Obj1 start.
              /*
               Consider the following:

               StartIndex  		  m
               +----------------	  +----------------|
               |	  |				   +----|
               +-----|						|
               |
               |k
               +-------------------|
               | h						+---------
               +------------------------
               */

              // Check if the obj1 is valid or not.
              // 1. cal the slot length with the searching slot depth.
              // g = obj2 border start index.
              // k = obj1 border start index.
              Obj1BdStartIndex = k;
              Obj1BdEndIndex   = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
              SlotLenWithFirstSlotDepth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g], pSlot->CarCenterPoint[k]);
              if (SlotLenWithFirstSlotDepth < (APACal.APASlotMinPerSlotDeltaCarPosDisAtSlotStartAndEndPt)) {//TODO:
                // Slot len is less than min per len
                // regarded as no slot.
                i = k;
                break;
              } else {
                bFlag = FALSE; // Obj1 is not exist.
                for (n = k; n > StartIndex; n--) {
                  if ((pSlot->bObjIsBigEnough[n] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                    // Regard as no object detected.
                  } else {
                    LTemp = pSlot->DisFromCarToObj[n] - MinDisToCar;
                    if (/*(pSlot->DisFromCarToObj[n] > APASlotMaxDisCarToObjByPassingSlot)
                     &&*/
                        (LTemp > APACal.APASlotMinSlotDepth)) {
                      // regard the start point as no object.
                    } else {
                      bFlag = TRUE; // Obj1 is not exist.
                      break;
                    }
                  }
                }               
                n++;
                if (n < k) {
                  SlotLenWithSecondSlotDepth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[k], pSlot->CarCenterPoint[n]);
                  if (SlotLenWithSecondSlotDepth > APACal.APASlotConsiderSecondSlotDepthMinDeltaSlotLen) {
                    if (SlotLenWithFirstSlotDepth > APACal.APASlotRegardAsFirstSlotDepthMinSlotLen) {
                      // Use the first slot depth which is the current searching slot depth.
                    } else {
                      if ((bFlag == TRUE) && (SlotLenWithSecondSlotDepth < (APACal.APASlotConsiderSecondSlotDepthMinDeltaSlotLen + 1500))) {
                        p      = k;
                        LTemp2 = APACal.APASlotMinSlotDepth / 2;
                        q      = n - 2;
                        if (q < StartIndex) {
                          q = StartIndex;
                        }               
                        for (j = k - 1; j >= q; j--) {
                          if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                            // regard as no obj detected.
                          } else {
                            LTemp = pSlot->DisFromCarToObj[p] - pSlot->DisFromCarToObj[j];
                            if ((LTemp > LTemp2)) {
                              // regard the start point of obj1.
                              bFlag = FALSE;
                              break;
                            } else {
                            }
                            p = j;
                          }
                        }              
                        if (bFlag == FALSE) {
                          // Use the second slot depth as the slot depth.
                          // just break to next loop.
                          bUseTheNewSlotDepthToSearch = TRUE;                    
                          break;
                        } else {
                          // Use the first slot depth.
                        }
                      } else {
                        // Use the second slot depth as the slot depth.
                        // just break to next loop.
                        bUseTheNewSlotDepthToSearch = TRUE;                
                        break;
                      }
                    }
                  } else {
                    // Use the first slot depth.
                  }
                }           
                DisToCarTemp1           = pSlot->DisFromCarToObj[k];
                m                       = k;
                h                       = k + 1;
                bRegardObj1Or2AsInvalid = FALSE;
                n                       = k;
                if (n > StartIndex) {      

                  bRegardObj1Or2AsInvalid =
                      APASlotProcCheckSlotCheckDisToCarPtIndexWithoutKnownIndex(pSlot, MinDisToCar, k, StartIndex, &Obj1BdEndIndex, &m, &n);               
                  DisToCarTemp1 = pSlot->DisFromCarToObj[m];
                }

                /*
                 Consider the following:

                 m
                 +--------------|m + 1
                 +-----
                 |
                 |
                 |k
                 +--------------------
                 |h						+---------
                 +------------------------
                 II
                 II
                 II
                 \/
                 --------------------+
                 |
                 |
                 |
                 +--------------------++------------------

                 */

#if 0 // kjy delete 2013 01 09

#endif 
                {

                  /*
                   Pt1.Coordinate.x = pSlot->ObjPt[g].x;
                   Pt1.Coordinate.y = pSlot->ObjPt[g].y;
                   PtCarAng1		 = pSlot->CarAng[g];
                   */
                  // g - Slot end point index. obj2.
                  if (pSlot->DisFromCarToObj[g] == NO_OBJ_DISTANCE) {
                    // Actually code should never reach.
                    SlotCalDisCarToObj2 = MinDisToCar;
                  } else {
                    // Consider the following:
                    /*                          Obj2Index
                     +-------
                     |
                     |
                     |
                     g = curb		|
                     +---------------+
                     |
                     |
                     |
                     No Obj Index|
                     ------------+

                     Actually g is the curb start index

                     */

                    // Obj2.
                    CurbCheckResult2 = APASlotProcCheckCurbType(
                        pSlot->DisFromCarToObj[m], pSlot->DisFromCarToObj[g], APACal.APASlotMinSlotDepth, APASlotMaxDisCarToObjByPassingSlot);

                    if (CurbCheckResult2 == 2) {
                      // Curb.
                      // Search back to get the start point of obj2.
                      while (g < MinDisToCarIndexTemp) {
                        g++;

                        if (pSlot->bObjIsBigEnough[g] == 0) {
                          CurbCheckResult2 = 7; // regarded as no curb.
                        } else {
                          CurbCheckResult2 = APASlotProcCheckCurbType(
                              pSlot->DisFromCarToObj[m], pSlot->DisFromCarToObj[g], APACal.APASlotMinSlotDepth, APASlotMaxDisCarToObjByPassingSlot);
                        }
                        if ((CurbCheckResult2 == 2) || (CurbCheckResult2 == 7)) {
                          // curb
                        } else {
                          break;
                        }
                      } 
                    }
                    SlotCalDisCarToObj2 = pSlot->DisFromCarToObj[g];
                  }
                  /*	Senario:

                   m
                   +-------------|
                   n +-|
                   |
                   h+---|
                   |
                   +---|
                   |
                   +---|
                   |
                   k +---|
                   +-------------------------------------
                   */
                  if (bRegardObj1Or2AsInvalid == FALSE) { 
                    n = k;
                    while (n > m) {
                      if ((APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[n])) <
                          APACal.APASlotCarToObjDisCalObj1WidthToBeConsidered) {
                        // Ok,
                        if (((pSlot->DisFromCarToObj[n] - DisToCarTemp1) < APACal.APASlotCarToObjDisCalObjToCarDisTolLen) &&
                            ((pSlot->bObjIsBigEnough[n] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0)) {
                          break;
                        }
                      } else {
                        break;
                      }
                      n--;
                    }  
                    h                   = n + 1; // Slot Start point index. obj1.
                    SlotCalDisCarToObj1 = DisToCarTemp1;
                  } else {
                    // Obj 1 is regarded as invalid.

                    // g = end pt
                    // n = start pt
                    LTemp = APACal.APASlotMaxSlotLengthWithInvalidObj2 - APACal.APASlotDetectionCompensateLengthTail[0][0];      
                    while (n < g) {
                      n++;
                      Y1 = (pSlot->CarCenterPoint[g].y - pSlot->CarCenterPoint[n].y);
                      if (Y1 < LTemp) {
                        LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g], pSlot->CarCenterPoint[n]);
                        if (LTemp2 < LTemp) {
                          n--;
                          break;
                        }
                      }
                    }          
                    h                   = n;
                    SlotCalDisCarToObj1 = NO_OBJ_DISTANCE;
                    // DisToCarTemp1 = NO_OBJ_DISTANCE;
                  }
                  /*
                   Pt2.Coordinate.x 	= pSlot->ObjPt[h].x;
                   Pt2.Coordinate.y 	= pSlot->ObjPt[h].y;
                   Pt2.DisFromCarToObj = DisToCarTemp1;
                   PtCarAng2		 	= pSlot->CarAng[h];
                   */  
            if (DebugIsCurbDetected == 1) {    
                  SlotDepth = APASlotProcCheckIsCurbDetected(pSlot,
                                                             DisToCarTemp1,
                                                             MinDisToCar,
                                                             SlotDepthSearchingStepTemp,
                                                             h,
                                                             g,
                                                             &LTemp,
                                                             &SlotDepthDetected1,
                                                             &SlotDepthDetected2,
                                                             &SlotDepthDetected3,
                                                             &SlotLenDetected1,
                                                             &SlotLenDetected2,
                                                             &SlotLenDetected3,
                                                             3);}
// #if Debug_SW_COUNTLOOP
                  if (CurrentSlotIndex == SlotIndexToDebug)
                  {
                    iscurb_cnt[1][0]++;
                    iscurb_cnt[1][1] = iscurb_cnt[1][0] > iscurb_cnt[1][1] ? iscurb_cnt[1][0] : iscurb_cnt[1][1];
                  }
                  if (iscurb_cnt[1][0] > DebugMaxCnt)
                  {
                    bAlreadyMaxCnt = TRUE;
                    i = k; /*20201106 kѭ��������Ҳ��iѭ������*/
                    break;
                  }
// #endif
                /* 20201014 Fix bug  */
            if (SlotDepth == -1)
            {
              bSlotMaybeFound = FALSE;
              i = k; /*20201106 kѭ��������Ҳ��iѭ������*/
              break;
            }
            /* 20201014 Fix bug  */
                  CheckedSlotType =
                      APASlotProcCheckSlotLengthIsLargeEnough(&h,
                                                              &g,
                                                              pSlot,
                                                              &SlotCalDisCarToObj1,
                                                              &SlotCalDisCarToObj2,
                                                              APACalObjPtSnsIndex,
#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
                                                              USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotHeadCompensated,
                                                              USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotTailCompensated,
#endif
                                                              LTemp,
                                                              &APASlotDetectionCompensateLengthHead,
                                                              &APASlotDetectionCompensateLengthTail,
                                                              &SlotLenTotal,
                                                              SlotDepthDetected1,
                                                              SlotDepthDetected2,
                                                              SlotDepthDetected3,
                                                              &SlotLenDetected1,
                                                              &SlotLenDetected2,
                                                              &SlotLenDetected3,
                                                              Obj1BdStartIndex,
                                                              Obj1BdEndIndex,
                                                              Obj2BdStartIndex,
                                                              Obj2BdEndIndex,
                                                              &Obj1StartIndex,
                                                              &Obj1EndIndex,
                                                              &Obj2StartIndex,
                                                              &Obj2EndIndex,
                                                              &Obj1Width,
                                                              &Obj2Width,
                                                              &Obj1Type,
                                                              &Obj2Type);    
                  if (CheckedSlotType == APA_SLOT_TYPE_INVALID) {
                    // i = k - 1;
                    // bSlotFirstPoint = TRUE;
                    bSlotMaybeFound = FALSE;
                    if (SlotLenTotal > APACal.APASlotMaxSlotLength) {
                      // Since the Parallel parking max slot length will great than the max perpendicular parking slot width.
                      // just use the max parallel slot length to check.
                      // Just regard the obj1 as invalid
                      bSlotLengthIsGreatThanMaxLen = TRUE;
                      k--; // Loop again.   
                      i = k; /*20201106 kѭ��������Ҳ��iѭ������*/
                      break;
                    }  
                    i = k; /*20201106 kѭ��������Ҳ��iѭ������*/
                    break;
                  } else {
                    /*if((DisToCarTemp1) > APASlotMaxDisCarToObjByPassingSlot){
                     if(APASlotDefinition & APA_SLOT_ALLOW_SLOT_WITH_OBJ1_INVALID_DIS_TO_CAR){
                     // Slot found
                     } else {
                     // Not a slot.
                     i = k - 1;
                     // bSlotFirstPoint = TRUE;
                     break;
                     }
                     } */

                    // Slot found.
                    /*	Senario:

                     h = slot start index.
                     g = slot end index.
                     MinDisToCarIndexTemp
                     StartIndex ... m,  n
                     g
                     +----------
                     +-----+---+---|<--------------------------Slot Length---------------------------------->+---|			|
                     h +-|
                     |
                     |
                     |
                     | +---
                     |
                     |
                     +---|															+---
                     +-----------| | |
                     +---|													+---
                     |													|
                     +---| 											+---
                     |											|
                     k+----|								i	 +--
                     +------------------------------+----
                     ===>

                     if this is the first slot.

                     StartIndex
                     g
                     +----------
                     +-------------|<--------------------------Slot Length---------------------------------->+---|			|
                     h +-|
                     |
                     |
                     |
                     | +---
                     |
                     |
                     +---|															+---
                     +-----------| | |
                     +---|													+---
                     |													|
                     +---| 											+---
                     |											|
                     k+----|								i	 +--
                     +------------------------------+----
                     else
                     Option 1: (not used)

                     StartIndex		StartIndex + 1 = n
                     g
                     +----------
                     +---------+---|<--------------------------Slot Length---------------------------------->+---|			|
                     |			h +-|
                     |
                     |
                     |
                     |				|
                     +---
                     |
                     |
                     |				+---|
                     +---
                     +-----------| |					|
                     | |					+---|
                     +--- |						|
                     | |						+---|
                     +--- |							|
                     | |					  	   k+----|								i
                     +--
                     +---------------							 	 +------------------------------+----

                     Option 2: used
                     do not remove the point between the slot 2 start point and slot 1 end point.
                     */ 
                    if ((bRegardObj1Or2AsInvalid == TRUE) &&
                        ((DisToCarTemp1 - MinDisToCar) > APACal.APASlotMaxOffsetDisBetweenObj1AndObj2ForParallel)) {
                      DisToCarTemp1 = NO_OBJ_DISTANCE;
                    }
                    if ((bTheSameSlotIsFound == TRUE) && (CheckedSlotType == APA_SLOT_TYPE_PERPENDICULAR)) {
                      if (h >= USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].SlotEndIndex) {
                        // A new slot is found.
                        // Restore the first old slot which is removed.
                        bTheSameSlotIsFound = FALSE;
                      }
                    }
                    APASlotProcSlotFoundSaveSlot(CheckedSlotType,
                                                 SlotCalDisCarToObj1,
                                                 SlotCalDisCarToObj2,
                                                 h,
                                                 g,
                                                 StartIndex,
                                                 DisToCarTemp1,
                                                 MinDisToCar,
                                                 SlotDepth,
                                                 SlotLenTotal,
                                                 APASlotDetectionCompensateLengthHead,
                                                 APASlotDetectionCompensateLengthTail,
                                                 CurrentSlotIndex,
                                                 SlotDepthDetected1,
                                                 SlotDepthDetected2,
                                                 SlotDepthDetected3,
                                                 SlotLenDetected1,
                                                 SlotLenDetected2,
                                                 SlotLenDetected3,
                                                 bTheSameSlotIsFound,
                                                 Obj1Type,
                                                 Obj2Type,
                                                 Obj1StartIndex,
                                                 Obj1EndIndex,
                                                 Obj2StartIndex,
                                                 Obj2EndIndex,
                                                 Obj1Width,
                                                 Obj2Width);
                    i                 = k;
                    bSlotAlreadyFound = TRUE;
                    break;
                  }
                }
              }
            }
          }
          if (bAlreadyMaxCnt == TRUE)
          {
            break;
          }
        }
      }   
      if (bUseTheNewSlotDepthToSearch == TRUE) {   
        break;
      }
      if (bSlotAlreadyFound == TRUE) {   
        break;
      }
    }
    if (bAlreadyMaxCnt == TRUE)
    {
      break;
    }
    if (bSlotAlreadyFound == TRUE) {   
      break;
    }
    MaxDisToCar = SlotDepthSearchingStep;
    // use the parallel parking parameter to check.
    L = APACal.APASlotMinSlotDepth;
  } while (SlotDepthSearchingStep >= L);
#if Debug_SW_ExeTimeTest                               
  Task_LoopDoWhileExeTimeTest[0][1] = Stm_ReadTimerValue(0, 0);
  Task_LoopDoWhileExeTimeTest[0][2] = Task_LoopDoWhileExeTimeTest[0][1] - Task_LoopDoWhileExeTimeTest[0][0];
  if (Task_LoopDoWhileExeTimeTest[0][3] < Task_LoopDoWhileExeTimeTest[0][2]) {
    Task_LoopDoWhileExeTimeTest[0][3] = Task_LoopDoWhileExeTimeTest[0][2];
  } else {
  }
#endif 
  }
  if (DebugDoWhile & 0x02) {
  // Searching from MinDisToCarIndex to the latest point.
  // Get the max dis to car
  MaxDisToCar  = NO_OBJ_DISTANCE;
  SlotLenTotal = 0;
#if Debug_SW_COUNTLOOP
#endif
  // bDeletePoint = FALSE;
  bAlreadyMaxCnt = FALSE;
#if Debug_SW_ExeTimeTest 
  Task_LoopDoWhileExeTimeTest[1][0] = Stm_ReadTimerValue(0, 0);
#endif
  do {
    if (bFlag_pre2 == FALSE)
    {
      break;
    }
    SlotStartIndexBk = -1;
    SlotEndIndexBk = -1;
#if Debug_SW_COUNTLOOP
    DebugLoopICnt[1][0] = 0;
    DebugLoopKCnt[1][0] = 0;
    if (CurrentSlotIndex == SlotIndexToDebug)
    {
      DebugDoWhileCnt[1][0]++;
      DebugDoWhileCnt[1][1] = DebugDoWhileCnt[1][1] > DebugDoWhileCnt[1][0] ? DebugDoWhileCnt[1][1] : DebugDoWhileCnt[1][0];
    }
    if (DebugDoWhileCnt[1][0] >= 3)
    {
      break;
    }
#endif
    SlotDepthSearchingStep = 0;

    MinDisToCarIndexTemp = MinDisToCarIndex;
    MinDisToCar          = pSlot->DisFromCarToObj[MinDisToCarIndex];

    /*20201112�޸�bug:�����Χ�ڼ���·�ص�Ҳ��32767�㣬��ֱ��ʹ��·�ص���Ϊ����������������������case��
    ��������Ϊ32766����һ������2/7������һ��Ϊi�㣬�ҳ�λ���ʱ����APACal.APASlotCarToObjDisCalObj1WidthToBeConsidered
    ���������������g��·�ص��ϣ���bigenough�����л��obj1���ҲУ����·�ص��ϡ���һ�����ܻᵼ��obj1�յ�Ҳ�ܽ����Ӷ�����obj1
    ���Ⱥ�С����saveslot�������޷���������    
    _____obj1____
                |
                |______·�ص�________
                                    |
                                    |
                                    |
                                    |_i_______________32767�ĵ�_________________
    */
    if (MaxDisToCar == NO_OBJ_DISTANCE) // ȷ���ǵ�һ��ִ��
    {
      for (i = MinDisToCarIndexTemp + 1; i < (pSlot->ObjPtCnt); i++)
      {
        if (((pSlot->bObjIsBigEnough[i] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0)
        && (pSlot->DisFromCarToObj[i] < NO_OBJ_DISTANCE)
        /*��С��1700���������SlotDepthSearchingStepTempͬ��������С��L������Do-whileһ��Ҳû��������32767֮�����Զ�㲻�������Ҫ��
        �޷�����������λ����ʱ��Ӧ����Ȼ��32767��Ϊ�׸������������г�λ����*/
        && ((pSlot->DisFromCarToObj[i] - MinDisToCar) >= 1700))/*1700Ҫ�������ͬ���仯*/
        {
          MaxDisToCar = NO_OBJ_DISTANCE - 1; /*����������ȡ������Զ��Ϊ��32767֮�����Զ��*/
          break;
        }
      }
    }
    /*20201112�޸�bug*/

    for (i = MinDisToCarIndexTemp + 1; i < (pSlot->ObjPtCnt); i++) {
      if ((pSlot->DisFromCarToObj[i] > SlotDepthSearchingStep) && ((pSlot->DisFromCarToObj[i]) <= MaxDisToCar)) {
        SlotDepthSearchingStep = pSlot->DisFromCarToObj[i];
      }
    }
    if (SlotDepthSearchingStep == NO_OBJ_DISTANCE) {
      SlotDepthSearchingStep--;
      SlotDepthSearchingStepTemp = SlotDepthSearchingStep;
    } else {
      SlotDepthSearchingStep -= APACal.APASlotCurbLineTolerance;
      SlotDepthSearchingStepTemp = SlotDepthSearchingStep - MinDisToCar;
      // L                          = (APACal.APASlotMinSlotDepth - APACal.APASlotCurbLineTolerance);
      L                          = (1700 - APACal.APASlotCurbLineTolerance);
      if (SlotDepthSearchingStepTemp < L) {
        break;
      }
    }
    // Searching for the slot which length is great than the min small slot len
    IsCurbDetectMaxCnt[3] = 0;
    IsCurbDetectMaxCnt[4] = 0;
    IsCurbDetectMaxCnt[5] = 0;

    if (CurrentSlotIndex == SlotIndexToDebug)
    {
      for (index_tmp = 2; index_tmp < 5; index_tmp++)
      {
        iscurb_cnt[index_tmp][0] = 0;
      }
    }
    // bSlotFirstPoint = TRUE;
    for (i = MinDisToCarIndexTemp + 1; i < pSlot->ObjPtCnt; i++) {
#if Debug_SW_COUNTLOOP
      if (CurrentSlotIndex == SlotIndexToDebug)
      {
        DebugLoopICnt[1][0]++;
        DebugLoopICnt[1][1] = DebugLoopICnt[1][1] > DebugLoopICnt[1][0] ? DebugLoopICnt[1][1] : DebugLoopICnt[1][0];
      }
#endif
      if (((pSlot->bObjIsBigEnough[i] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) && (MinDisToCar >= pSlot->DisFromCarToObj[i])) {
        MinDisToCar          = pSlot->DisFromCarToObj[i];
        MinDisToCarIndexTemp = i;
      }

      CurbCheckResult1 =
          APASlotProcCheckCurbType(MinDisToCar, pSlot->DisFromCarToObj[i], SlotDepthSearchingStepTemp, APASlotMaxDisCarToObjByPassingSlot);
      bUseTheNewSlotDepthToSearch = FALSE;
      if ((CurbCheckResult1 == 2) || (CurbCheckResult1 == 7)) {
        // 2 -- Curb
        // 7 -- no curb.

        bSlotMaybeFound = FALSE;

        // if(bSlotFirstPoint)
        {

          /*
           Consider the following:

           MinDisToCarIndexTemp			  m
           +----------------	  +----------------|
           |	  |				   +----|
           +-----|						|
           |
           |k
           +-------------------|
           | i						+---------
           +------------------------
           II
           II
           II
           \/

           m = MinDisToCarIndexTemp
           +----------------	  +----------------|
           |	  |				   +----|
           +-----|						|
           |
           |
           |
           +-------------------+
           | i						+---------
           +------------------------

           */
          for (n = i - 1; n > MinDisToCarIndexTemp; n--) {
            if ((pSlot->bObjIsBigEnough[n] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) {
              break;
            }
          }
          Obj1BdStartIndex = n;
          m = APASlotProcCheckSlotCheckDisToCarPtIndexByKnownIndex(pSlot, MinDisToCarIndexTemp, n + 1, MinDisToCarIndexTemp, &Obj1BdEndIndex);
          if (m == MinDisToCarIndexTemp) {
            // Dis < 1m, It is OK. just regarded the min dis to car index temp as car to obj dis pt.
            bSlotMaybeFound = TRUE;
          } else {
            /*
             check the following case:

             *******

             ****** <- this should be regarded as the start of the obj2.
             | 1m  |

             -------
             */

            MinDisToCarIndexTemp = m;
            MinDisToCar          = pSlot->DisFromCarToObj[MinDisToCarIndexTemp];

            SlotDepthSearchingStepTemp = SlotDepthSearchingStep - MinDisToCar;
            CurbCheckResult1 = APASlotProcCheckCurbType(
                MinDisToCar, pSlot->DisFromCarToObj[i], SlotDepthSearchingStepTemp, APACal.APASlotMaxDisCarToObjByPassingSlotWhenObjHasOffset);                
            if ((CurbCheckResult1 == 2) || (CurbCheckResult1 == 7)) {
              // 2 -- Curb
              // 7 -- no curb.
              bSlotMaybeFound = TRUE;
              // bSlotFirstPoint = FALSE;
            }
          }

          /*
           Consider the following:

           MinDisToCarIndexTemp
           +--------------| h
           +----|
           |
           |
           | h + 1
           +-------------------|						k
           |						+---------
           i +------------------------
           II
           II
           II
           \/
           +-------------------|
           |
           |
           |
           +--------------------++------------------

           */

#if 0 // kjy delete 2013 01 09
					if(bSlotMaybeFound
							&& (L > APA_SLOT_DIS_TO_CAR_CHECK_CAR_TRAVELLING_DIS_1)) {

						LTemp = pSlot->DisFromCarToObj[n];
						for(h = n - 1; h > MinDisToCarIndexTemp; h --) {
							if((pSlot->DisFromCarToObj[h] != NO_OBJ_DISTANCE)
									&& (SlotDepthSearchingStep > (pSlot->DisFromCarToObj[h] + APA_SLOT_CURB_DETECTION_DEPTH_TOL))) {
								break;
							}
							if((pSlot->DisFromCarToObj[h] < LTemp)
									&& ((pSlot->DisFromCarToObj[h]) <= SlotDepthSearchingStep)) {
								LTemp = pSlot->DisFromCarToObj[h];
							}
						}
						i1 = h + 1;
						X1 = MATH_ABS(pSlot->CarCenterPoint[i].x - pSlot->CarCenterPoint[i1].x) +
						MATH_ABS(pSlot->CarCenterPoint[i].y - pSlot->CarCenterPoint[i1].y);
						/*

						 -----| ---
						 -----		 |	^
						 -----				 |	| DeltaH
						 ----						 |	V
						 ------------------------------ ---
						 |<-----------X1------------->|

						 X1 > 2 * DeltaH
						 */

						DeltaH = SlotDepthSearchingStep - LTemp;

						if((X1 > (DeltaH * 2))
								&& (DeltaH > 0)) {
							X1 = LTemp - MinDisToCar - APACal.APASlotCurbLineTolerance;
							if(X1 < APACal.APASlotMinSlotDepth) {
								X1 = APACal.APASlotMinSlotDepth;
							}
							CurbCheckResult1 = APASlotProcCheckCurbType(MinDisToCar,
									pSlot->DisFromCarToObj[i - 1], // ??? or h + 1
									X1,
									APASlotMaxDisCarToObjByPassingSlot);
							if((CurbCheckResult1 == 2)
									|| (CurbCheckResult1 == 7)) {
								// Treat as invalid slot.
								bSlotMaybeFound = FALSE;
							}
						}
					}
#endif
        }

        if (bSlotMaybeFound) {
          /*if(CurbCheckResult1 == 2){
           // curb
           } else {
           // no curb
           }*/

          /*	Senario:

           MinDisToCarIndexTemp
           +-------------|
           k +-|
           |
           g	+---|
           |
           +---|
           |
           +---|
           |
           i - 1 +---|
           i +-------------------------------------
           */
          k = i;
          while (k > MinDisToCarIndexTemp) {
            k--;
            if ((APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[i], pSlot->CarCenterPoint[k])) <
                APACal.APASlotCarToObjDisCalObj1WidthToBeConsidered) {
              // Ok,
              if (((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) &&
                  ((pSlot->DisFromCarToObj[k] - MinDisToCar) < APACal.APASlotCarToObjDisCalObjToCarDisTolLen)) {
                break;
              }
            } else {
              break;
            }
          }
          g = k + 1; // The index of the slot start point.
          /*
           Pt1.Coordinate.x = pSlot->ObjPt[g].x;
           Pt1.Coordinate.y = pSlot->ObjPt[g].y;
           Pt1.DisFromCarToObj = MinDisToCar;
           PtCarAng1   = pSlot->CarAng[g];
           */

          if (((pSlot->bObjIsBigEnough[g] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) || (pSlot->DisFromCarToObj[g] == NO_OBJ_DISTANCE)) {
            SlotCalDisCarToObj1 = MinDisToCar;
          } else {
            SlotCalDisCarToObj1 = pSlot->DisFromCarToObj[g];
          }
          for (k = i + 1; k < pSlot->ObjPtCnt; k++) {
#if Debug_SW_COUNTLOOP
            if (CurrentSlotIndex == SlotIndexToDebug)
            {
              DebugLoopKCnt[1][0]++;
              DebugLoopKCnt[1][1] = DebugLoopKCnt[1][1] > DebugLoopKCnt[1][0] ? DebugLoopKCnt[1][1] : DebugLoopKCnt[1][0];
            }
#endif

#if 0
						if((pSlot->bObjIsBigEnough[k]) == 0) {
							CurbCheckResult2 = 7; // regarded as no curb.
						} else {
							CurbCheckResult2 = APASlotProcCheckCurbType(MinDisToCar,
									pSlot->DisFromCarToObj[k],
									SlotDepthSearchingStepTemp);
						}

#else
            if ((pSlot->bObjIsBigEnough[k] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) { // Kjy 2013 09 03 added. need to be debuged.
              CurbCheckResult2 = 7;                                                             // regarded as no curb.
            } else {
              CurbCheckResult2 =
                  APASlotProcCheckCurbType(MinDisToCar, pSlot->DisFromCarToObj[k], SlotDepthSearchingStepTemp, APASlotMaxDisCarToObjByPassingSlot);     
            }

#endif
            if ((CurbCheckResult2 == 2) || (CurbCheckResult2 == 7)) {
              // 2 -- Curb
              // 7 -- no curb.

              if (k == (pSlot->ObjPtCnt - 1)) {
                // the last one.
                // if(APASlotDefinition & APA_SLOT_ALLOW_SLOT_WITH_NO_OBJ_AT_TAIL)
                {
                  m     = k;
                  LTemp = APACal.APASlotMaxSlotLengthWithInvalidObj2 - APACal.APASlotDetectionCompensateLengthHead[0][0];
                  while (m > g) {

                    m--;
                    Y1 = (pSlot->CarCenterPoint[m].y - pSlot->CarCenterPoint[g].y);
                    if (Y1 < LTemp) {
                      LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g], pSlot->CarCenterPoint[m]);
                      if (LTemp2 < LTemp) {
                        m++;
                        break;
                      }
                    }

#if 0
										X1 = (pSlot->CarCenterPoint[g].x - pSlot->CarCenterPoint[m].x);
										Y1 = (pSlot->CarCenterPoint[m].y - pSlot->CarCenterPoint[g].y);
										if(CurrentSlotIndex == USSPar.APARightSlotDataIndex) {
											if(X1 < 0) {
												// Convex road
												X1 = -X1 / 4;
											} else {
												X1 = X1 / 2;
											}
										} else {
											if(X1 < 0) {
												// Convex road
												X1 = -X1 / 2;
											} else {
												X1 = X1 / 4;
											}
										}
										Y1 += X1;
										if(Y1 < LTemp) {
											break;
										}
										m --;
#endif
                  }
                  while (m < k) {
                    CurbCheckResult2 = APASlotProcCheckCurbType(
                        MinDisToCar, pSlot->DisFromCarToObj[m], SlotDepthSearchingStepTemp, APASlotMaxDisCarToObjByPassingSlot);
                    if ((CurbCheckResult2 == 2) || (CurbCheckResult2 == 7)) {
                      // curb
                      break;
                    } else {
                    }
                    m++;
                  }

#if 0
									Ang = MATH_FABS(pSlot->CarAng[g] - pSlot->CarAng[m]);
									Ang = MATH_FABS(pSlot->CarAng[g]) + Ang;
									Ang = Ang / APA_SLOT_WITHOUT_OBJ12_SLOT_LEN_COMP_MAX_DELTA_CAR_ANG;
									if(Ang > 2.0) {
										Ang = 2.0;
									}
									Ang *= APA_SLOT_WITHOUT_OBJ12_SLOT_LEN_COMP_MAX_LEN;
									LTemp -= Ang;
									/*if(Ang > 0)
									 {


									 while (m < k){
									 X1 = (pSlot->CarCenterPoint[m].x - pSlot->CarCenterPoint[g].x);
									 Y1 = (pSlot->CarCenterPoint[m].y - pSlot->CarCenterPoint[g].y);
									 if(Y1 < X1){
									 Y1 = X1;
									 }
									 if(Y1 >  LTemp){
									 break;
									 }
									 m ++;
									 }
									 } else*/
									{
										while(m > g) {
											X1 = (pSlot->CarCenterPoint[m].x - pSlot->CarCenterPoint[g].x);
											Y1 = (pSlot->CarCenterPoint[m].y - pSlot->CarCenterPoint[g].y);
											if(Y1 < X1) {
												Y1 = X1;
											}
											if(Y1 < LTemp) {
												break;
											}
											m --;
										}
									}
#endif
                  SlotCalDisCarToObj2 = NO_OBJ_DISTANCE;

                  Obj2BdStartIndex = m;
                  Obj2BdEndIndex   = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
                  if (DebugIsCurbDetected == 1) {
                  SlotDepth = APASlotProcCheckIsCurbDetected(pSlot,
                                                             MinDisToCar,
                                                             pSlot->DisFromCarToObj[m],
                                                             SlotDepthSearchingStepTemp,
                                                             g,
                                                             m,
                                                             &LTemp,
                                                             &SlotDepthDetected1,
                                                             &SlotDepthDetected2,
                                                             &SlotDepthDetected3,
                                                             &SlotLenDetected1,
                                                             &SlotLenDetected2,
                                                             &SlotLenDetected3,
                                                             4);}

// #if Debug_SW_COUNTLOOP
                if (CurrentSlotIndex == SlotIndexToDebug)
                {
                  iscurb_cnt[2][0]++;
                  iscurb_cnt[2][1] = iscurb_cnt[2][0] > iscurb_cnt[2][1] ? iscurb_cnt[2][0] : iscurb_cnt[2][1];
                }
                if (iscurb_cnt[2][0] > DebugMaxCnt)
                {
                  bAlreadyMaxCnt = TRUE;
                  i = k; /*20201106 kѭ��������Ҳ��iѭ������*/
                  break;
                }
// #endif 
                      /* 20201014 Fix bug  */
                  if (SlotDepth == -1)
                  {
                    bSlotMaybeFound = FALSE;
                    i = k;
                    break;
                  }
                  /* 20201014 Fix bug  */
                  CheckedSlotType =
                      APASlotProcCheckSlotLengthIsLargeEnough(&g,
                                                              &m,
                                                              pSlot,
                                                              &SlotCalDisCarToObj1,
                                                              &SlotCalDisCarToObj2,
                                                              APACalObjPtSnsIndex,
#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
                                                              USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotHeadCompensated,
                                                              USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotTailCompensated,
#endif
                                                              LTemp,
                                                              &APASlotDetectionCompensateLengthHead,
                                                              &APASlotDetectionCompensateLengthTail,
                                                              &SlotLenTotal,
                                                              SlotDepthDetected1,
                                                              SlotDepthDetected2,
                                                              SlotDepthDetected3,
                                                              &SlotLenDetected1,
                                                              &SlotLenDetected2,
                                                              &SlotLenDetected3,
                                                              Obj1BdStartIndex,
                                                              Obj1BdEndIndex,
                                                              Obj2BdStartIndex,
                                                              Obj2BdEndIndex,
                                                              &Obj1StartIndex,
                                                              &Obj1EndIndex,
                                                              &Obj2StartIndex,
                                                              &Obj2EndIndex,
                                                              &Obj1Width,
                                                              &Obj2Width,
                                                              &Obj1Type,
                                                              &Obj2Type);
                  if (CheckedSlotType != APA_SLOT_TYPE_INVALID) {
                    // DisToCarTemp1 = NO_OBJ_DISTANCE;
                    APASlotProcSlotFoundSaveSlot(CheckedSlotType,
                                                 SlotCalDisCarToObj1,
                                                 SlotCalDisCarToObj2,
                                                 g,
                                                 m,
                                                 StartIndex,
                                                 MinDisToCar,
                                                 NO_OBJ_DISTANCE,
                                                 SlotDepth,
                                                 SlotLenTotal,
                                                 APASlotDetectionCompensateLengthHead,
                                                 APASlotDetectionCompensateLengthTail,
                                                 CurrentSlotIndex,
                                                 SlotDepthDetected1,
                                                 SlotDepthDetected2,
                                                 SlotDepthDetected3,
                                                 SlotLenDetected1,
                                                 SlotLenDetected2,
                                                 SlotLenDetected3,
                                                 bTheSameSlotIsFound,
                                                 Obj1Type,
                                                 Obj2Type,
                                                 Obj1StartIndex,
                                                 Obj1EndIndex,
                                                 Obj2StartIndex,
                                                 Obj2EndIndex,
                                                 Obj1Width,
                                                 Obj2Width); 
                    return;
                  } else {
                    bSlotMaybeFound = FALSE;
                  }
                  /// need to be checked end
#if 0  // dsh 20120710
									if(CheckedSlotType == APA_SLOT_TYPE_INVALID) {
										if((SlotLenTotal >= APACal.APASlotMaxSlotLengthWithInvalidObj2) ///dsh 2012 07 09
												&& (SlotLenTotal < APACal.APASlotMaxSlotLength)) { ///dsh 2012 07 09
											// Parallel parking slot is found.
											CheckedSlotType = APA_SLOT_TYPE_PARALLEL;
										} else if((SlotLenTotal >= APACal.APASlotPMaxSlotLengthWithInvalidObj2)///dsh 2012 07 09
												&& (SlotLenTotal < APACal.APASlotPMaxSlotLength)) { ///dsh 2012 07 09
											CheckedSlotType = APA_SLOT_TYPE_PERPENDICULAR;
										}
									}
#endif // dsh 20120710
                }
                i = k;
                // bSlotFirstPoint = TRUE;
                break;
              } else {
                // This is a minor point. it can be deleted.
                // remove k.
                /*if((bDeletePoint == FALSE)
                 && (pMainSlot->WrIndex >= EndIndex)){
                 bDeletePoint = TRUE;
                 Counter1 = k;
                 n = k + 1;
                 for(; n < EndIndex; n ++){
                 pMainSlot->OutlinePoint[Counter1].Coordinate.x = pMainSlot->OutlinePoint[n].Coordinate.x;
                 pMainSlot->OutlinePoint[Counter1].Coordinate.y = pMainSlot->OutlinePoint[n].Coordinate.y;
                 pMainSlot->OutlinePoint[Counter1].DisFromCarToObj = pMainSlot->DisFromCarToObj[n];
                 pMainSlot->CarCenterPoint[Counter1].x = pMainSlot->CarCenterPoint[n].x;
                 pMainSlot->CarCenterPoint[Counter1].y = pMainSlot->CarCenterPoint[n].y;
                 pMainSlot->CarAng[Counter1] = pMainSlot->CarAng[n];
                 Counter1 ++;
                 }
                 pMainSlot->WrIndex --;
                 k --;
                 }*/
              }
            } else {
              // Obj2 border start.
              /*
               Consider the following: n
               +
               1
               +------------
               m							n			|
               k + 1	+----------------			+---------- |
               +----				|			|
               |					+-----------
               |
               k					|
               +-------------------|
               k - 1					|
               +------------------------

               */

              DisToCarTemp1    = pSlot->DisFromCarToObj[k];
              m                = k;
              Obj2BdStartIndex = k;
              Obj2BdEndIndex   = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
              // Check if the obj2 is valid or not.
              // 1. cal the slot length with the searching slot depth.
              SlotLenWithFirstSlotDepth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g], pSlot->CarCenterPoint[k]);

              if (SlotLenWithFirstSlotDepth < (APACal.APASlotMinPerSlotDeltaCarPosDisAtSlotStartAndEndPt)) {
                // Slot len is less than min per len
                // regarded as no slot.
                i = k;
                break;
              } else {
                bFlag = FALSE; // Obj2 is not exist.
                for (n = k; n < (pSlot->ObjPtCnt - 1); n++) {
                  if ((pSlot->bObjIsBigEnough[n] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                    // regard as no obj detected.
                  } else {
                    LTemp = pSlot->DisFromCarToObj[n] - MinDisToCar;
                    if (/*(pSlot->DisFromCarToObj[n] > APASlotMaxDisCarToObjByPassingSlot)
                     &&*/
                        (LTemp > APACal.APASlotMinSlotDepth)) {
                      // regard the start point as no object.
                    } else {
                      bFlag = TRUE; // Obj2 is exist.
                      break;
                    }
                  }
                }
                n--;
                if (n > k) {
                  SlotLenWithSecondSlotDepth = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[k], pSlot->CarCenterPoint[n]);
                  if (SlotLenWithSecondSlotDepth > APACal.APASlotConsiderSecondSlotDepthMinDeltaSlotLen) {
                    if (SlotLenWithFirstSlotDepth > APACal.APASlotRegardAsFirstSlotDepthMinSlotLen) {
                      // Use the first slot depth which is the current searching slot depth.
                    } else {
                      if ((bFlag == TRUE) && (SlotLenWithSecondSlotDepth < (APACal.APASlotConsiderSecondSlotDepthMinDeltaSlotLen + 1500))) {
                        p      = k;
                        LTemp2 = APACal.APASlotMinSlotDepth / 2;
                        q      = n + 2;
                        if (q > (pSlot->ObjPtCnt - 1)) {
                          q = (pSlot->ObjPtCnt - 1);
                        }
                        for (j = k + 1; j < q; j++) {
                          if ((pSlot->bObjIsBigEnough[j] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                            // regard as no obj detected.
                          } else {
                            LTemp = pSlot->DisFromCarToObj[p] - pSlot->DisFromCarToObj[j];
                            if ((LTemp > LTemp2)) {
                              // regard the start point of obj2.
                              bFlag = FALSE;
                              break;
                            } else {
                            }
                            p = j;
                          }
                        }
                        if (bFlag == FALSE) {
                          // Use the second slot depth as the slot depth.
                          // just break to next loop.
                          bUseTheNewSlotDepthToSearch = TRUE;
                          break;
                        } else {
                          // Use the first slot depth.
                        }
                      } else {
                        // Use the second slot depth as the slot depth.
                        // just break to next loop.
                        bUseTheNewSlotDepthToSearch = TRUE;
                        break;
                      }
                    }
                  } else {
                    // Use the first slot depth.
                  }
                }
                bRegardObj1Or2AsInvalid = FALSE;
                n                       = k + 1;
                h                       = (pSlot->ObjPtCnt - 1);
                if (n < h) {
                  bRegardObj1Or2AsInvalid =
                      APASlotProcCheckSlotCheckDisToCarPtIndexWithoutKnownIndex(pSlot, MinDisToCar, k, h, &Obj2BdEndIndex, &m, &n);
                  DisToCarTemp1 = pSlot->DisFromCarToObj[m];
                }
                if (n > h) {
                  n = h;
                }
                /*if(MATH_ABS(DisToCarTemp1) > APASlotMaxDisCarToObjByPassingSlot){

                 if(APASlotDefinition & APA_SLOT_ALLOW_SLOT_WITH_OBJ2_INVALID_DIS_TO_CAR){
                 // Slot found
                 } else {
                 // Not a slot.
                 //i = k;
                 // bSlotFirstPoint = TRUE;
                 break;
                 }

                 } */

                /*
                 Consider the following:										m
                 +--------
                 +---
                 k + 1	 |
                 +--------|
                 i						k					|
                 |
                 |
                 +-------------------|
                 +-----------------------|

                 II
                 II
                 II
                 \/
                 +-------------------
                 |
                 |
                 |
                 ------------------------+-------------------|

                 */

#if 0 // kjy delete 2013 01 09
								L = MATH_ABS(pSlot->CarCenterPoint[m].x - pSlot->CarCenterPoint[k].x) +
								MATH_ABS(pSlot->CarCenterPoint[m].y - pSlot->CarCenterPoint[k].y);
								bFlag = TRUE;
								if(L > APA_SLOT_DIS_TO_CAR_CHECK_CAR_TRAVELLING_DIS_1) {
									LTemp = pSlot->DisFromCarToObj[k];
									for(h = k + 1; h <= m; h ++) {
										if((pSlot->DisFromCarToObj[h] != NO_OBJ_DISTANCE)
												&& (SlotDepthSearchingStep > (pSlot->DisFromCarToObj[h] + APA_SLOT_CURB_DETECTION_DEPTH_TOL))) {
											break;
										}
										if((pSlot->DisFromCarToObj[h] < LTemp)
												&& ((pSlot->DisFromCarToObj[h]) <= SlotDepthSearchingStep)) {
											LTemp = pSlot->DisFromCarToObj[h];
										}
									}
									X1 = MATH_ABS(pSlot->CarCenterPoint[h].x - pSlot->CarCenterPoint[k].x) +
									MATH_ABS(pSlot->CarCenterPoint[h].y - pSlot->CarCenterPoint[k].y);
									/*

									 -----| ---
									 -----		 |	^
									 -----				 |	| DeltaH
									 ----						 |	V
									 ------------------------------ ---
									 |<-----------X1------------->|

									 X1 > 2 * DeltaH
									 */

									DeltaH = SlotDepthSearchingStep - LTemp;

									if((X1 > (DeltaH * 2))
											&& (DeltaH > 0)) {
										X1 = LTemp - MinDisToCar - APACal.APASlotCurbLineTolerance;
										if(X1 < APACal.APASlotMinSlotDepth) {
											X1 = APACal.APASlotMinSlotDepth;
										}
										CurbCheckResult1 = APASlotProcCheckCurbType(MinDisToCar,
												pSlot->DisFromCarToObj[k], // ???? or h - 1
												X1);
										if((CurbCheckResult1 == 2)
												|| (CurbCheckResult1 == 7)) {
											// Treat as invalid slot.
											bFlag = FALSE;
										}
									}
								}
								if(bFlag == TRUE)
#endif

                {

                  /*
                   Consider the following:					m
                   h	 +--------
                   +---
                   k + 1	 |
                   +--------|
                   i						k	|
                   |
                   |
                   +----
                   +-----------------------|

                   II
                   II
                   II
                   \/										h
                   +-------------------
                   |
                   |
                   i										|
                   +---------------------------------------|

                   */

                  // g = start pt
                  // n - end pt
                  // Consider the following:
                  /*
                   Obj1Index
                   --------+
                   |
                   |
                   |
                   |	            g = curb
                   +---------------+
                   |
                   |
                   |
                   |	No Obj Index
                   +----------------

                   Actually g is the curb start index

                   */

                  // Obj2.
                  if ((pSlot->bObjIsBigEnough[g] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                    LTemp2 = pSlot->DisFromCarToObj[g - 1]; // g = k + 1, when k is the slot start point(object1 end point)
                  } else {
                    LTemp2 = pSlot->DisFromCarToObj[g];
                  }
                  CurbCheckResult2 =
                      APASlotProcCheckCurbType(pSlot->DisFromCarToObj[m], LTemp2, APACal.APASlotMinSlotDepth, APASlotMaxDisCarToObjByPassingSlot);
                  if (CurbCheckResult2 == 2) {
                    // Curb.
                    // Search back to get the start point of obj2.
                    while (g > MinDisToCarIndexTemp) {
                      g--;
                      if (pSlot->bObjIsBigEnough[g] == 0) {
                        CurbCheckResult2 = 7; // regarded as no curb.
                      } else {
                        CurbCheckResult2 = APASlotProcCheckCurbType(
                            pSlot->DisFromCarToObj[m], pSlot->DisFromCarToObj[g], APACal.APASlotMinSlotDepth, APASlotMaxDisCarToObjByPassingSlot);
                      }
                      if ((CurbCheckResult2 == 2) || (CurbCheckResult2 == 7)) {
                        // curb
                      } else {
                        break;
                      }
                    }
                  }
                  
                  if (bRegardObj1Or2AsInvalid == FALSE) {
                    n = k;
                    while (n < m) {
                      n++;
                      if ((APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[n], pSlot->CarCenterPoint[k])) <
                          APACal.APASlotCarToObjDisCalObj2WidthToBeConsidered) {
                        // Ok,
                        if (((pSlot->DisFromCarToObj[n] - DisToCarTemp1) < APACal.APASlotCarToObjDisCalObjToCarDisTolLen) &&
                            ((pSlot->bObjIsBigEnough[n] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0)) {
                          n--;
                          break;
                        }
                      } else {
                        n--;
                        break;
                      }
                    }
                    // n Slot End Point index. obj2
                    h = n;
                    while (h > g) {
                      if ((pSlot->bObjIsBigEnough[h] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) {
                        break;
                      }
                      h--;
                    }
                    if (h >= k) {
                      n = h;
                    } else {
                      while (h < m) {
                        if ((pSlot->bObjIsBigEnough[h] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0) {
                          break;
                        }
                        h++;
                      }
                      n = h;
                    }
                    SlotCalDisCarToObj2 = DisToCarTemp1;
                  } else {
                    // Obj 2 is regarded as invalid.
                    // n = end pt
                    // g = start pt

                    LTemp = APACal.APASlotMaxSlotLengthWithInvalidObj2 - APACal.APASlotDetectionCompensateLengthHead[0][0];
                    if (n >= pSlot->ObjPtCnt) {
                      n = pSlot->ObjPtCnt - 1;
                    }
                    while (n > g) {
                      n--;
                      Y1 = (pSlot->CarCenterPoint[n].y - pSlot->CarCenterPoint[g].y);
                      if (Y1 < LTemp) {
                        LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g], pSlot->CarCenterPoint[n]);
                        if (LTemp2 < LTemp) {
                          n++;
                          break;
                        }
                      }

#if 0
											X1 = (pSlot->CarCenterPoint[g].x - pSlot->CarCenterPoint[n].x);
											Y1 = (pSlot->CarCenterPoint[n].y - pSlot->CarCenterPoint[g].y);
											if(CurrentSlotIndex == USSPar.APARightSlotDataIndex) {
												if(X1 < 0) {
													// Convex road
													X1 = -X1 / 4;
												} else {
													X1 = X1 / 2;
												}
											} else {
												if(X1 < 0) {
													// Convex road
													X1 = -X1 / 2;
												} else {
													X1 = X1 / 4;
												}
											}
											Y1 += X1;
											if(Y1 < LTemp) {
												break;
											}
											n --;
#endif
                    }
                    SlotCalDisCarToObj2 = NO_OBJ_DISTANCE;
                    // DisToCarTemp1 = NO_OBJ_DISTANCE;
                  }
                  if (DebugIsCurbDetected == 1) {
                  SlotDepth = APASlotProcCheckIsCurbDetected(pSlot,
                                                             MinDisToCar,
                                                             DisToCarTemp1,
                                                             SlotDepthSearchingStepTemp,
                                                             g,
                                                             n,
                                                             &LTemp,
                                                             &SlotDepthDetected1,
                                                             &SlotDepthDetected2,
                                                             &SlotDepthDetected3,
                                                             &SlotLenDetected1,
                                                             &SlotLenDetected2,
                                                             &SlotLenDetected3,
                                                             5);}

// #if Debug_SW_COUNTLOOP
                  if (CurrentSlotIndex == SlotIndexToDebug)
                  {
                    iscurb_cnt[3][0]++;
                    iscurb_cnt[3][1] = iscurb_cnt[3][0] > iscurb_cnt[3][1] ? iscurb_cnt[3][0] : iscurb_cnt[3][1];
                  }
                  if (iscurb_cnt[3][0] > DebugMaxCnt)
                  {
                    bAlreadyMaxCnt = TRUE;
                    break;
                  }
// #endif 
                   /* 20201014 Fix bug  */
                  if (SlotDepth != -1)
                  {
                  
                  CheckedSlotType =
                      APASlotProcCheckSlotLengthIsLargeEnough(&g,
                                                              &n,
                                                              pSlot,
                                                              &SlotCalDisCarToObj1,
                                                              &SlotCalDisCarToObj2,
                                                              APACalObjPtSnsIndex,
#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
                                                              USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotHeadCompensated,
                                                              USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotTailCompensated,
#endif
                                                              LTemp,
                                                              &APASlotDetectionCompensateLengthHead,
                                                              &APASlotDetectionCompensateLengthTail,
                                                              &SlotLenTotal,
                                                              SlotDepthDetected1,
                                                              SlotDepthDetected2,
                                                              SlotDepthDetected3,
                                                              &SlotLenDetected1,
                                                              &SlotLenDetected2,
                                                              &SlotLenDetected3,
                                                              Obj1BdStartIndex,
                                                              Obj1BdEndIndex,
                                                              Obj2BdStartIndex,
                                                              Obj2BdEndIndex,
                                                              &Obj1StartIndex,
                                                              &Obj1EndIndex,
                                                              &Obj2StartIndex,
                                                              &Obj2EndIndex,
                                                              &Obj1Width,
                                                              &Obj2Width,
                                                              &Obj1Type,
                                                              &Obj2Type);
                  }
                  else
                  {
                    CheckedSlotType = APA_SLOT_TYPE_INVALID;
                  }
                  if ((CheckedSlotType == APA_SLOT_TYPE_INVALID) ||
                      ((bRegardObj1Or2AsInvalid == TRUE) && (CheckedSlotType == APA_SLOT_TYPE_PARALLEL))) {
                    // i = k;
                    // bSlotFirstPoint = TRUE;
                    bSlotMaybeFound = FALSE;
                    if ((SlotLenTotal > APACal.APASlotMaxSlotLength) || (bRegardObj1Or2AsInvalid == TRUE)) {
                      // Since the Parallel parking max slot length will great than the max perpendicular parking slot width.
                      // just use the max parallel slot length to check.
                      // Just regard the obj1 as invalid.
                      // g = start pt.
                      // n = end pt.
                      m     = g + 1;
                      LTemp = APACal.APASlotMaxSlotLengthWithInvalidObj2 - APACal.APASlotDetectionCompensateLengthTail[0][0];
                      while (m < n) {

                        m++;
                        Y1 = (pSlot->CarCenterPoint[n].y - pSlot->CarCenterPoint[m].y);
                        if (Y1 < LTemp) {
                          LTemp2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[n], pSlot->CarCenterPoint[m]);
                          if (LTemp2 < LTemp) {
                            m--;
                            break;
                          }
                        }

#if 0
												if(CurrentSlotIndex == USSPar.APARightSlotDataIndex) {
													X1 = (pSlot->CarCenterPoint[n].x - pSlot->CarCenterPoint[m].x);
												} else {
													X1 = (pSlot->CarCenterPoint[m].x - pSlot->CarCenterPoint[n].x);
												}
												Y1 = (pSlot->CarCenterPoint[n].y - pSlot->CarCenterPoint[m].y);
												Y1 += X1 + (X1 / 2);
												/*
												 if(Y1 < X1){
												 Y1 = X1;
												 }
												 */
												if(Y1 < LTemp) {
													break;
												}
												m ++;

#endif
                      }
                      while (m > g) {
                        CurbCheckResult2 = APASlotProcCheckCurbType(
                            DisToCarTemp1, pSlot->DisFromCarToObj[m], SlotDepthSearchingStepTemp, APASlotMaxDisCarToObjByPassingSlot);                          

                        if ((CurbCheckResult2 == 2) || (CurbCheckResult2 == 7)) {
                          // curb
                          break;
                        } else {
                        }
                        m--;
                      }
                      if (DebugIsCurbDetected == 1) {
                      SlotDepth = APASlotProcCheckIsCurbDetected(pSlot,
                                                                 pSlot->DisFromCarToObj[m],
                                                                 DisToCarTemp1,
                                                                 SlotDepthSearchingStepTemp,
                                                                 m,
                                                                 n,
                                                                 &LTemp,
                                                                 &SlotDepthDetected1,
                                                                 &SlotDepthDetected2,
                                                                 &SlotDepthDetected3,
                                                                 &SlotLenDetected1,
                                                                 &SlotLenDetected2,
                                                                 &SlotLenDetected3,
                                                                 6);}

// #if Debug_SW_COUNTLOOP
                  if (CurrentSlotIndex == SlotIndexToDebug)
                  {
                    iscurb_cnt[4][0]++;
                    iscurb_cnt[4][1] = iscurb_cnt[4][0] > iscurb_cnt[4][1] ? iscurb_cnt[4][0] : iscurb_cnt[4][1];
                  }
                  if (iscurb_cnt[4][0] > DebugMaxCnt)
                  {
                    bAlreadyMaxCnt = TRUE;
                    break;
                  }
// #endif
                          /* 20201014 Fix bug  */
                      if (SlotDepth == -1)
                      {
                        bSlotMaybeFound = FALSE;
                        i = k; /*20201106 kѭ��������Ҳ��iѭ������*/
                        break;
                      }
                      /* 20201014 Fix bug  */
                      // Notes: n = slot end point index = obj2 index.
                      //        m = slot start point index = obj1 index.
                      SlotCalDisCarToObj1 = NO_OBJ_DISTANCE;
                      CheckedSlotType =
                          APASlotProcCheckSlotLengthIsLargeEnough(&m,
                                                                  &n,
                                                                  pSlot,
                                                                  &SlotCalDisCarToObj1,
                                                                  &SlotCalDisCarToObj2,
                                                                  APACalObjPtSnsIndex,
#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
                                                                  USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotHeadCompensated,
                                                                  USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].bSlotTailCompensated,
#endif
                                                                  LTemp,
                                                                  &APASlotDetectionCompensateLengthHead,
                                                                  &APASlotDetectionCompensateLengthTail,
                                                                  &SlotLenTotal,
                                                                  SlotDepthDetected1,
                                                                  SlotDepthDetected2,
                                                                  SlotDepthDetected3,
                                                                  &SlotLenDetected1,
                                                                  &SlotLenDetected2,
                                                                  &SlotLenDetected3,
                                                                  Obj1BdStartIndex,
                                                                  Obj1BdEndIndex,
                                                                  Obj2BdStartIndex,
                                                                  Obj2BdEndIndex,
                                                                  &Obj1StartIndex,
                                                                  &Obj1EndIndex,
                                                                  &Obj2StartIndex,
                                                                  &Obj2EndIndex,
                                                                  &Obj1Width,
                                                                  &Obj2Width,
                                                                  &Obj1Type,
                                                                  &Obj2Type); 
                      if (CheckedSlotType != APA_SLOT_TYPE_INVALID) {
                        // Slot found.
                        APASlotProcSlotFoundSaveSlot(CheckedSlotType,
                                                     SlotCalDisCarToObj1,
                                                     SlotCalDisCarToObj2,
                                                     m,
                                                     n,
                                                     StartIndex,
                                                     MinDisToCar,
                                                     NO_OBJ_DISTANCE,
                                                     SlotDepth,
                                                     SlotLenTotal,
                                                     APASlotDetectionCompensateLengthHead,
                                                     APASlotDetectionCompensateLengthTail,
                                                     CurrentSlotIndex,
                                                     SlotDepthDetected1,
                                                     SlotDepthDetected2,
                                                     SlotDepthDetected3,
                                                     SlotLenDetected1,
                                                     SlotLenDetected2,
                                                     SlotLenDetected3,
                                                     bTheSameSlotIsFound,
                                                     Obj1Type,
                                                     Obj2Type,
                                                     Obj1StartIndex,
                                                     Obj1EndIndex,
                                                     Obj2StartIndex,
                                                     Obj2EndIndex,
                                                     Obj1Width,
                                                     Obj2Width);
                      return;
                      } else {
                        bSlotMaybeFound = FALSE;
                      }
                    }
                    i = k; /*20201106 kѭ��������Ҳ��iѭ������*/
                    break;
                  } else {
                    // Slot found.
                    // i = g;
                    // k = n;
                    if (CheckedSlotType != APA_SLOT_TYPE_PARALLEL) {
                      // It is not parallel parking slot.
                      // Check if it is a parallel parking slot.
                      /*

                       -------+
                       |
                       |
                       |          k
                       | no obj   +----------------- curb

                       */
                      LTemp = MinDisToCar + APACal.APASlotMinSlotDepth;
                      if (DisToCarTemp1 > LTemp) {
                        // It may be a parallel slot with curb.
                        for (m = k + 1; m < pSlot->ObjPtCnt; m++) {
                          if (((pSlot->DisFromCarToObj[m]) < LTemp) &&
                              ((pSlot->bObjIsBigEnough[m] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) != 0)) {
                            break;
                          }
                        }
                        LTemp = APATrajCalGetTwoPointDisInt(
                            pSlot->CarCenterPoint[g].x, pSlot->CarCenterPoint[g].y, pSlot->CarCenterPoint[m].x, pSlot->CarCenterPoint[m].y);
                        if (LTemp > (APACal.APASlotMinSmallSlotLen - APACal.APASlotDetectionToleranceDis - APASlotDetectionCompensateLengthHead -
                                     APASlotDetectionCompensateLengthTail)) {
                          // It may be a parallel slot with curb.
                          // regard as parallel slot.
                          /*CheckedSlotType = APA_SLOT_TYPE_INVALID;
                           if(m > (k + 1)){
                           k = m - 2;
                           }
                           */
                          // It is no need to search the current slot again.
                          i = k;
                          break;
                        }
                      }
                    }
                    // if(CheckedSlotType != APA_SLOT_TYPE_INVALID)
                    {
                      APASlotProcSlotFoundSaveSlot(CheckedSlotType,
                                                   SlotCalDisCarToObj1,
                                                   SlotCalDisCarToObj2,
                                                   g,
                                                   n,
                                                   StartIndex,
                                                   MinDisToCar,
                                                   DisToCarTemp1,
                                                   SlotDepth,
                                                   SlotLenTotal,
                                                   APASlotDetectionCompensateLengthHead,
                                                   APASlotDetectionCompensateLengthTail,
                                                   CurrentSlotIndex,
                                                   SlotDepthDetected1,
                                                   SlotDepthDetected2,
                                                   SlotDepthDetected3,
                                                   SlotLenDetected1,
                                                   SlotLenDetected2,
                                                   SlotLenDetected3,
                                                   bTheSameSlotIsFound,
                                                   Obj1Type,
                                                   Obj2Type,
                                                   Obj1StartIndex,
                                                   Obj1EndIndex,
                                                   Obj2StartIndex,
                                                   Obj2EndIndex,
                                                   Obj1Width,
                                                   Obj2Width);
                      return;
                    }
                  }
                }
              }
            }
          }
          if (bAlreadyMaxCnt == TRUE)
          {
            break;
          }
        }
      }
      if (bUseTheNewSlotDepthToSearch == TRUE) {
        break;
      }
    }
    if (bAlreadyMaxCnt == TRUE)
    {
      break;
    }

    MaxDisToCar = SlotDepthSearchingStep;
    // use the parallel parking parameter to check.
    L = APACal.APASlotMinSlotDepth;

  } while (SlotDepthSearchingStep >= L);
#if Debug_SW_ExeTimeTest                               
  Task_LoopDoWhileExeTimeTest[1][1] = Stm_ReadTimerValue(0, 0);
  Task_LoopDoWhileExeTimeTest[1][2] = Task_LoopDoWhileExeTimeTest[1][1] - Task_LoopDoWhileExeTimeTest[1][0];
  if (Task_LoopDoWhileExeTimeTest[1][3] < Task_LoopDoWhileExeTimeTest[1][2]) {
    Task_LoopDoWhileExeTimeTest[1][3] = Task_LoopDoWhileExeTimeTest[1][2];
  } else {
  }
#endif
  }
  if (bSlotAlreadyFound == TRUE) {
    return;
  }
APACheckSlot_NoSlotFound:
  if (USSPar.Slot[CurrentSlotIndex].SlotNum > 0) {
    MaxSlotNumIndex = USSPar.Slot[CurrentSlotIndex].SlotNum - 1;
    if ((StartIndex <= USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].SlotStartIndex) &&
        (USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].CarPassTheSlotEndPtDistance < APACal.APASlotDisToCarCheckCarDrvDis2)) {
      // The slot is firstly found but now it is double check as not a valid slot,
      // it should be removed.

      // Remove the same slot.
#if 0
			should not use the following code: it will cause the previous slot be calculated again and again.
			MaxSlotNumIndex = USSPar.Slot[CurrentSlotIndex].SlotNum;
			while(MaxSlotNumIndex > 0) {
				MaxSlotNumIndex --;
				USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].TrajectoryCalRequestType = APAParkProcSlotFoundTrajCalReqWithoutCaled;
			}
#else
      USSPar.Slot[CurrentSlotIndex].SlotPar[MaxSlotNumIndex].TrajectoryCalRequestType = APAParkProcSlotFoundTrajCalReqWithoutCaled;
#endif
      USSPar.Slot[CurrentSlotIndex].SlotNum--;
    }
  }
  return;
}

void APASlotProcSlotFoundSaveSlot(APA_ENUM_TYPE SlotType,
                                  APA_DISTANCE_TYPE SlotCalDisCarToObj1, // APASlotCoordinateDataType Pt1,
                                  APA_DISTANCE_TYPE SlotCalDisCarToObj2, // APASlotCoordinateDataType Pt2,
                                  APA_ENUM_TYPE SlotStartPtIndex,
                                  APA_ENUM_TYPE SlotEndPtIndex,
                                  APA_ENUM_TYPE StartIndex,
                                  APA_DISTANCE_TYPE DisCarToObj1ByPassingSlot,
                                  APA_DISTANCE_TYPE DisCarToObj2ByPassingSlot,
                                  APA_DISTANCE_TYPE SlotDepth,
                                  APA_DISTANCE_TYPE SlotLenTotal,
                                  APA_DISTANCE_TYPE APASlotDetectionCompensateLengthHead,
                                  APA_DISTANCE_TYPE APASlotDetectionCompensateLengthTail,
                                  UCHAR CurrentSlotIndex,
                                  APA_DISTANCE_TYPE SlotDepthDetected1,
                                  APA_DISTANCE_TYPE SlotDepthDetected2,
                                  APA_DISTANCE_TYPE SlotDepthDetected3,
                                  APA_DISTANCE_TYPE SlotLenDetected1,
                                  APA_DISTANCE_TYPE SlotLenDetected2,
                                  APA_DISTANCE_TYPE SlotLenDetected3,
                                  BOOLEAN bSameSlotFound,
                                  APA_ENUM_TYPE Obj1Type,
                                  APA_ENUM_TYPE Obj2Type,
                                  APA_ENUM_TYPE Obj1StartIndex,
                                  APA_ENUM_TYPE Obj1EndIndex,
                                  APA_ENUM_TYPE Obj2StartIndex,
                                  APA_ENUM_TYPE Obj2EndIndex,
                                  APA_DISTANCE_TYPE Obj1Width,
                                  APA_DISTANCE_TYPE Obj2Width

) {
  // Pt1: Slot Start Point used to calculate the slot length.
  // Pt2: Slot end point used to calculate the slot length.
 if (DebugSaveSlot == 0) {
   return;
 }
  APA_ENUM_TYPE SlotIndex, SlotEndPtIndexTemp, SlotStartPtIndexTemp, CurSlotNum;

  /*	Senario1:

   +-----------|
   Obj1	|									Obj2 = Invalid
   |
   |
   |Pt1								  Pt2
   +--------------------------------------+
   */
  /*	Senario12:

   +-----------|
   |						Pt2
   Obj1	|						+---------------
   |						|	Obj2
   |Pt1					|
   +------------------------
   */
  /*	Senario3:							Pt2
   +--------------
   |
   Obj1 = Invalid							|	Obj2
   |
   Pt1									|
   +------------------------------------
   */
  /*	Senario14:
   Pt2
   +---------------
   |
   +-----------|						|	Obj2
   |						|
   Obj1	|Pt1					|
   +------------------------
   */

  CurSlotNum = USSPar.Slot[CurrentSlotIndex].SlotNum;
  if (bSameSlotFound == TRUE) {
    CurSlotNum--;
  }

#ifdef APA_SLOT_SUPPORT_DEBUG1

  if ((Obj1Type != APA_SLOT_OBJ_TYPE_UNKNOWN) && (((SlotStartPtIndex) < (Obj1EndIndex)) || ((SlotStartPtIndex) > (Obj1StartIndex)))) {

    // Data error ??
    cSlotDebug = 1;
  }
#endif

  if (CurSlotNum <= APA_SLOT_SUPPORT_MAX_SLOT_NUM) {
    // Slot found.

    /*
     Slot Parameter:

     SlotStartIndex
     SlotStartIndex - 1							SlotEndIndex
     +			+ --+-					+--+-----+---
     DisCarToObj2ByPassingSlot	|	|					|  |     |
     | 			|	|					|  |     |
     V			| SlotCalDisCarToObj1	| SlotCalDisCarToObj2
     ------------+	|	+				|  |     DisCarToObj2ByPassingSlot
     |	|	|				|  |     |
     |	|	SlotDepth		+  |-----+------
     |	|	|				V--+-
     V	|	|				|
     +---+---+---------------+

     +----SlotLength---------+
     */

    // check object width:
    if (DisCarToObj1ByPassingSlot == NO_OBJ_DISTANCE) {
      // Obj1 does not exist, Obj2 exist.
      if (Obj2Width < APACal.APASlotObj1NotExistObj2ExistRegardedAsValidSlotAllowedMinObj2Width) {
        // Obj2 < 80cm.
        // NG.
        return;
      } else {
        // OK,
      }
    } else {
      if (DisCarToObj2ByPassingSlot == NO_OBJ_DISTANCE) {
        // Obj1 exist, obj2 not
        if (Obj1Width < APACal.APASlotObj1ExistObj2NotExistRegardedAsValidSlotAllowedMinObj1Width) {
          // obj1 width < 80cm
          // NG.
          return;
        } else {
          // OK,
        }

      } else {
        // both obj12 exist.
        if (Obj1Width < APACal.APASlotObj12ExistRegardedAsValidSlotAllowedMinObj1Width3) {
          // obj1 > 80cm,
          if (Obj2Width < APACal.APASlotObj12ExistRegardedAsValidSlotAllowedMinObj2Width1) {
            // Obj2 < 0.
            // NG.
            return;
          }
        } else if (Obj2Width > APACal.APASlotObj12ExistRegardedAsValidSlotAllowedMinObj2Width3) {
          // Obj2 0 ~ 30cm.
          if (Obj1Width < APACal.APASlotObj12ExistRegardedAsValidSlotAllowedMinObj1Width1) {
            // obj1 < 0,
            // NG
            return;
          }
        } else {

          if (Obj1Width < APACal.APASlotObj12ExistRegardedAsValidSlotAllowedMinObj1Width2) {
            // obj1 0~30cm,
            if (Obj2Width < APACal.APASlotObj12ExistRegardedAsValidSlotAllowedMinObj2Width2) {
              // Obj2 0 ~ 30cm.
              // NG.
              return;
            }
          } else {
            // obj1 30~80cm,
            if (Obj2Width <= APACal.APASlotObj12ExistRegardedAsValidSlotAllowedMinObj2Width1) {
              // Obj2 0 ~ 30cm.
              // NG.
              return;
            }
          }
        }
      }
    }
    SlotIndex = 0;
    while (SlotIndex < CurSlotNum) {
      if (USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotEndIndex > SlotStartPtIndex) {
        // The same slot.
        //
        bSameSlotFound = TRUE;
        CurSlotNum     = SlotIndex;
        break;
      }
      SlotIndex++;
    }

    SlotIndex = CurSlotNum;
    /*wsc 20200716*/
    if (SlotIndex == APA_SLOT_SUPPORT_MAX_SLOT_NUM) 
    {
      USSPar.Slot[CurrentSlotIndex].SlotPar[0] = USSPar.Slot[CurrentSlotIndex].SlotPar[1];
      USSPar.Slot[CurrentSlotIndex].SlotPar[1] = USSPar.Slot[CurrentSlotIndex].SlotPar[2];
      USSPar.Slot[CurrentSlotIndex].SlotNum--;
      CurSlotNum--;
      SlotIndex--;
    }
    /*wsc 20200716*/
    if (SlotIndex < APA_SLOT_SUPPORT_MAX_SLOT_NUM) {

      /*	Senario:

       h = slot start index.
       g = slot end index.
       MinDisToCarIndexTemp
       StartIndex ... m,  n
       g
       +----------
       +-----+---+---|<--------------------------Slot Length---------------------------------->+---|			|
       h +-| |
       |
       |
       |																	+---
       |
       |
       +---|															+---
       +-----------| |															|
       +---|													+---
       |													|
       +---| 											+---
       |											|
       k+----|								i	 +--
       +------------------------------+----
       ===>

       if this is the first slot.

       StartIndex
       g
       +----------
       +-------------|<--------------------------Slot Length---------------------------------->+---|			|
       h +-| |
       |
       |
       |																	+---
       |
       |
       +---|															+---
       +-----------| |															|
       +---|													+---
       |													|
       +---| 											+---
       |											|
       k+----|								i	 +--
       +------------------------------+----
       else
       Option 1: (not used)

       StartIndex		StartIndex + 1 = n
       g
       +----------
       +---------+---|<--------------------------Slot Length---------------------------------->+---|			|
       |			h +-|
       | | | |				|
       +---	|			| |				+---|
       +---		+-----------| |					|
       | |					+---| +--- |						|
       | |						+---| 											+---
       |							| |
       |					  	   k+----|								i	 +--
       +---------------							 	 +------------------------------+----

       Option 2: used
       do not remove the point between the slot 2 start point and slot 1 end point.
       */

      // SlotEndPtIndexTemp = SlotEndPtIndex - m;
      SlotEndPtIndexTemp                                                                       = SlotEndPtIndex;
      SlotStartPtIndexTemp                                                                     = SlotStartPtIndex;
      SlotIndex                                                                                = CurSlotNum;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotType                             = SlotType;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotStartIndex                       = SlotStartPtIndex;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotCalDisCarToObj1                  = SlotCalDisCarToObj1;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotCalDisCarToObj2                  = SlotCalDisCarToObj2;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].DisCarToObj1ByPassingSlot            = DisCarToObj1ByPassingSlot;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].DisCarToObj2ByPassingSlot            = DisCarToObj2ByPassingSlot;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotEndIndex                         = SlotEndPtIndexTemp;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotDepthDetected1                   = SlotDepthDetected1;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotDepthDetected2                   = SlotDepthDetected2;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotDepthDetected3                   = SlotDepthDetected3;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotLengthDetected1                  = SlotLenDetected1;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotLengthDetected2                  = SlotLenDetected2;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotLengthDetected3                  = SlotLenDetected3;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotLengthTotal                      = SlotLenTotal;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotDepthParallel                    = SlotDepth;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotDepth                            = SlotDepth;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].APASlotDetectionCompensateLengthHead = APASlotDetectionCompensateLengthHead;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].APASlotDetectionCompensateLengthTail = APASlotDetectionCompensateLengthTail;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].APAVehicleSpeedWhenSlotFound         = USSPar.APAVehicleSpeed;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].Obj1Width                            = Obj1Width;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].Obj2Width                            = Obj2Width;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].Obj1Type                             = Obj1Type;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].Obj2Type                             = Obj2Type;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].Obj1StartPtIndex                     = Obj1StartIndex;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].Obj1EndPtIndex                       = Obj1EndIndex;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].Obj2StartPtIndex                     = Obj2StartIndex;
      USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].Obj2EndPtIndex                       = Obj2EndIndex;

#ifdef APA_SLOT_SUPPORT_DEBUG1

      if ((Obj1Type != APA_SLOT_OBJ_TYPE_UNKNOWN) && (((SlotStartPtIndex) < (Obj1EndIndex)) || ((SlotStartPtIndex) > (Obj1StartIndex)))) {

        // Data error ??
        cSlotDebug = 1;
      }

#endif

      if (bSameSlotFound == FALSE) {
        USSPar.SlotPrevID++;
        if (USSPar.SlotPrevID == APA_SLOT_INVALID_SLOT_ID) {
          USSPar.SlotPrevID++;
        }
        USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].SlotID = USSPar.SlotPrevID;
      }
      USSPar.Slot[CurrentSlotIndex].SlotNum = CurSlotNum;

#if 0
			pSlot = &USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane;

			if(m > 0) {
				// remove the minor point
				k = 0;
				for(; n < pSlot->ObjPtCnt; n ++) { //modified by DSH 2012.2.14
					pSlot->ObjPt[k].x = pSlot->ObjPt[n].x;
					pSlot->ObjPt[k].y = pSlot->ObjPt[n].y;
					pSlot->DisFromCarToObj[k] = pSlot->DisFromCarToObj[n];
					pSlot->CarCenterPoint[k].x = pSlot->CarCenterPoint[n].x;
					pSlot->CarCenterPoint[k].y = pSlot->CarCenterPoint[n].y;
					pSlot->CarAng[k] = pSlot->CarAng[n];
					k ++;

				}
				pSlot->ObjPtCnt = k;  //modified by DSH 2012.2.14

			}
#endif

      // Readjust the slot start point pos and slot end point position. kjy add 2012 3 26
      // Start 2012 03 26

#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
      pSlot = &USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane;

      // slot end point position readjustment
      if ((DisCarToObj2ByPassingSlot != NO_OBJ_DISTANCE) &&
          (USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].CarPassTheSlotEndPtDistance >
           (APACal.APASlotMinPathAfterSlot - APA_SLOT_START_TO_COMPENSATE_SLOT_END_POS_DIS_TO_MIN_PATH_AFTER_SLOT)) &&
          (USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].bSlotHeadCompensated == FALSE)) {
        USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].bSlotHeadCompensated = TRUE;
        // Since the slot point has been compensated here, just resetup the system coordinate.

        USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].TrajectoryCalRequestType = APAParkProcSlotFoundTrajCalReqWithoutCaled;

        if (SlotDepth == NO_OBJ_DISTANCE) {
          CarToObjDisTemp = NO_OBJ_DISTANCE;
        } else {
          CarToObjDisTemp = SlotDepth + DisCarToObj2ByPassingSlot;
        }
        for (n = SlotEndPtIndexTemp - 1; n > SlotStartPtIndexTemp; n--) {
          if ( //(pSlot->DisFromCarToObj[n] == NO_OBJ_DISTANCE) ||
              (pSlot->DisFromCarToObj[n] >= CarToObjDisTemp)) {
            break;
          }
        }

        n++;

        CompensateDis = (APA_DISTANCE_CAL_FLOAT_TYPE)(APASlotDetectionCompensateLengthHead);
        k             = pSlot->ObjPtCnt - 1;
        for (; n < k; n++) {

          DeltaDis         = (CompensateDis)*MATH_SIN(pSlot->CarAng[n]);
          PtDeltaDisTemp.x = (APA_DISTANCE_TYPE)DeltaDis;
          DeltaDis         = (CompensateDis)*MATH_COS(pSlot->CarAng[n]);
          PtDeltaDisTemp.y = (APA_DISTANCE_TYPE)DeltaDis;

          pSlot->CarCenterPoint[n].x -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
          pSlot->CarCenterPoint[n].y += (APA_DISTANCE_TYPE)PtDeltaDisTemp.y;
          pSlot->ObjPt[n].x -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
          pSlot->ObjPt[n].y += (APA_DISTANCE_TYPE)PtDeltaDisTemp.y;
          pSlot->CarSpeed[t]         = ;

          if ((n >= SlotEndPtIndexTemp) && (pSlot->CarCenterPoint[n].y < pSlot->CarCenterPoint[n + 1].y)) {
            break;
          }
        }
      }

      // slot start point position readjustment
      if ((DisCarToObj1ByPassingSlot != NO_OBJ_DISTANCE) && (USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].bSlotTailCompensated == FALSE)) {
        USSPar.Slot[CurrentSlotIndex].SlotPar[SlotIndex].bSlotTailCompensated = TRUE;

        if (SlotDepth == NO_OBJ_DISTANCE) {
          CarToObjDisTemp = NO_OBJ_DISTANCE;
        } else {
          CarToObjDisTemp = SlotDepth + DisCarToObj1ByPassingSlot;
        }
        for (n = SlotStartPtIndexTemp; n < SlotEndPtIndexTemp; n++) {
          if ( //(pSlot->DisFromCarToObj[n] == NO_OBJ_DISTANCE) ||
              (pSlot->DisFromCarToObj[n] >= CarToObjDisTemp)) {
            break;
          }
        }

        if ((USSPar.Slot[CurrentSlotIndex].SlotNum == 0) ||
            ((USSPar.Slot[CurrentSlotIndex].SlotNum > 0) &&
             (n > USSPar.Slot[CurrentSlotIndex].SlotPar[USSPar.Slot[CurrentSlotIndex].SlotNum - 1].SlotEndIndex))) {
          CompensateDis = APASlotDetectionCompensateLengthTail;

          do {
            DeltaDis         = ((APA_DISTANCE_CAL_FLOAT_TYPE)(CompensateDis)) * MATH_SIN(pSlot->CarAng[n]);
            PtDeltaDisTemp.x = (APA_DISTANCE_TYPE)DeltaDis;
            DeltaDis         = ((APA_DISTANCE_CAL_FLOAT_TYPE)(CompensateDis)) * MATH_COS(pSlot->CarAng[n]);
            PtDeltaDisTemp.y = (APA_DISTANCE_TYPE)DeltaDis;

            if (USSPar.Slot[CurrentSlotIndex].SlotNum > 0) {
              DisTemp = pSlot->CarCenterPoint[n].y - (APA_DISTANCE_TYPE)PtDeltaDisTemp.y -
                        pSlot->CarCenterPoint[USSPar.Slot[CurrentSlotIndex].SlotPar[USSPar.Slot[CurrentSlotIndex].SlotNum - 1].SlotEndIndex].y;

              if (DisTemp < 0) {
                // Just use the previous slot end point as the new slot start point.
                CompensateDis += DisTemp;
                DeltaDis         = ((APA_DISTANCE_CAL_FLOAT_TYPE)(CompensateDis)) * MATH_SIN(pSlot->CarAng[n]);
                PtDeltaDisTemp.x = (APA_DISTANCE_TYPE)DeltaDis;
                DeltaDis         = ((APA_DISTANCE_CAL_FLOAT_TYPE)(CompensateDis)) * MATH_COS(pSlot->CarAng[n]);
                PtDeltaDisTemp.y = (APA_DISTANCE_TYPE)DeltaDis;

                pSlot->CarCenterPoint[n].x += (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
                pSlot->CarCenterPoint[n].y -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.y;

                pSlot->ObjPt[n].x += (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
                pSlot->ObjPt[n].y -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.y;
                pSlot->CarSpeed[t]         = ;

                break;
              }
            }

            pSlot->CarCenterPoint[n].x += (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
            pSlot->CarCenterPoint[n].y -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.y;

            pSlot->ObjPt[n].x += (APA_DISTANCE_TYPE)PtDeltaDisTemp.x;
            pSlot->ObjPt[n].y -= (APA_DISTANCE_TYPE)PtDeltaDisTemp.y;
            pSlot->CarSpeed[t]         = ;

            if ((n <= 0) || ((n < SlotStartPtIndexTemp) && (pSlot->CarCenterPoint[n].y > pSlot->CarCenterPoint[n - 1].y))) {
              break;
            }
            n--;
          } while (n >= 0);
        }
      }
      // End 2012 03 26

#endif

      USSPar.Slot[CurrentSlotIndex].SlotNum++;
      // bResult = TRUE;
    }
  }
  /// return bResult;
}

BOOLEAN APASlotProcSearchForTheSlotPointCanBeRemoved(APA_INDEX_TYPE StartPtIndex,
                                                     APA_INDEX_TYPE EndPtIndex,
                                                     APA_INDEX_TYPE *pPtToBeRemovedIndex,
                                                     APA_DISTANCE_TYPE *pDisFromCarToObj,
                                                     APACoordinateDataType *pCarCenterPt) {
  APA_INDEX_TYPE i, j, k, m;
  BOOLEAN bPtFound;
  APA_DISTANCE_TYPE L2;

  bPtFound = FALSE;
  j        = (StartPtIndex + EndPtIndex) / 2;

  for (i = j; i < (EndPtIndex - 1); i++) {
    if (j > (StartPtIndex + 2)) {
      j--;
    }
    for (k = 0; k < 2; k++) {
      if (k == 0) {
        m = i;
      } else {
        m = j;
      }

      if (pDisFromCarToObj[m] == NO_OBJ_DISTANCE) {
        if ((pDisFromCarToObj[m - 1] == NO_OBJ_DISTANCE)
            /*&& (pDisFromCarToObj[m + 1] == NO_OBJ_DISTANCE)*/) {
          // Ok, m can be removed.
          bPtFound               = TRUE;
          (*pPtToBeRemovedIndex) = m;
          break;
        }
      } else {
        if ((pDisFromCarToObj[m] >= pDisFromCarToObj[m - 1]) && (pDisFromCarToObj[m] >= pDisFromCarToObj[m + 1])) {
          // Ok, m can be removed.
          bPtFound               = TRUE;
          (*pPtToBeRemovedIndex) = m;
          break;
        } else if ((pDisFromCarToObj[m - 1] != NO_OBJ_DISTANCE) && (pDisFromCarToObj[m + 1] != NO_OBJ_DISTANCE)) {
          if (((pDisFromCarToObj[m] >= pDisFromCarToObj[m - 1]) && (pDisFromCarToObj[m] <= pDisFromCarToObj[m + 1])) ||
              ((pDisFromCarToObj[m] <= pDisFromCarToObj[m - 1]) && (pDisFromCarToObj[m] >= pDisFromCarToObj[m + 1]))) {
            // Ok, m can be removed.
            bPtFound               = TRUE;
            (*pPtToBeRemovedIndex) = m;
            break;
          }
        } else {
          // nothing to do?????
        }
// for corrcet logic mask the repeat statements 2014 08 21
#if 0				
				else if((pDisFromCarToObj[m - 1] != NO_OBJ_DISTANCE)
						&& (pDisFromCarToObj[m + 1] != NO_OBJ_DISTANCE)) {
					if(((pDisFromCarToObj[m] >= pDisFromCarToObj[m - 1])
									&& (pDisFromCarToObj[m] <= pDisFromCarToObj[m + 1]))
							|| ((pDisFromCarToObj[m] <= pDisFromCarToObj[m - 1])
									&& (pDisFromCarToObj[m] >= pDisFromCarToObj[m + 1]))) {
						// Ok, m can be removed.
						bPtFound = TRUE;
						(*pPtToBeRemovedIndex) = m;
						break;
					}
				}
#endif
      }
    }
    if (bPtFound == TRUE) {
      break;
    }
  }
  if ((bPtFound == FALSE) && ((StartPtIndex + 3) < EndPtIndex)) {
    j = 0;
    for (i = StartPtIndex + 4; i < EndPtIndex; i++) {
      if (pDisFromCarToObj[i] == NO_OBJ_DISTANCE) {
        k = j + 1;
        if ((j > 0) && (k < i)) {
          L2 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPt[i], pCarCenterPt[k]);
          if (L2 < APACal.APASlotPointCanBeRemovedInTheSlotMaxObjWidth) {
            // Ok, k can be removed.
            bPtFound               = TRUE;
            (*pPtToBeRemovedIndex) = k;
            break;
          }
        }
        j = i;
      }
    }
  }
  return bPtFound;
}

void APASlotProcDeletePointCheckSlotStartEndIndex(APA_ENUM_TYPE CurrentSlotIndex, APA_ENUM_TYPE DeletePointIndex) {

  APA_INDEX_TYPE n, j, m, k;

  n = USSPar.Slot[CurrentSlotIndex].SlotNum;
  j = 0;

  while (j < n) {

    k = USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex;
    m = USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex;

    if (k > DeletePointIndex) {
      // OK, just remove the mid of the first slot.
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex--;
    } else if (k == DeletePointIndex) {
      // The slot start point is removed.
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex = -1;  //20200923
      // if(k == 0) //20200923
      // { 
      //     USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex = 0;
      // }
      // else
      // {
      //   USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex = -1;
      // }//20200923
    } else {
    }

    if (m > DeletePointIndex) {
      // OK, just remove the mid of the first slot.
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex--;
    } else if (m == DeletePointIndex) {
      // The slot end point is removed.
      if (m > k) {
        USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex--;
      } else {
        USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex = -1;
      }
    }
    if (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1StartPtIndex >= DeletePointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1StartPtIndex--;
    }
    if (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1EndPtIndex > DeletePointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1EndPtIndex--;
    }
    if (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2StartPtIndex > DeletePointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2StartPtIndex--;
    }
    if (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2EndPtIndex >= DeletePointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2EndPtIndex--;
    }
    j++;
  }

  for (j = 0; j < n; j++) {
    if ((USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex < 0) || (USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex < 0) ||
        (USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex >= USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex)) {
      // remove the cur slot.
      m = j;
      for (k = j + 1; k < n; k++) {
        USSPar.Slot[CurrentSlotIndex].SlotPar[m] = USSPar.Slot[CurrentSlotIndex].SlotPar[k];
        m++;
      }
      n--;
      j--;
    }
  }

  USSPar.Slot[CurrentSlotIndex].SlotNum = n;
}

void APASlotProcRemoveUselessObjPtFromSlotBufferByStartAndEndIndex(UCHAR CurrentSlotIndex, APA_ENUM_TYPE StartIndex, APA_ENUM_TYPE EndIndex) {

  APASlotOutlineCoordinateDataType *pSlot;
  APA_DISTANCE_TYPE *pDisFromCarToObj;
  APACoordinateDataType *pCarCenterPointBuf;
  APACoordinateDataType *pObjPointBuf;
  APA_ANGLE_TYPE *pCarAngBuf;
  // APA_ENUM_TYPE *pObjTypeBuf;
  UCHAR *pCarSpeedBuf;

  APA_INDEX_TYPE i, j, k, m, n, h;
  APA_DISTANCE_TYPE Dis1;
  APA_INDEX_TYPE RemovedPtIndexBuf[10];
  BOOLEAN bPointFound;
  APA_DISTANCE_TYPE MaxTwoPtDisToBeRemoved;

  if ((EndIndex - StartIndex) < 2) {
    return;
  }

  pSlot              = &USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane;
  pCarAngBuf         = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.CarAng;
  pDisFromCarToObj   = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.DisFromCarToObj;
  pCarCenterPointBuf = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.CarCenterPoint;
  pObjPointBuf       = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.ObjPt;
  // pObjTypeBuf = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.ObjType;
  pCarSpeedBuf          = USSPar.Slot[CurrentSlotIndex].SlotOutline.Lane.CarSpeed;

  j = EndIndex;

  h = 0;
  m = j + 1;
  if (pSlot->ObjPtCnt > (APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM - 10)) {
    // the buffer is almost over flow.
    MaxTwoPtDisToBeRemoved = APACal.APASlotFPointCanBeRemovedContiguousPointMinDisP;
  } else {
    MaxTwoPtDisToBeRemoved = APACal.APASlotSamplePointCanBeRemovedMaxTwoPtDis;
  }

  for (j = EndIndex; j > StartIndex; j--) {
    i = j - 1;
    k = j + 1;

    if (h < 10) {
      if ((MATH_ABS(pDisFromCarToObj[i] - pDisFromCarToObj[k]) < APACal.APASlotFSamplePointUpdateSmallDeltaLen2) &&
          (((pDisFromCarToObj[i] >= pDisFromCarToObj[j]) && (pDisFromCarToObj[j] >= pDisFromCarToObj[k])) ||
           ((pDisFromCarToObj[i] <= pDisFromCarToObj[j]) && (pDisFromCarToObj[j] <= pDisFromCarToObj[k])))) {
        Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[m], pCarCenterPointBuf[i]);

        if (Dis1 < MaxTwoPtDisToBeRemoved) {
          // remove the point 'j'
          RemovedPtIndexBuf[h] = j;
          h++;
        } else {
          m = j;
        }
      } else {
        m = j;
      }
    } else {
      break;
    }
  }

  if (h > 0) {
    for (i = 0; i < h; i++) {
      APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotIndex, RemovedPtIndexBuf[i]);
    }
    m = RemovedPtIndexBuf[h - 1];
    for (n = m + 1; n < pSlot->ObjPtCnt; n++) {
      bPointFound = FALSE;
      for (i = 0; i < h; i++) {
        if (RemovedPtIndexBuf[i] == n) {
          bPointFound = TRUE;
          break;
        }
      }
      if (bPointFound == FALSE) {
        pCarCenterPointBuf[m].x = pCarCenterPointBuf[n].x;
        pCarCenterPointBuf[m].y = pCarCenterPointBuf[n].y;
        pDisFromCarToObj[m]     = pDisFromCarToObj[n];
        pObjPointBuf[m].x       = pObjPointBuf[n].x;
        pObjPointBuf[m].y       = pObjPointBuf[n].y;
        pCarAngBuf[m]           = pCarAngBuf[n];
        // pObjTypeBuf[m] = pObjTypeBuf[n];
        pSlot->bObjIsBigEnough[m] = pSlot->bObjIsBigEnough[n];
        pCarSpeedBuf[m]           = pCarSpeedBuf[n];
        m++;
      }
    }
    pSlot->ObjPtCnt = m;
  }
}

void APASlotProcRemoveUselessObjPtFromSlotBufferDetectedByFRSideSns(UCHAR CurrentSlotIndex, BOOLEAN SlotIsDetectedByRearSideSns) {

  APASlotInfoDataType *pSlotInfo;
  APA_DISTANCE_TYPE *pDisFromCarToObj;
  APACoordinateDataType *pCarCenterPointBuf;
  APACoordinateDataType *pObjPointBuf;
  APA_ANGLE_TYPE *pCarAngBuf;
  UCHAR *pCarSpeedBuf;
  APA_ENUM_TYPE *pSlotBufferObjCnt;
  UCHAR *pbObjIsBigEnough, *RearSideSnsDetectRemoveIndex;
  APA_DISTANCE_TYPE Dis1, Dis2, Dis3;
  APA_DISTANCE_TYPE PointCanBeRemovedMinDis, PointCanBeRemovedMinDis2;
  APA_DISTANCE_TYPE MinSnsDtdDis, SecondMinSnsDtdDis;
  APA_ENUM_TYPE NoObjDtPtNum, ObjPtOutOfTolNum, SlotBufferMaxObjPtCnt;
  APA_ENUM_TYPE SlopeOutOfTolPtPosTemp; // 0: at the start of the obj; 1: in the mid of the obj; 2: at the end of the obj;
  APA_INDEX_TYPE i, j, k, n, m, g, h, p, StartIndex;
  APA_INDEX_TYPE MinSnsDtdDisIndex, SecondMinSnsDtdDisIndex, SameObjPtCnt;
  APA_INDEX_TYPE NoObjDtPtStartIndex, NoObjDtPtEndIndex, PrevNoObjDtPtIndex;
  APA_INDEX_TYPE CheckLoopCnt;
  APA_INDEX_TYPE MaxSlotNumIndex;
  APA_INDEX_TYPE FirstNoObjPtIndex;
  APA_INDEX_TYPE SlopeOutOfTolPtIndex;
  APA_SLOT_PT_SLOPE_TYPE PtSlope1, PtSlope2;
  APA_SLOT_PT_SLOPE_CAL_TYPE Slope1;
  BOOLEAN bPointFound, bObjIsBigEnough;
  // variable CAL
  APA_DISTANCE_TYPE NoisePtStartCheckBkObjWidth;
  APA_SLOT_PT_SLOPE_TYPE AllowedMaxDeltaSlope;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedCheckMinNoObjWidth;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis;
  APA_SLOT_PT_SLOPE_TYPE NoisePtCanBeRemovedHeadOrTailMaxSlope;
  APA_SLOT_PT_SLOPE_TYPE NoisePtCanBeRemovedHeadOrTailMinSlope;
  APA_DISTANCE_TYPE NoisePtRegardedAsSameObjMaxNoObjWidth;
  APA_DISTANCE_TYPE NoisePtRegardedAsSameObjMaxDeltaObjDis;
  APA_DISTANCE_TYPE NoisePtRegardedAsSameObjMinObjWidth;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedSameObjTol;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedCheckNoiseWidth;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedCheckNoiseToObjWidth;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedMaxDis;
  APA_ENUM_TYPE NoisePtCanBeRemovedMinSameObjPtNum;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedMinObjWidth;
  APA_ENUM_TYPE NoisePtCanBeRemovedMaxNoiseWidthPercentage;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedCheckMaxObjWidth;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedCheckStartHeadWidth;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedRegardAsNoiseMinObjWidth;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedMinObjPtOutOfTolNum;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedMinNoObjPtTotalNum;
  APA_DISTANCE_TYPE NoisePtCanBeRemovedMinNoObjPtWitinNoiseNum;
  APA_DISTANCE_TYPE UpdateLongDeltaLen;
  APA_DISTANCE_TYPE UpdateSmallDeltaLen;
  APA_DISTANCE_TYPE UpdateSmallDeltaLen2;
  APA_DISTANCE_TYPE SlotPtCanBeRemovedMaxObjPtDeltaSlope;
  APA_DISTANCE_TYPE SlotPtCanBeRemovedMaxObjDis;
  APA_DISTANCE_TYPE SlotPtCanBeRemovedContiguousPointMinDisP2;

  pSlotInfo = &USSPar.Slot[CurrentSlotIndex];
  if (SlotIsDetectedByRearSideSns == FALSE) {
    pDisFromCarToObj      = pSlotInfo->SlotOutline.Lane.DisFromCarToObj;
    pCarCenterPointBuf    = pSlotInfo->SlotOutline.Lane.CarCenterPoint;
    pObjPointBuf          = pSlotInfo->SlotOutline.Lane.ObjPt;
    pCarAngBuf            = pSlotInfo->SlotOutline.Lane.CarAng;
    pSlotBufferObjCnt     = &(pSlotInfo->SlotOutline.Lane.ObjPtCnt);
    pbObjIsBigEnough      = pSlotInfo->SlotOutline.Lane.bObjIsBigEnough;
    pCarSpeedBuf          = pSlotInfo->SlotOutline.Lane.CarSpeed;
    SlotBufferMaxObjPtCnt = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM;
    if ((pSlotInfo->SlotNum == 0) ||
        ((pSlotInfo->SlotNum >= 1) && (pSlotInfo->SlotPar[0].CarPassTheSlotEndPtDistance < APACal.APASlotMinPathAfterSlot))) {
      StartIndex = 0;
    } else {
      // one or More than One slot found.
      MaxSlotNumIndex = pSlotInfo->SlotNum - 1;
      StartIndex      = pSlotInfo->SlotPar[MaxSlotNumIndex].SlotStartIndex;
    }
    NoisePtStartCheckBkObjWidth                 = APACal.APASlotFSamplePointNoisePtStartCheckBkObjWidth;
    AllowedMaxDeltaSlope                        = APACal.APASlotFSamplePointAllowedMaxDeltaSlope;
    NoisePtCanBeRemovedCheckMinNoObjWidth       = APACal.APASlotFSamplePointNoisePtCanBeRemovedCheckMinNoObjWidth;
    NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis = APACal.APASlotFSamplePointNoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis;
    NoisePtCanBeRemovedHeadOrTailMaxSlope       = APACal.APASlotFSamplePointNoisePtCanBeRemovedHeadOrTailMaxSlope;
    NoisePtCanBeRemovedHeadOrTailMinSlope       = APACal.APASlotFSamplePointNoisePtCanBeRemovedHeadOrTailMinSlope;
    NoisePtRegardedAsSameObjMaxNoObjWidth       = APACal.APASlotFSamplePointNoisePtRegardedAsSameObjMaxNoObjWidth;
    NoisePtRegardedAsSameObjMaxDeltaObjDis      = APACal.APASlotFSamplePointNoisePtRegardedAsSameObjMaxDeltaObjDis;
    NoisePtRegardedAsSameObjMinObjWidth         = APACal.APASlotFSamplePointNoisePtRegardedAsSameObjMinObjWidth;
    NoisePtCanBeRemovedSameObjTol               = APACal.APASlotFSamplePointNoisePtCanBeRemovedSameObjTol;
    NoisePtCanBeRemovedCheckNoiseWidth          = APACal.APASlotFSamplePointNoisePtCanBeRemovedCheckNoiseWidth;
    NoisePtCanBeRemovedCheckNoiseToObjWidth     = APACal.APASlotFSamplePointNoisePtCanBeRemovedCheckNoiseToObjWidth;
    NoisePtCanBeRemovedMaxDis                   = APACal.APASlotFSamplePointNoisePtCanBeRemovedMaxDis;
    NoisePtCanBeRemovedMinSameObjPtNum          = APACal.APASlotFSamplePointNoisePtCanBeRemovedMinSameObjPtNum;
    NoisePtCanBeRemovedMinObjWidth              = APACal.APASlotFSamplePointNoisePtCanBeRemovedMinObjWidth;
    NoisePtCanBeRemovedMaxNoiseWidthPercentage  = APACal.APASlotFSamplePointNoisePtCanBeRemovedMaxNoiseWidthPercentage;
    NoisePtCanBeRemovedCheckMaxObjWidth         = APACal.APASlotFSamplePointNoisePtCanBeRemovedCheckMaxObjWidth;
    NoisePtCanBeRemovedCheckStartHeadWidth      = APACal.APASlotFSamplePointNoisePtCanBeRemovedCheckStartHeadWidth;
    NoisePtCanBeRemovedRegardAsNoiseMinObjWidth = APACal.APASlotFSamplePointNoisePtCanBeRemovedRegardAsNoiseMinObjWidth;
    NoisePtCanBeRemovedMinObjPtOutOfTolNum      = APACal.APASlotFSamplePointNoisePtCanBeRemovedMinObjPtOutOfTolNum;
    NoisePtCanBeRemovedMinNoObjPtTotalNum       = APACal.APASlotFSamplePointNoisePtCanBeRemovedMinNoObjPtTotalNum;
    NoisePtCanBeRemovedMinNoObjPtWitinNoiseNum  = APACal.APASlotFSamplePointNoisePtCanBeRemovedMinNoObjPtWitinNoiseNum;
    UpdateLongDeltaLen                          = APACal.APASlotFSamplePointUpdateLongDeltaLen;
    UpdateSmallDeltaLen                         = APACal.APASlotFSamplePointUpdateSmallDeltaLen;
    UpdateSmallDeltaLen2                        = APACal.APASlotFSamplePointUpdateSmallDeltaLen2;
    SlotPtCanBeRemovedMaxObjPtDeltaSlope        = APACal.APASlotFSamplePointCanBeRemovedMaxObjPtDeltaSlope;
    SlotPtCanBeRemovedMaxObjDis                 = APACal.APASlotFSamplePointCanBeRemovedMaxObjDis;
    PointCanBeRemovedMinDis                     = APACal.APASlotFPointCanBeRemovedContiguousPointMinDisP;
    PointCanBeRemovedMinDis2                    = APACal.APASlotFPointCanBeRemovedContiguousPointMinDisP * 2;
    SlotPtCanBeRemovedContiguousPointMinDisP2   = APACal.APASlotFPointCanBeRemovedContiguousPointMinDisP2;

  } else {
    pDisFromCarToObj             = pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.DisFromCarToObjRSns;
    pCarCenterPointBuf           = pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarCenterPointRSns;
    pObjPointBuf                 = pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtRSns;
    pCarAngBuf                   = pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarAngRSns;
    pSlotBufferObjCnt            = &(pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtCntRSns);
    RearSideSnsDetectRemoveIndex = &(pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.RemoveIndex);
    pbObjIsBigEnough             = pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.bObjIsBigEnoughRSns;
    pCarSpeedBuf                 = pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.CarSpeedRSns;

    SlotBufferMaxObjPtCnt = APA_SLOT_SUPPORT_REAR_SIDE_MAX_SAMPLE_POINT_NUM;
    /*if((*pSlotBufferObjCnt) == 12) {
     pSlotBufferObjCnt  = &(pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor.ObjPtCntRSns);
     }*/
    StartIndex                                  = 0;
    NoisePtStartCheckBkObjWidth                 = APACal.APASlotRSamplePointNoisePtStartCheckBkObjWidth;
    AllowedMaxDeltaSlope                        = APACal.APASlotRSamplePointAllowedMaxDeltaSlope;
    NoisePtCanBeRemovedCheckMinNoObjWidth       = APACal.APASlotRSamplePointNoisePtCanBeRemovedCheckMinNoObjWidth;
    NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis = APACal.APASlotRSamplePointNoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis;
    NoisePtCanBeRemovedHeadOrTailMaxSlope       = APACal.APASlotRSamplePointNoisePtCanBeRemovedHeadOrTailMaxSlope;
    NoisePtCanBeRemovedHeadOrTailMinSlope       = APACal.APASlotRSamplePointNoisePtCanBeRemovedHeadOrTailMinSlope;
    NoisePtRegardedAsSameObjMaxNoObjWidth       = APACal.APASlotRSamplePointNoisePtRegardedAsSameObjMaxNoObjWidth;
    NoisePtRegardedAsSameObjMaxDeltaObjDis      = APACal.APASlotRSamplePointNoisePtRegardedAsSameObjMaxDeltaObjDis;
    NoisePtRegardedAsSameObjMinObjWidth         = APACal.APASlotRSamplePointNoisePtRegardedAsSameObjMinObjWidth;
    NoisePtCanBeRemovedSameObjTol               = APACal.APASlotRSamplePointNoisePtCanBeRemovedSameObjTol;
    NoisePtCanBeRemovedCheckNoiseWidth          = APACal.APASlotRSamplePointNoisePtCanBeRemovedCheckNoiseWidth;
    NoisePtCanBeRemovedCheckNoiseToObjWidth     = APACal.APASlotRSamplePointNoisePtCanBeRemovedCheckNoiseToObjWidth;
    NoisePtCanBeRemovedMaxDis                   = APACal.APASlotRSamplePointNoisePtCanBeRemovedMaxDis;
    NoisePtCanBeRemovedMinSameObjPtNum          = APACal.APASlotRSamplePointNoisePtCanBeRemovedMinSameObjPtNum;
    NoisePtCanBeRemovedMinObjWidth              = APACal.APASlotRSamplePointNoisePtCanBeRemovedMinObjWidth;
    NoisePtCanBeRemovedMaxNoiseWidthPercentage  = APACal.APASlotRSamplePointNoisePtCanBeRemovedMaxNoiseWidthPercentage;
    NoisePtCanBeRemovedCheckMaxObjWidth         = APACal.APASlotRSamplePointNoisePtCanBeRemovedCheckMaxObjWidth;
    NoisePtCanBeRemovedCheckStartHeadWidth      = APACal.APASlotRSamplePointNoisePtCanBeRemovedCheckStartHeadWidth;
    NoisePtCanBeRemovedRegardAsNoiseMinObjWidth = APACal.APASlotRSamplePointNoisePtCanBeRemovedRegardAsNoiseMinObjWidth;
    NoisePtCanBeRemovedMinObjPtOutOfTolNum      = APACal.APASlotRSamplePointNoisePtCanBeRemovedMinObjPtOutOfTolNum;
    NoisePtCanBeRemovedMinNoObjPtTotalNum       = APACal.APASlotRSamplePointNoisePtCanBeRemovedMinNoObjPtTotalNum;
    NoisePtCanBeRemovedMinNoObjPtWitinNoiseNum  = APACal.APASlotRSamplePointNoisePtCanBeRemovedMinNoObjPtWitinNoiseNum;
    UpdateLongDeltaLen                          = APACal.APASlotRSamplePointUpdateLongDeltaLen;
    UpdateSmallDeltaLen                         = APACal.APASlotRSamplePointUpdateSmallDeltaLen;
    UpdateSmallDeltaLen2                        = APACal.APASlotRSamplePointUpdateSmallDeltaLen2;
    SlotPtCanBeRemovedMaxObjPtDeltaSlope        = APACal.APASlotRSamplePointCanBeRemovedMaxObjPtDeltaSlope;
    SlotPtCanBeRemovedMaxObjDis                 = APACal.APASlotRSamplePointCanBeRemovedMaxObjDis;
    PointCanBeRemovedMinDis                     = APACal.APASlotRPointCanBeRemovedContiguousPointMinDisP;
    PointCanBeRemovedMinDis2                    = APACal.APASlotRPointCanBeRemovedContiguousPointMinDisP * 2;
    SlotPtCanBeRemovedContiguousPointMinDisP2   = APACal.APASlotRPointCanBeRemovedContiguousPointMinDisP2;
  }

  for (j = 0; j < 3; j++) {
    if ((*pSlotBufferObjCnt) > 2) {

      n = (*pSlotBufferObjCnt) - 1;
      i = n - 1;
      k = n - 2;

      Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[n], pCarCenterPointBuf[k]);

      Dis2 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[i], pCarCenterPointBuf[k]);
      if ((Dis1 < PointCanBeRemovedMinDis2) && (Dis2 < PointCanBeRemovedMinDis)) {
        Dis3 = MATH_ABS(pDisFromCarToObj[n] - pDisFromCarToObj[k]);
        if ((Dis3 < UpdateSmallDeltaLen) || ((Dis3 < UpdateSmallDeltaLen2) && (Dis2 < SlotPtCanBeRemovedContiguousPointMinDisP2))) {
          if (((pDisFromCarToObj[i] <= pDisFromCarToObj[k]) && (pDisFromCarToObj[i] >= pDisFromCarToObj[n])) ||
              ((pDisFromCarToObj[i] >= pDisFromCarToObj[k]) && (pDisFromCarToObj[i] <= pDisFromCarToObj[n])) ||
              ((pDisFromCarToObj[i] >= pDisFromCarToObj[k]) && (pDisFromCarToObj[i] >= pDisFromCarToObj[n]))) {
            // get rid of i;
            if (SlotIsDetectedByRearSideSns == FALSE) {
              APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotIndex, i);
            } else {
              if ((*RearSideSnsDetectRemoveIndex) > i)
                (*RearSideSnsDetectRemoveIndex)--;
            }
            pCarCenterPointBuf[i].x = pCarCenterPointBuf[n].x;
            pCarCenterPointBuf[i].y = pCarCenterPointBuf[n].y;
            pDisFromCarToObj[i]     = pDisFromCarToObj[n];
            pObjPointBuf[i].x       = pObjPointBuf[n].x;
            pObjPointBuf[i].y       = pObjPointBuf[n].y;
            pCarAngBuf[i]           = pCarAngBuf[n];
            // pObjTypeBuf[i] = pObjTypeBuf[n];
            pbObjIsBigEnough[i] = pbObjIsBigEnough[n];
            pCarSpeedBuf[i]     = pCarSpeedBuf[n];
            (*pSlotBufferObjCnt)--;

          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }

  for (j = 0; j < 3; j++) {
    if ((*pSlotBufferObjCnt) > 2) {

      n = (*pSlotBufferObjCnt) - 1;
      i = n - 1;
      k = n - 2;

      Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[n], pCarCenterPointBuf[k]);

      Dis2 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[i], pCarCenterPointBuf[k]);
      if ((Dis1 < PointCanBeRemovedMinDis2) && (Dis2 < PointCanBeRemovedMinDis)) {

        PtSlope1 = APASlotProcCalTwoObjPtSlope(pCarCenterPointBuf[n], pCarCenterPointBuf[i], pDisFromCarToObj[n], pDisFromCarToObj[i]);

        PtSlope2 = APASlotProcCalTwoObjPtSlope(pCarCenterPointBuf[i], pCarCenterPointBuf[k], pDisFromCarToObj[i], pDisFromCarToObj[k]);

        Dis1 = (APA_DISTANCE_TYPE)PtSlope1;
        Dis2 = (APA_DISTANCE_TYPE)PtSlope2;
        Dis1 -= Dis2;
        Dis1 = MATH_ABS(Dis1);
        if (Dis1 < SlotPtCanBeRemovedMaxObjPtDeltaSlope) {
          // get rid of i;
          if (SlotIsDetectedByRearSideSns == FALSE) {
            APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotIndex, i);
          } else {
            if ((*RearSideSnsDetectRemoveIndex) > i)
              (*RearSideSnsDetectRemoveIndex)--;
          }
          pCarCenterPointBuf[i].x = pCarCenterPointBuf[n].x;
          pCarCenterPointBuf[i].y = pCarCenterPointBuf[n].y;
          pDisFromCarToObj[i]     = pDisFromCarToObj[n];
          pObjPointBuf[i].x       = pObjPointBuf[n].x;
          pObjPointBuf[i].y       = pObjPointBuf[n].y;
          pCarAngBuf[i]           = pCarAngBuf[n];
          // pObjTypeBuf[i] = pObjTypeBuf[n];
          pbObjIsBigEnough[i] = pbObjIsBigEnough[n];
          pCarSpeedBuf[i]     = pCarSpeedBuf[n];
          (*pSlotBufferObjCnt)--;
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }

  if ((*pSlotBufferObjCnt) > 3) {

    // Remove the point which is noise.
    /*
     1.

     *  <-  point will be removed.


     ******* *******

     2.
     ground noise.


     *          *
     *       *     *
     *
     *           *
     *       *
     -  -	--
     */

    for (CheckLoopCnt = 0; CheckLoopCnt < 3; CheckLoopCnt++) {
      MinSnsDtdDisIndex       = (*pSlotBufferObjCnt) - 1;
      n                       = MinSnsDtdDisIndex;
      MinSnsDtdDis            = pDisFromCarToObj[MinSnsDtdDisIndex];
      SecondMinSnsDtdDisIndex = MinSnsDtdDisIndex;
      SecondMinSnsDtdDis      = MinSnsDtdDis;
      i                       = n - 1;

      NoObjDtPtNum        = 0;
      ObjPtOutOfTolNum    = 0;
      NoObjDtPtStartIndex = SlotBufferMaxObjPtCnt;
      NoObjDtPtEndIndex   = SlotBufferMaxObjPtCnt;
      PrevNoObjDtPtIndex  = SlotBufferMaxObjPtCnt;

      FirstNoObjPtIndex    = SlotBufferMaxObjPtCnt;
      SlopeOutOfTolPtIndex = SlotBufferMaxObjPtCnt;

      p = 0;
      for (; i >= 0; i--) {
        p++;
        if (p > 20) {
          break;
        }
        Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[n], pCarCenterPointBuf[i]);
        if (Dis1 > NoisePtCanBeRemovedCheckMaxObjWidth) {
          break;
        }

        bObjIsBigEnough = FALSE;
        if (pDisFromCarToObj[i] == NO_OBJ_DISTANCE) {
          if (PrevNoObjDtPtIndex < SlotBufferMaxObjPtCnt) {
            k = i + 1;
            if (pDisFromCarToObj[k] != NO_OBJ_DISTANCE) {
              Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[PrevNoObjDtPtIndex], pCarCenterPointBuf[k]);
              if (Dis1 > NoisePtCanBeRemovedRegardAsNoiseMinObjWidth) {
                // Obj detected.
                bObjIsBigEnough    = TRUE;
                PrevNoObjDtPtIndex = i;
              }
            }
          } else {
          }
          if (FirstNoObjPtIndex == SlotBufferMaxObjPtCnt) {
            FirstNoObjPtIndex = i;
          }
        } else {

          // Point not found yet.
          if (Dis1 > NoisePtStartCheckBkObjWidth) // 100cm
          {
            // Check the slot point

            SlopeOutOfTolPtPosTemp = 3; // default to no.
            m                      = i + 1;
            if (i > 0) {
              // i is at mid o
              h = i - 1;
              if (pDisFromCarToObj[m] == NO_OBJ_DISTANCE) {
                if (pDisFromCarToObj[h] == NO_OBJ_DISTANCE) {
                  // do not check.
                } else {
                  g = m + 1;
                  while (g < n) {
                    if (pDisFromCarToObj[g] != NO_OBJ_DISTANCE) {
                      break;
                    }
                    g++;
                  }
                  Dis3 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[m], pCarCenterPointBuf[g]);
                  if (Dis3 > NoisePtCanBeRemovedCheckMinNoObjWidth) {
                    // No obj width > 50cm
                    // check the point slope.
                    SlopeOutOfTolPtPosTemp = 2; // at the end of obj.
                  }
                }
              } else {
                if (pDisFromCarToObj[h] == NO_OBJ_DISTANCE) {
                  // do not check.
                  g = h - 1;
                  while (g > 0) {
                    if (pDisFromCarToObj[g] != NO_OBJ_DISTANCE) {
                      break;
                    }
                    g--;
                  }
                  if (g <= 0) {
                    // OK, confirmed.
                    SlopeOutOfTolPtPosTemp = 0; // at the start of obj.
                  } else {
                    Dis3 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[i], pCarCenterPointBuf[g]);
                    if (Dis3 > NoisePtCanBeRemovedCheckMinNoObjWidth) {
                      // No obj width > 50cm
                      // check the point slope.
                      SlopeOutOfTolPtPosTemp = 0; // at the start of obj.
                    }
                  }
                } else {
                  SlopeOutOfTolPtPosTemp = 1; // in the mid of obj.
                }
              }
            } else {
              // i is the first point.
              if (pDisFromCarToObj[m] == NO_OBJ_DISTANCE) {
                // unknown point.
              } else {
                SlopeOutOfTolPtPosTemp = 0; // at the start of obj.
              }
              h = i;
            }

            if (SlopeOutOfTolPtPosTemp < 3) {

              PtSlope1 = APASlotProcCalTwoObjPtSlope(pCarCenterPointBuf[i], pCarCenterPointBuf[h], pDisFromCarToObj[i], pDisFromCarToObj[h]);

              PtSlope2 = APASlotProcCalTwoObjPtSlope(pCarCenterPointBuf[m], pCarCenterPointBuf[i], pDisFromCarToObj[m], pDisFromCarToObj[i]);

              if (SlopeOutOfTolPtPosTemp == 0) {
                // at the start of obj
                if (PtSlope2 == APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT) {
                  // ?? use
                  g = m + 1;
                  if ((g < n) && (pDisFromCarToObj[g] != NO_OBJ_DISTANCE)) {
                    Dis1 = pDisFromCarToObj[m] - pDisFromCarToObj[i];
                    if ((Dis1 > NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis) &&
                        ((pDisFromCarToObj[g] - pDisFromCarToObj[i]) > NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis)) {
                      // Noise point confirmed.
                      /*
                       i
                       * <- noise

                       * g
                       * m

                       */
                      SlopeOutOfTolPtIndex = i;
                    }
                  }
                } else if ((PtSlope2 > NoisePtCanBeRemovedHeadOrTailMaxSlope) || (PtSlope2 < NoisePtCanBeRemovedHeadOrTailMinSlope)) {
                  // Ok, points can be removed.
                  // > 30deg or < -60deg.
                  /*
                   i
                   * <- noise         * m


                   * m          * <- noise
                   i

                   */
                  SlopeOutOfTolPtIndex = i;
                }
              } else if (SlopeOutOfTolPtPosTemp == 1) {
                // At mid of obj
                Dis1 = pDisFromCarToObj[m] - pDisFromCarToObj[i];
                if ((Dis1 > NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis) &&
                    ((pDisFromCarToObj[h] - pDisFromCarToObj[i]) > NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis)) {
                  if ((PtSlope1 == APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT) ||
                      (PtSlope2 == APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT)) {
                    // ?? use
                    // Noise point confirmed.
                    /*
                     i
                     * <- noise

                     * h
                     * m

                     */
                    SlopeOutOfTolPtIndex = i;
                  } else {

                    Slope1 = (APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope1 - (APA_SLOT_PT_SLOPE_CAL_TYPE)PtSlope2;

                    if ((Slope1 < -AllowedMaxDeltaSlope) || (Slope1 > AllowedMaxDeltaSlope)) {
                      /*
                       i      *
                       *   *
                       *
                       m
                       ***
                       h
                       */
                      SlopeOutOfTolPtIndex = i;
                    }
                  }
                } else {
                  // not a noise.
                }
              } else {
                // at the end of obj.
                if (PtSlope1 == APA_SLOT_OBJ_PT_SLOPE_ERROR_OBJ_WIDTH_TOO_SHORT) {
                  // ?? use
                  g = h - 1;
                  if (g >= 0) {
                    if (pDisFromCarToObj[g] != NO_OBJ_DISTANCE) {
                      Dis1 = pDisFromCarToObj[h] - pDisFromCarToObj[i];
                      if ((Dis1 > NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis) &&
                          ((pDisFromCarToObj[g] - pDisFromCarToObj[i]) > NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis)) {
                        // Noise point confirmed.
                        /*
                         i
                         * <- noise

                         * g
                         * h

                         */
                        SlopeOutOfTolPtIndex = i;
                      }
                    }
                  } else {

                    Dis1 = pDisFromCarToObj[h] - pDisFromCarToObj[i];
                    if (Dis1 > NoisePtCanBeRemovedHeadOrTailMaxDeltaObjDis) {
                      // Noise point confirmed.
                      /*
                       i
                       * <- noise


                       * h

                       */
                      SlopeOutOfTolPtIndex = i;
                    }
                  }
                } else if (((-PtSlope1) > NoisePtCanBeRemovedHeadOrTailMaxSlope) || ((-PtSlope1) < NoisePtCanBeRemovedHeadOrTailMinSlope)) {
                  // Ok, points can be removed.
                  // > 30deg or < -60deg.
                  /*
                   i
                   * <- noise         * m


                   * m          * <- noise
                   i

                   */
                  SlopeOutOfTolPtIndex = i;
                }
              }
              if (SlopeOutOfTolPtIndex != SlotBufferMaxObjPtCnt) {
                // remove it.
                if (SlotIsDetectedByRearSideSns == FALSE) {
                  APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotIndex, SlopeOutOfTolPtIndex);
                } else {
                  if ((*RearSideSnsDetectRemoveIndex) > SlopeOutOfTolPtIndex)
                    (*RearSideSnsDetectRemoveIndex)--;
                }
                g = SlopeOutOfTolPtIndex + 1;
                for (; g < (*pSlotBufferObjCnt); g++) {
                  j                       = g - 1;
                  pCarCenterPointBuf[j].x = pCarCenterPointBuf[g].x;
                  pCarCenterPointBuf[j].y = pCarCenterPointBuf[g].y;
                  pDisFromCarToObj[j]     = pDisFromCarToObj[g];
                  pObjPointBuf[j].x       = pObjPointBuf[g].x;
                  pObjPointBuf[j].y       = pObjPointBuf[g].y;
                  pCarAngBuf[j]           = pCarAngBuf[g];
                  // pObjTypeBuf[j] = pObjTypeBuf[g];
                  pbObjIsBigEnough[j] = pbObjIsBigEnough[g];
                  pCarSpeedBuf[j]     = pCarSpeedBuf[g];
                }
                (*pSlotBufferObjCnt)--;
                break;
              }
            }
          }
        }

        if (pDisFromCarToObj[i] <= MinSnsDtdDis) {
          MinSnsDtdDis      = pDisFromCarToObj[i];
          MinSnsDtdDisIndex = i;
        }

        ObjPtOutOfTolNum++;
        if (bObjIsBigEnough == TRUE) {
          NoObjDtPtNum        = 0;
          ObjPtOutOfTolNum    = 0;
          NoObjDtPtStartIndex = SlotBufferMaxObjPtCnt;
          NoObjDtPtEndIndex   = SlotBufferMaxObjPtCnt;
        } else {
          if (pDisFromCarToObj[i] == NO_OBJ_DISTANCE) {
            PrevNoObjDtPtIndex = i;
            if (NoObjDtPtEndIndex == SlotBufferMaxObjPtCnt) {
              NoObjDtPtEndIndex = i;
            } else {
              NoObjDtPtStartIndex = i;
            }
            NoObjDtPtNum++;
          }
        }
      }
      if ((SlopeOutOfTolPtIndex == SlotBufferMaxObjPtCnt) || ((*pSlotBufferObjCnt) < 4)) {
        break;
      }
    }

    if ((SlopeOutOfTolPtIndex == SlotBufferMaxObjPtCnt) && ((*pSlotBufferObjCnt) > 3) && (MinSnsDtdDis != NO_OBJ_DISTANCE)) {
      i++;

      // i = Obj width End point.
      // n = latest point.
      m = MinSnsDtdDisIndex + 1;
      if (((i < MinSnsDtdDisIndex) || (i == 0)) && (i >= 0) && (n > m)) {
        Dis1        = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[n], pCarCenterPointBuf[m]);
        Dis2        = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[MinSnsDtdDisIndex], pCarCenterPointBuf[i]);
        bPointFound = FALSE;
        Dis3        = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[MinSnsDtdDisIndex], pCarCenterPointBuf[0]);
        if (Dis3 < NoisePtCanBeRemovedCheckStartHeadWidth) {
          // may be a noise at head.
          /*

           * <- first point may be a noise.

           ******
           */
          /*

           * <- first piont may be a noise.

           *****
           *
           -----

           */
          bPointFound = TRUE;
        } else {

          k = NoObjDtPtStartIndex;
          if (k == SlotBufferMaxObjPtCnt) {
            k = NoObjDtPtEndIndex;
          }
          if (k < SlotBufferMaxObjPtCnt) {
            if (k < MinSnsDtdDisIndex) {
              j = k;
              while (k > 0) {
                k--;
                if (pDisFromCarToObj[k] != NO_OBJ_DISTANCE) {
                  break;
                }
              }
              if (pDisFromCarToObj[k] == NO_OBJ_DISTANCE) {
                /*

                 * <- first piont may be a noise.
                 *****
                 *
                 -----

                 */
                bPointFound = TRUE;
              } else {
                /*

                 * <- first piont may be a noise.
                 *            *****
                 *
                 -----

                 */
                Dis2 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[j], pCarCenterPointBuf[k + 1]);
                if (Dis2 > NoisePtCanBeRemovedCheckStartHeadWidth) {
                  bPointFound = TRUE;
                }
              }
            }
          }
        }

        if ((Dis1 > NoisePtCanBeRemovedCheckStartHeadWidth) && ((Dis2 > NoisePtCanBeRemovedCheckStartHeadWidth) || (bPointFound == TRUE))) {
          for (k = n - 1; k >= i; k--) {

            if ((pDisFromCarToObj[k] < SecondMinSnsDtdDis) && (pDisFromCarToObj[k] > MinSnsDtdDis)) {
              Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[k], pCarCenterPointBuf[MinSnsDtdDisIndex]);
              if (Dis1 > NoisePtCanBeRemovedCheckNoiseWidth) {
                SecondMinSnsDtdDis      = pDisFromCarToObj[k];
                SecondMinSnsDtdDisIndex = k;
              }
            }
          }

          if ((SecondMinSnsDtdDis != NO_OBJ_DISTANCE) && ((SecondMinSnsDtdDis - MinSnsDtdDis) > NoisePtCanBeRemovedMaxDis)) {

            // search the start point.

            SameObjPtCnt = 0;
            j            = SecondMinSnsDtdDisIndex; // Obj width start point.
            for (g = SecondMinSnsDtdDisIndex; g >= i; g--) {
              if ((pDisFromCarToObj[g] >= SecondMinSnsDtdDis) && ((pDisFromCarToObj[g] - SecondMinSnsDtdDis) < NoisePtCanBeRemovedSameObjTol)) {
                SameObjPtCnt++;
                j = g;
              }
            }

            if ((bPointFound == TRUE) || (j < MinSnsDtdDisIndex) ||
                (((APA_DISTANCE_TYPE)(APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[j], pCarCenterPointBuf[MinSnsDtdDisIndex]))) <
                 NoisePtCanBeRemovedCheckNoiseToObjWidth)) {
              // OK,
              // search the end point
              bPointFound = FALSE;
              if ((FirstNoObjPtIndex < SlotBufferMaxObjPtCnt) && (FirstNoObjPtIndex > MinSnsDtdDisIndex)) {
                g = FirstNoObjPtIndex;
                while (g > MinSnsDtdDisIndex) {
                  g--;
                  if (pDisFromCarToObj[g] != NO_OBJ_DISTANCE) {
                    break;
                  }
                }
                /*

                 * <- end piont may be a noise.
                 *****
                 *
                 -----

                 */

                g++;

                Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[g], pCarCenterPointBuf[FirstNoObjPtIndex]);
                if (Dis1 > NoisePtCanBeRemovedCheckStartHeadWidth) {
                  bPointFound = TRUE;
                }
              }

              h = SecondMinSnsDtdDisIndex; // Obj width end poiont
              for (g = h; g <= n; g++) {
                if ((pDisFromCarToObj[g] >= SecondMinSnsDtdDis) && ((pDisFromCarToObj[g] - SecondMinSnsDtdDis) < NoisePtCanBeRemovedSameObjTol)) {
                  if (g != SecondMinSnsDtdDisIndex) {
                    SameObjPtCnt++;
                  }
                  h = g;
                }
              }

              if (((h > MinSnsDtdDisIndex) || (bPointFound == TRUE) ||
                   (((APA_DISTANCE_TYPE)(APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[h], pCarCenterPointBuf[MinSnsDtdDisIndex]))) <
                    NoisePtCanBeRemovedCheckNoiseToObjWidth)) &&
                  (h > j) && (SameObjPtCnt >= NoisePtCanBeRemovedMinSameObjPtNum)) {
                // At least two points.
                // check obj width
                Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[h], pCarCenterPointBuf[j]);
                if (Dis1 > NoisePtCanBeRemovedMinObjWidth) {
                  // Ok, Obj is wide enough.
                  m    = MinSnsDtdDisIndex + 1;
                  Dis2 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[m], pCarCenterPointBuf[MinSnsDtdDisIndex]);
                  Dis2 *= 100;
                  Dis2 = Dis2 / Dis1;
                  m    = (APA_ENUM_TYPE)Dis2;
                  if ((m <= NoisePtCanBeRemovedMaxNoiseWidthPercentage) && (MinSnsDtdDisIndex >= 0)) {
                    // OK, Noise width < 25%.
                    // Can be removed.
                    // delete MinSnsDtdDisIndex
                    if (SlotIsDetectedByRearSideSns == FALSE) {
                      APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotIndex, MinSnsDtdDisIndex);
                    } else {
                      if ((*RearSideSnsDetectRemoveIndex) > MinSnsDtdDisIndex)
                        (*RearSideSnsDetectRemoveIndex)--;
                    }
                    i = MinSnsDtdDisIndex + 1;
                    for (; i < (*pSlotBufferObjCnt); i++) {
                      j                       = i - 1;
                      pCarCenterPointBuf[j].x = pCarCenterPointBuf[i].x;
                      pCarCenterPointBuf[j].y = pCarCenterPointBuf[i].y;
                      pDisFromCarToObj[j]     = pDisFromCarToObj[i];
                      pObjPointBuf[j].x       = pObjPointBuf[i].x;
                      pObjPointBuf[j].y       = pObjPointBuf[i].y;
                      pCarAngBuf[j]           = pCarAngBuf[i];
                      // pObjTypeBuf[j] = pObjTypeBuf[i];
                      pbObjIsBigEnough[j] = pbObjIsBigEnough[i];
                      pCarSpeedBuf[j]     = pCarSpeedBuf[i];
                    }

                    (*pSlotBufferObjCnt)--;
                  }
                }
              }
            }
          }
        }
      }
      if ((*pSlotBufferObjCnt) > n) {
        // No Obj point was removed.
        // check if the noise in the slot should be removed.
        if ((ObjPtOutOfTolNum >= NoisePtCanBeRemovedMinObjPtOutOfTolNum) && (NoObjDtPtEndIndex < SlotBufferMaxObjPtCnt) &&
            (NoObjDtPtStartIndex < SlotBufferMaxObjPtCnt) &&
            ((NoObjDtPtEndIndex - NoObjDtPtStartIndex) >= NoisePtCanBeRemovedMinNoObjPtWitinNoiseNum) &&
            (NoObjDtPtNum >= NoisePtCanBeRemovedMinNoObjPtTotalNum) && (NoObjDtPtEndIndex < ((*pSlotBufferObjCnt) - 5))) {
          // may be noise found.
          /*
           *** -> Noises
           ---       ----
           */

          // Check the following case:
          /*

           ****    *** -> Not regarded as a noise.
           --     -----
           */

          m               = NoObjDtPtStartIndex;
          k               = 0;
          bObjIsBigEnough = FALSE;
          while (m > 0) {
            m--;
            if (pDisFromCarToObj[m] == NO_OBJ_DISTANCE) {
              // keep searching.
              k++;
              if (k > 2) {
                break;
              }
            } else {
              i    = m + 1;
              g    = NoObjDtPtStartIndex + 1;
              Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[g], pCarCenterPointBuf[i]);
              if (Dis1 > NoisePtRegardedAsSameObjMaxNoObjWidth) {
                break;
              }
              if (pbObjIsBigEnough[m] != 0) {
                bObjIsBigEnough = TRUE;
              }
              break;
            }
          }
          if (bObjIsBigEnough == FALSE) {
            // OK, points between the NoObjDtPtStartIndex and NoObjDtPtEndIndex can be removed.
            m = NoObjDtPtStartIndex + 1;
            k = NoObjDtPtEndIndex;

            if (SlotIsDetectedByRearSideSns == FALSE) {
              for (i = m; i < k; i++) {
                APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotIndex, m); // here should set m as the removed point and not i.
              }
            } else {
              if ((*RearSideSnsDetectRemoveIndex) <= m) {
                // do nothing.
              } else if ((*RearSideSnsDetectRemoveIndex) <= k) {
                (*RearSideSnsDetectRemoveIndex) = m;
              } else {
                (*RearSideSnsDetectRemoveIndex) = m + (*RearSideSnsDetectRemoveIndex) - k;
              }
            }

            for (; k <= n; k++) {
              pCarCenterPointBuf[m].x = pCarCenterPointBuf[k].x;
              pCarCenterPointBuf[m].y = pCarCenterPointBuf[k].y;
              pDisFromCarToObj[m]     = pDisFromCarToObj[k];
              pObjPointBuf[m].x       = pObjPointBuf[k].x;
              pObjPointBuf[m].y       = pObjPointBuf[k].y;
              pCarAngBuf[m]           = pCarAngBuf[k];
              // pObjTypeBuf[m] = pObjTypeBuf[k];
              pbObjIsBigEnough[m] = pbObjIsBigEnough[k];
              pCarSpeedBuf[m]     = pCarSpeedBuf[k];
              m++;
            }
            (*pSlotBufferObjCnt) = m;
          }
        }
      }

      if (SlotIsDetectedByRearSideSns == FALSE) {
        /* check the following case:

         *
         * <- slot start index
         *
         * <- very close points can be removed.
         *
         *
         *
         *
         *
         * <- start index
         */

        MaxSlotNumIndex = pSlotInfo->SlotNum;
        if (MaxSlotNumIndex > 0) {
          MaxSlotNumIndex--;

          // 1. Check slot start point to 0.
          // Start check point.
          if (MaxSlotNumIndex > 0) {
            g = pSlotInfo->SlotPar[MaxSlotNumIndex - 1].SlotEndIndex;
          } else {
            g = 0;
          }

          g += 2;

          j = pSlotInfo->SlotPar[MaxSlotNumIndex].SlotStartIndex;
          n = j;

          if ((*pSlotBufferObjCnt) > (SlotBufferMaxObjPtCnt - 10)) {
            Dis2 = APACal.APASlotSamplePointCanBeRemovedObj1SearchBkDis / 2;
          } else {
            Dis2 = APACal.APASlotSamplePointCanBeRemovedObj1SearchBkDis;
          }
          while (j > g) {
            j--;
            Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[n], pCarCenterPointBuf[j]);
            if (Dis1 > Dis2) {
              break;
            }
          }

          APASlotProcRemoveUselessObjPtFromSlotBufferByStartAndEndIndex(CurrentSlotIndex, g, j);

          // 2. Check slot start point to Obj1 end point.
          // Start check point.
          g = pSlotInfo->SlotPar[MaxSlotNumIndex].SlotEndIndex - 2;
          j = pSlotInfo->SlotPar[MaxSlotNumIndex].SlotStartIndex + 1;
          n = (*pSlotBufferObjCnt) - 1;

          for (; g > j; g--) {
            Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[n], pCarCenterPointBuf[g]);
            if (Dis1 > APACal.APASlotSamplePointCanBeRemovedObj2SearchBkDis) {
              break;
            }
          }
          m = j;
          while (j < g) {
            j++;
            Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[j], pCarCenterPointBuf[m]);
            if (Dis1 > Dis2) {
              break;
            }
          }

          APASlotProcRemoveUselessObjPtFromSlotBufferByStartAndEndIndex(CurrentSlotIndex, j, g);
        }
      }
    }
  }

  g = 0;
  for (j = 0; j < 8; j++) {
    h = (*pSlotBufferObjCnt);
    if ((*pSlotBufferObjCnt) > 2) {

      // Searching 3 times.
      n = (*pSlotBufferObjCnt) - 1 - g; // n = pSlot->ObjPtCnt - 1 - j Current point
      k = n - 2;
      while (k >= StartIndex) {
        // Check if k is a valid obj, not a noise
        /*
         *** <- k.
         *    *
         */
        bPointFound = TRUE;
        if (pDisFromCarToObj[k] != NO_OBJ_DISTANCE) {
          m = k + 12;
          if (m > n) {
            m = n;
          }
          for (i = k + 1; i < m; i++) {
            Dis1 = (pDisFromCarToObj[i] - pDisFromCarToObj[k]);
            if (Dis1 > NoisePtRegardedAsSameObjMaxDeltaObjDis) {
              break;
            }
          }

          // i obj end point.
          // for correct loop change the variat from j to p 2014 08 21
          // j = k;
          p = k;

          m = k - 12;
          if (m < 0) {
            m = 0;
          }
          // while(j > m){
          while (p > m) {
            // j --;
            p--;
            // Dis1 = (pDisFromCarToObj[j] - pDisFromCarToObj[k]);
            Dis1 = (pDisFromCarToObj[p] - pDisFromCarToObj[k]);
            if (Dis1 > NoisePtRegardedAsSameObjMaxDeltaObjDis) {
              break;
            }
          }

          // j ++; // Obj start point.
          p++; // Obj start point.

          Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[p], pCarCenterPointBuf[i]);

          if (Dis1 < NoisePtRegardedAsSameObjMinObjWidth) {
            // Invalid obj width.
            // may be a noise.
            bPointFound = FALSE;
          }
        }

        if (bPointFound == TRUE) {
          Dis1 = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[n], pCarCenterPointBuf[k]);
          if (Dis1 < PointCanBeRemovedMinDis) {
            /*bObjIsBigEnough = APASlotProcCheckIfSlotObjIsBigEnough(pSlotInfo,
             FALSE,
             k,
             APASlotObjIsBigEnoughCheckType_Obj
             );

             if(bObjIsBigEnough == TRUE)*/
            {

              Dis2 = MATH_ABS(pDisFromCarToObj[n] - pDisFromCarToObj[k]);
              if (Dis2 < UpdateLongDeltaLen) {
                for (i = k + 1; i < n; i++) {
                  if ((pDisFromCarToObj[n] <= pDisFromCarToObj[i]) && (pDisFromCarToObj[k] <= pDisFromCarToObj[i])) {
                    // ok,
                  } else {
                    break;
                  }
                }
                if (i == n) {
                  m = k + 1;

                  if ((pDisFromCarToObj[m] - pDisFromCarToObj[k]) > SlotPtCanBeRemovedMaxObjDis) {
                    // Keep point m.
                    m = k + 2;
                  } else {
                    // Ok, get rid of all the points.
                  }
                  if (SlotIsDetectedByRearSideSns == FALSE) {
                    for (i = m; i < n; i++) {
                      APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotIndex, m); // here should set m as the removed point and not i.
                    }
                  } else {
                    if ((*RearSideSnsDetectRemoveIndex) <= m) {
                      // do nothing.
                    } else if ((*RearSideSnsDetectRemoveIndex) <= n) {
                      (*RearSideSnsDetectRemoveIndex) = m;
                    } else {
                      (*RearSideSnsDetectRemoveIndex) = m + (*RearSideSnsDetectRemoveIndex) - n;
                    }
                  }

                  for (; n < (*pSlotBufferObjCnt); n++) {
                    pCarCenterPointBuf[m].x = pCarCenterPointBuf[n].x;
                    pCarCenterPointBuf[m].y = pCarCenterPointBuf[n].y;
                    pDisFromCarToObj[m]     = pDisFromCarToObj[n];
                    pObjPointBuf[m].x       = pObjPointBuf[n].x;
                    pObjPointBuf[m].y       = pObjPointBuf[n].y;
                    pCarAngBuf[m]           = pCarAngBuf[n];
                    // pObjTypeBuf[m] = pObjTypeBuf[n];
                    pbObjIsBigEnough[m] = pbObjIsBigEnough[n];
                    pCarSpeedBuf[m]     = pCarSpeedBuf[n];
                    m++;
                  }
                  (*pSlotBufferObjCnt) = m;
                  break;
                } else {
                }
              }
            }
          } else {
            break;
          }
        }
        k--;
      }
    } else {
      break;
    }
    if (h == (*pSlotBufferObjCnt)) {
      if (g > 2) {
        // Loop for at least 4 times.
        break;
      }
      g++;
    } else {
    }
  }

  if (SlotIsDetectedByRearSideSns == TRUE) {
    if ((*pSlotBufferObjCnt) >= SlotBufferMaxObjPtCnt) {
      k = 0;
      for (n = 0 + 1; n < SlotBufferMaxObjPtCnt; n++) {
        pCarCenterPointBuf[k].x = pCarCenterPointBuf[n].x;
        pCarCenterPointBuf[k].y = pCarCenterPointBuf[n].y;
        pDisFromCarToObj[k]     = pDisFromCarToObj[n];
        pObjPointBuf[k].x       = pObjPointBuf[n].x;
        pObjPointBuf[k].y       = pObjPointBuf[n].y;
        pCarAngBuf[k]           = pCarAngBuf[n];
        // pObjTypeBuf[k] = pObjTypeBuf[n];
        pbObjIsBigEnough[k] = pbObjIsBigEnough[n];
        pCarSpeedBuf[k]     = pCarSpeedBuf[n];
        k++;
      }
      (*pSlotBufferObjCnt)--;
      if ((*RearSideSnsDetectRemoveIndex) > 0)
        (*RearSideSnsDetectRemoveIndex)--;
    }
  }
}

void APASlotProcRemoveUselessObjPtFromSlotBuffer(UCHAR CurrentSlotIndex, UCHAR OpsiteSideSlotIndex) {
  APASlotOutlineCoordinateDataType *pSlot;
  APA_DISTANCE_TYPE *pDisFromCarToObj;
  APACoordinateDataType *pCarCenterPointBuf;
  APACoordinateDataType *pObjPointBuf;
  UCHAR *pCarSpeedBuf;
  APA_ANGLE_TYPE *pCarAngBuf;
  // APA_ENUM_TYPE *pObjTypeBuf;
  APA_DISTANCE_CAL_INT_TYPE L, L2, Ycur, DeltaY2;
  // APA_DISTANCE_CAL_INT_TYPE PointCanBeRemovedMinDis, PointCanBeRemovedMinDis2, BorderPointCanBeRemovedMinDis;
  APA_DISTANCE_TYPE PointCanBeRemovedMinDis, PointCanBeRemovedMinDis2; //, BorderPointCanBeRemovedMinDis;
  APA_DISTANCE_CAL_FLOAT_TYPE fX1, fY1, fFactor;
  APA_ANGLE_CAL_FLOAT_TYPE fAng;
  APA_INDEX_TYPE i, j, k, n, m, g, h, p, StartIndex, DeletePointIndex;
  APA_INDEX_TYPE StartIndex2, MaxSlotNumIndex;
  APA_DISTANCE_TYPE Y1;
  BOOLEAN bPointFound, bObjIsBigEnough;

  APACoordinateDataCalFloatType Pt1, PtTemp;

  APA_DISTANCE_TYPE MinSnsDtdDis, SecondMinSnsDtdDis;
  APA_INDEX_TYPE MinSnsDtdDisIndex, SecondMinSnsDtdDisIndex, SameObjPtCnt;
  APA_DISTANCE_TYPE Dis1, Dis2, Dis3;

  APA_ENUM_TYPE NoObjDtPtNum, ObjPtOutOfTolNum;
  APA_INDEX_TYPE NoObjDtPtStartIndex, NoObjDtPtEndIndex, PrevNoObjDtPtIndex;

  APA_INDEX_TYPE FirstNoObjPtIndex;
  APA_INDEX_TYPE SlopeOutOfTolPtIndex;
  APA_ENUM_TYPE SlopeOutOfTolPtPosTemp; // 0: at the start of the obj; 1: in the mid of the obj; 2: at the end of the obj;
  APA_SLOT_PT_SLOPE_TYPE PtSlope1, PtSlope2;
  APA_SLOT_PT_SLOPE_CAL_TYPE Slope1;
  APA_INDEX_TYPE CheckLoopCnt;
  APASlotInfoDataType *pSlotInfo;
  APASlotInfoDataType *pOpsiteSideSlotInfo;

  pSlotInfo           = &USSPar.Slot[CurrentSlotIndex];
  pSlot               = &(pSlotInfo->SlotOutline.Lane);
  pOpsiteSideSlotInfo = &USSPar.Slot[OpsiteSideSlotIndex];
  pCarAngBuf          = pSlotInfo->SlotOutline.Lane.CarAng;
  pDisFromCarToObj    = pSlotInfo->SlotOutline.Lane.DisFromCarToObj;
  pCarCenterPointBuf  = pSlotInfo->SlotOutline.Lane.CarCenterPoint;
  pObjPointBuf        = pSlotInfo->SlotOutline.Lane.ObjPt;
  pCarSpeedBuf        = pSlotInfo->SlotOutline.Lane.CarSpeed;
  // pObjTypeBuf = pSlotInfo->SlotOutline.Lane.ObjType;

  i = pSlot->ObjPtCnt - 1;

  if (pSlotInfo->SlotNum > 0) {
    MaxSlotNumIndex = pSlotInfo->SlotNum - 1;
    L2              = 16000;//APACal.APASlotMaxDisBetweenStartEndPt;
    if (pSlotInfo->SlotPar[0].CarPassTheSlotEndPtDistance < APACal.APASlotDisToCarCheckCarDrvDis2) {  //2.2m
      Dis1 = APACal.APASlotMaxWidthOfObj1WithoutSlotConfirmed;  //6m
    } else {
      Dis1 = APACal.APASlotMaxWidthOfObj1WithSlotConfirmed;  //3m
    }
    // 1. check the min length with the current slot.
    k = pSlotInfo->SlotPar[0].SlotStartIndex;
    if (k > 6) {
      m = k - 6;
      j = pSlotInfo->SlotPar[0].Obj1EndPtIndex;
      while (j < m) {
        Dis2 = MATH_ABS(pCarCenterPointBuf[k].y - pCarCenterPointBuf[j].y);
        if (Dis2 < Dis1) {
          break;
        }
        Dis2 = MATH_ABS(pCarCenterPointBuf[k].x - pCarCenterPointBuf[j].x);
        if (Dis2 < Dis1) {
          break;
        }
        j++;
      }
      // dis bt index 0 ~ (j - 1) can be removed.
      if (j > m) {
        j = m;
      }
      if (j > 0) {
        j--;

        L = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[k], pCarCenterPointBuf[j]);

        if (L > Dis1) {
          L = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[i], pCarCenterPointBuf[j]);
          if (L < L2) {
            L2 = L;
          }
        }
      }
    }
  } else {
    L2              = APACal.APASlotMaxDisBetweenStartEndPtWithObj1Invalid;  //16m
    MaxSlotNumIndex = 0;
  }

  // 2. check the min length with the opsite side slot.
  if (pOpsiteSideSlotInfo->SlotNum > 0) {
    // Opsite side slot exist
    m    = pOpsiteSideSlotInfo->SlotPar[0].SlotStartIndex;
    n    = pOpsiteSideSlotInfo->SlotPar[0].SlotEndIndex;
    Dis2 = pOpsiteSideSlotInfo->SlotOutline.Lane.ObjPt[m].y +
           (pOpsiteSideSlotInfo->SlotOutline.Lane.ObjPt[n].y - pOpsiteSideSlotInfo->SlotOutline.Lane.ObjPt[m].y) / 2;
    for (m = 0; m < i; m++) {
      if (pObjPointBuf[m].y > Dis2) {
        break;
      }
    }
    m--;
    if (m > 0) {
      // There are points can be removed
      L = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[i], pCarCenterPointBuf[m]);
      if ((L > L2) && (L < ((APA_DISTANCE_CAL_INT_TYPE)APACal.APASlotMaxDisBetweenStartEndPt))) {
        L2 = L;
      }
    } else {
      // remain the curent points.
      L2 = APACal.APASlotMaxDisBetweenStartEndPt;
    }
  } else {
    // Just use the current slot check result.
  }

  h = 0;
  if (pSlot->ObjPtCnt > 1) {
    Ycur = pCarCenterPointBuf[i].y;

    for (; h < pSlot->ObjPtCnt; h++) {
      DeltaY2 = pCarCenterPointBuf[h].y;
      DeltaY2 = Ycur - DeltaY2;
      if (DeltaY2 < L2) {
        fAng = MATH_FABS(pCarAngBuf[i] - pCarAngBuf[h]);
        if (fAng < APACal.APASlotMaxDeltaCarAngBetStartEndPt) {  //80deg
          L = APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[i], pCarCenterPointBuf[h]);
          if (L < L2) {
            break;
          } else {
            // Keep searching
          }
        } else {
          // Keep searching
        }

      } else {
        // Keep searching
      }
    }
    if (h == 0) {
      m = pSlot->ObjPtCnt - 6;
      L = APACal.APASlotMaxDisBetweenToCheckCarTurningTheRoad;
      while (m > 0) {
        m--;
        DeltaY2 = pCarCenterPointBuf[m].y;
        DeltaY2 = Ycur - DeltaY2;
        if (DeltaY2 > L) {
          break;
        }
        fAng = MATH_FABS(pCarAngBuf[i] - pCarAngBuf[m]);
        if (fAng > APACal.APASlotMaxDeltaCarAngForCheckingCarTurningTheRoad) { //13deg
          // car angle is beyound the limited.
          // deleted all the points.
          h = m;
          break;
        }
      }
    }
  }
  if (h > 0) {
    i = h;
    for (i = 0; i < h; i++) {
      APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotIndex, 0); // here should set 0 as the removed point and not i.
    }
    j = 0;
    for (i = h; i < pSlot->ObjPtCnt; i++) {
      pCarCenterPointBuf[j].x = pCarCenterPointBuf[i].x;
      pCarCenterPointBuf[j].y = pCarCenterPointBuf[i].y;
      pDisFromCarToObj[j]     = pDisFromCarToObj[i];
      pObjPointBuf[j].x       = pObjPointBuf[i].x;
      pObjPointBuf[j].y       = pObjPointBuf[i].y;
      pCarAngBuf[j]           = pCarAngBuf[i];
      // pObjTypeBuf[j] = pObjTypeBuf[i];
      pSlot->bObjIsBigEnough[j] = pSlot->bObjIsBigEnough[i];
      pCarSpeedBuf[j]        = pSlot->CarSpeed[i];
      j++;
    }

    pSlot->ObjPtCnt = j;
  }

  // Remove one point.

  if (pSlot->ObjPtCnt >= APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {

    n           = pSlotInfo->SlotNum;
    j           = 0;
    bPointFound = FALSE;
    while (j < n) {

      // 1. remove the first slot mid point. it is an useless point.
      m = pSlotInfo->SlotPar[j].SlotEndIndex;
      k = pSlotInfo->SlotPar[j].SlotStartIndex;

      if ((k + 2) < m) {
        // OK, just remove the mid of the first slot.
        // Search for the slot piont which is within the delta dis can be removed.
        bPointFound = APASlotProcSearchForTheSlotPointCanBeRemoved(k, m, &DeletePointIndex, pDisFromCarToObj, pCarCenterPointBuf);
        break;
      } else {
        i = j + 1;
        if (i < n) {
          // 2. remove the mid point between the first and second slot.
          g = pSlotInfo->SlotPar[i].SlotEndIndex;
          h = pSlotInfo->SlotPar[i].SlotStartIndex;

          if ((m + 3) < h) {
            // 2. remove the mid point between the first and second slot.
            bPointFound = APASlotProcSearchForTheSlotPointCanBeRemoved(m, h, &DeletePointIndex, pDisFromCarToObj, pCarCenterPointBuf);
            break;
          } else if ((h + 2) < g) {
            // 3. remove the second slot mid point. it is an useless point.
            bPointFound = APASlotProcSearchForTheSlotPointCanBeRemoved(h, g, &DeletePointIndex, pDisFromCarToObj, pCarCenterPointBuf);
            break;
          }
        }
      }
      j += 2;
    }

    if (bPointFound == FALSE) {
      // Remove the mid point.
      n = pSlotInfo->SlotNum;
      if (n == 0) {
        g = 0;
      } else {
        g = pSlotInfo->SlotPar[n - 1].SlotEndIndex;
      }
      bPointFound = APASlotProcSearchForTheSlotPointCanBeRemoved(g, (pSlot->ObjPtCnt - 1), &DeletePointIndex, pDisFromCarToObj, pCarCenterPointBuf);

      if (bPointFound == FALSE) {
        if ((n > 0) && (pSlotInfo->SlotPar[0].SlotStartIndex > 6)) {
          // remove the start point of the slot.
          DeletePointIndex = 0;
        } else {
          // remove the points between the first slot end point and  second slot start point
          m = 0;
          k = 1;
          for (; k < n; k++) {
            i = pSlotInfo->SlotPar[k].SlotStartIndex;
            j = pSlotInfo->SlotPar[m].SlotEndIndex;
            i -= j;
            if ((i) > 6) {
              // remove the mid point.
              DeletePointIndex = i / 2 + j;
              bPointFound      = TRUE;
              break;
            }
            k++;
            m++;
          }
          if (bPointFound == FALSE) {
            // remove the point in the slot.
            for (m = 0; m < n; m++) {
              j = pSlotInfo->SlotPar[m].SlotStartIndex;
              i = pSlotInfo->SlotPar[m].SlotEndIndex;
              i -= j;
              if ((i) > 7) {
                // remove the mid point.
                DeletePointIndex = i / 2 + j;
                bPointFound      = TRUE;
                break;
              }
            }
          }
          if (bPointFound == FALSE) {
            // remove the point bt the nearst slot to cur point
            k = pSlot->ObjPtCnt - 2;
            for (i = g; i < k; i++) {
              if (pDisFromCarToObj[i] < APACal.APASlotMaxDisCarToObjByPassingSlotWhenObjHasOffset) {
                if ((pSlot->bObjIsBigEnough[i] & APA_SLOT_OBJ_IS_BIG_ENOUGH_CHECK_OBJ_MASK) == 0) {
                  // remove the obj.
                  DeletePointIndex = i;
                  bPointFound      = TRUE;
                  break;
                }
              }
            }
          }
          if (bPointFound == FALSE) {
            // remove the first point.
            DeletePointIndex = 0;
          }
        }
      }
    }

#ifdef APA_SLOT_PROC_DEBUG_SLOT_PT_REMOVE
    if (APASlotPTRemovedDisIndex < APA_SLOT_PROC_SLOT_PT_REMOVE_PT_NUM) {
      APASlotPTRemovedDis[APASlotPTRemovedDisIndex] = pDisFromCarToObj[DeletePointIndex];
      APASlotPTRemovedDisIndex++;
    }

#endif
    k = DeletePointIndex;
    APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotIndex, DeletePointIndex);
    for (n = DeletePointIndex + 1; n < APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; n++) {
      pCarCenterPointBuf[k].x = pCarCenterPointBuf[n].x;
      pCarCenterPointBuf[k].y = pCarCenterPointBuf[n].y;
      pDisFromCarToObj[k]     = pDisFromCarToObj[n];
      pObjPointBuf[k].x       = pObjPointBuf[n].x;
      pObjPointBuf[k].y       = pObjPointBuf[n].y;
      pCarAngBuf[k]           = pCarAngBuf[n];
      // pObjTypeBuf[k] = pObjTypeBuf[n];
      pSlot->bObjIsBigEnough[k] = pSlot->bObjIsBigEnough[n];
      pSlot->CarSpeed[k]        = pSlot->CarSpeed[n];
      k++;
    }

    pSlot->ObjPtCnt--;
  }
  APASlotProcRemoveUselessObjPtFromSlotBufferDetectedByFRSideSns(CurrentSlotIndex, FALSE);
}

void APASlotProcCheckAndRemoveSlot(APA_ENUM_TYPE APACalObjPtSnsIndex,
                                   APACarCoordinateDataType CarCenterPt,
                                   APA_INDEX_TYPE CurrentProcessSlotIndex,
                                   BOOLEAN bMainSlot) {
  APA_DISTANCE_CAL_INT_TYPE L, LTemp, Dis, CarPassTheSlotEndPtDistance;
  BOOLEAN bRemoveOneSlot, bCheckResetSysCoordinate;
  APASlotOutlineCoordinateDataType *pSlot;
  APA_INDEX_TYPE i, j, k, g, m, n, h;
  APA_DISTANCE_TYPE iDis2, iDis3;
  APASlotInfoDataType *pSlotInfo;

  pSlotInfo = &USSPar.Slot[CurrentProcessSlotIndex];
  pSlot     = &(pSlotInfo->SlotOutline.Lane);

  // if(pSlotInfo->RequestToRemoveSlotNum == 0)
  {
    APASlotProcCheckSlot(APACalObjPtSnsIndex, CurrentProcessSlotIndex);
  }
  
if (DebugRecheckCurb == 1)
{
  APASlotProcRecheckCurb(CurrentProcessSlotIndex);
}
  if ((pSlotInfo->SlotNum == 0) || (pSlotInfo->SlotPar[pSlotInfo->SlotNum - 1].CarPassTheSlotEndPtDistance > APACal.APASlotDisToCarCheckCarDrvDis2)) {
    pSlotInfo->SlotConfirmSeq = 0;
  }

  bCheckResetSysCoordinate = FALSE;
  // Check if the car has pass the slot for a long distance
  if ((CarCenterPt.Coordinate.y > APACal.APASlotCarCenterPtAllowedMaxY) ||   //22m
      (MATH_ABS(CarCenterPt.Coordinate.x) > APACal.APASlotCarCenterPtAllowedMaxX) ||   //20m
      (MATH_FABS(CarCenterPt.CarAng) > APACal.APASlotCarCenterPtAllowedMaxCarAng)) {   //80deg
    // Slot found, and the car should still within the max car pos range (< +32m)
    bCheckResetSysCoordinate = TRUE;
  } else if ((pSlotInfo->SlotNum == 0)
             /*&& (pSlotInfo->RequestToRemoveSlotNum == 0)*/) {
    // No Slot found.
    // check if the object coordinate has been exceed its max value
    bCheckResetSysCoordinate = TRUE;
  } else if (pSlotInfo->SlotNum == 0) {
    // pSlotInfo->RequestToRemoveSlotNum = 0;
    bCheckResetSysCoordinate = TRUE;
  } else {
    // Slot found.
    i = pSlotInfo->SlotNum;
    j = i - 1;
    while (i > 0) {
      i--;

      Dis = APATrajCalGetTwoPointDisInt(pSlot->CarCenterPoint[pSlotInfo->SlotPar[i].SlotStartIndex].x,
                                        pSlot->CarCenterPoint[pSlotInfo->SlotPar[i].SlotStartIndex].y,
                                        CarCenterPt.Coordinate.x,
                                        CarCenterPt.Coordinate.y);

      CarPassTheSlotEndPtDistance = APATrajCalGetTwoPointDisInt(pSlot->CarCenterPoint[pSlotInfo->SlotPar[i].SlotEndIndex].x,
                                                                pSlot->CarCenterPoint[pSlotInfo->SlotPar[i].SlotEndIndex].y,
                                                                CarCenterPt.Coordinate.x,
                                                                CarCenterPt.Coordinate.y);
      k                           = 0;
      if (i == j) {
        // The latest slot.
        if ((pSlotInfo->SlotPar[i].CarPassTheSlotEndPtDistance < APACal.APASlotDisToCarCheckCarDrvDis2) &&  //2.2m
            (CarPassTheSlotEndPtDistance > APACal.APASlotDisToCarCheckCarDrvDis2) &&  //2.2m
            (CarPassTheSlotEndPtDistance < APACal.APASlotDisToCarCheckCarDrvDis3) &&  //3.5m
            (pSlotInfo->SlotPar[i].DisCarToObj1ByPassingSlot != NO_OBJ_DISTANCE) &&
            (pSlotInfo->SlotPar[i].DisCarToObj2ByPassingSlot != NO_OBJ_DISTANCE) && 
            (pSlotInfo->SlotConfirmSeq == 0)) {
          iDis2 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[pSlot->ObjPtCnt - 1],
        		  pSlot->CarCenterPoint[pSlotInfo->SlotPar[i].SlotEndIndex]);
          if (iDis2 < APACal.APASlotDisToCarCheckCarDrvDis2) {
            // Check again the slot.
            // remain the current car pass slot dis
            pSlotInfo->SlotConfirmSeq = 1;

            k = 1;
          }
        }
      }
      if (k == 0) {
        pSlotInfo->SlotPar[i].CarPassTheSlotStartPtDistance = Dis;
        pSlotInfo->SlotPar[i].CarPassTheSlotEndPtDistance   = CarPassTheSlotEndPtDistance;
      }
    }
    bRemoveOneSlot = FALSE;

    // if(pSlotInfo->SlotPar[0].SlotType == APA_SLOT_TYPE_PARALLEL){ // delete by kjy 2012 11 03
    LTemp = APACal.APASlotMaxPathAfterSlot;  //16m
    //} else {
    //	LTemp = APACal.APASlotPMaxPathAfterSlot;
    //}
    CarPassTheSlotEndPtDistance = pSlotInfo->SlotPar[0].CarPassTheSlotEndPtDistance;
    if ((CarPassTheSlotEndPtDistance > LTemp) || (pSlotInfo->SlotPar[pSlotInfo->SlotNum - 1].SlotStartIndex >= pSlot->ObjPtCnt) ||
        (pSlotInfo->SlotPar[pSlotInfo->SlotNum - 1].SlotEndIndex >= pSlot->ObjPtCnt)) {   //��һ����λ����16m �� ���³�λ�������յ��indexС�����µ�
      // Treat as no object found.
      bRemoveOneSlot = TRUE;
    }

    // LTemp = pSlotInfo->SlotPar[1].SlotLengthTotal;
    if ((bRemoveOneSlot == TRUE)
				|| (MATH_FABS(CarCenterPt.CarAng) >= (80.0 * PI / 180.0))
				/*|| (pSlotInfo->RequestToRemoveSlotNum > 0)*/
				/*|| ((pSlotInfo->SlotNum == 2)
				 && (pSlotInfo->SlotPar[1].bSlotCalConfirmed == TRUE)
				 && (pSlotInfo->SlotPar[0].CarPassTheSlotEndPtDistance
				 > LTemp))*/
				/*|| ((USSPar.Slot.SlotPar[0].TrajectoryCalRequestType == APA_SLOT_TRAJECTORY_CAL_SEQUENCE_CAL_COMPLETE)
				 && (USSPar.Slot.SlotPar[0].bSlotCalConfirmed == FALSE)
				 && (USSPar.Slot.SlotNum > 0))*/) {
      // Remove the slot.

#if 0
			m = pSlotInfo->RequestToRemoveSlotNum;
			if(pSlotInfo->SlotNum >= 2) {
				n = m;
				if(m >= pSlotInfo->SlotNum) {
					// remove all the slots.
					m = pSlotInfo->SlotNum;
					n = m - 1;
				} else if(m < 2) {
					m = 1;
					n = 1;
				}
				k = pSlotInfo->SlotPar[m].SlotStartIndex;
				j = pSlotInfo->SlotPar[m - 1].SlotStartIndex + 2; // Start Pt to be removed.
			} else {
				m = 1;
				k = pSlotInfo->SlotPar[0].SlotEndIndex;
				j = pSlotInfo->SlotPar[0].SlotStartIndex;
			}
#else
      m = 1;
      k = pSlotInfo->SlotPar[0].SlotEndIndex;
      j = pSlotInfo->SlotPar[0].SlotStartIndex;
#endif

      // pSlotInfo->RequestToRemoveSlotNum = 0;

      g = k;
      // iDis2 = pSlot->DisFromCarToObj[k];
      j++;
      h = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
      while (k > j) {
        k--;
        iDis3 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[g], pSlot->CarCenterPoint[k]);

        if (iDis3 > APACal.APASLotObjTypeCheckMaxObjWidth) {   //5.5m
          break;
        }
        if (pSlot->DisFromCarToObj[k] == NO_OBJ_DISTANCE) {
          if (h == INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            h = k + 1;
          }
        } else {
          if (h != INVALID_APA_SLOT_BUFFER_VALUE_INDEX) {
            if (iDis3 > APACal.APASlotObjTypeCheckFlatShapeRegardedAsSmallObjMaxWidth1) {
              // big obj.
              iDis2 = APACal.APASlotObjTypeCheckFlatShapeRegardedAsNoObjDtMinWidth1; // 50cm.
            } else {
              // Small obj.
              iDis2 = APACal.APASlotObjTypeCheckFlatShapeRegardedAsNoObjDtMinWidth2; // 100cm.
            }
            iDis3 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[h], pSlot->CarCenterPoint[k + 1]);

            if (iDis3 > iDis2) {
              k = h - 1;
              break;
            }
            h = INVALID_APA_SLOT_BUFFER_VALUE_INDEX;
          }
        }
      }

#if 0
			while(k < g) {
				if(iDis2 >= pSlot->DisFromCarToObj[k]) {
					break;
				}
				k ++;
			}
#endif
      if (k > 0) {
        g = k;
        i = 0;
        for (; k < pSlot->ObjPtCnt; k++) {
          pSlot->CarCenterPoint[i].x = pSlot->CarCenterPoint[k].x;
          pSlot->CarCenterPoint[i].y = pSlot->CarCenterPoint[k].y;
          pSlot->DisFromCarToObj[i]  = pSlot->DisFromCarToObj[k];
          pSlot->ObjPt[i].x          = pSlot->ObjPt[k].x;
          pSlot->ObjPt[i].y          = pSlot->ObjPt[k].y;
          pSlot->CarAng[i]           = pSlot->CarAng[k];
          // pSlot->ObjType[i] = pSlot->ObjType[k];
          pSlot->bObjIsBigEnough[i] = pSlot->bObjIsBigEnough[k];
          pSlot->CarSpeed[i]         = pSlot->CarSpeed[k];
          i++;
        }

        pSlot->ObjPtCnt = i;
      } else {
        g = 0;
      }
      pSlotInfo->SlotNum -= m;
      i = pSlotInfo->SlotNum;
      k = 0;
      for (j = 0; j < i; j++) {
        k = j + 1;

        if (pSlotInfo->SlotPar[k].Obj1StartPtIndex > g) {
          pSlotInfo->SlotPar[k].Obj1StartPtIndex -= g;
        } else {
          pSlotInfo->SlotPar[k].Obj1StartPtIndex = 0;
        }

        if (pSlotInfo->SlotPar[k].Obj1EndPtIndex > g) {
          pSlotInfo->SlotPar[k].Obj1EndPtIndex -= g;
        } else {
          pSlotInfo->SlotPar[k].Obj1EndPtIndex = 0;
        }
        if (pSlotInfo->SlotPar[k].Obj2StartPtIndex > g) {
          pSlotInfo->SlotPar[k].Obj2StartPtIndex -= g;
        } else {
          pSlotInfo->SlotPar[k].Obj2StartPtIndex = 0;
        }

        if (pSlotInfo->SlotPar[k].Obj2EndPtIndex > g) {
          pSlotInfo->SlotPar[k].Obj2EndPtIndex -= g;
        } else {
          pSlotInfo->SlotPar[k].Obj2EndPtIndex = 0;
        }

        if (pSlotInfo->SlotPar[k].SlotStartIndex > g) {
          pSlotInfo->SlotPar[k].SlotStartIndex -= g;
        } else {
          // ?? data error
          // remove the cur slot
          pSlotInfo->SlotNum = j;
          break;
        }
        if (pSlotInfo->SlotPar[k].SlotEndIndex > g) {
          pSlotInfo->SlotPar[k].SlotEndIndex -= g;
        } else {
          // ?? data error
          // remove the cur slot
          pSlotInfo->SlotNum = j;
          break;
        }
        pSlotInfo->SlotPar[k].TrajectoryCalRequestType = APAParkProcSlotFoundTrajCalReqWithoutCaled;
        pSlotInfo->SlotPar[j]                          = pSlotInfo->SlotPar[k];
      }

      if ((pSlotInfo->SlotNum == 0) && (bMainSlot == TRUE)) {
        APASlotProcResetSlotInfo(CurrentProcessSlotIndex);
        APASlotProcResetSystemCoordinate();
      } else {
      }
    } else {
      if (USSPar.APAState == APA_STATE_STANDBY_ENABLE) {
        bCheckResetSysCoordinate = TRUE;
      }
    }
  }

  if (pSlot->ObjPtCnt < 5) {
    pSlotInfo->SlotNum = 0;
  }

  j = pSlotInfo->SlotNum;
  for (i = j; i < APA_SLOT_SUPPORT_MAX_SLOT_NUM; i++) {
    pSlotInfo->SlotPar[i].SlotEndIndex                                     = 0;
    pSlotInfo->SlotPar[i].SlotStartIndex                                   = 0;
    pSlotInfo->SlotPar[i].CarPassTheSlotStartPtDistance                    = 0;
    pSlotInfo->SlotPar[i].CarPassTheSlotEndPtDistance                      = 0;
    pSlotInfo->SlotPar[i].CarPassTheSlotDistanceTrajectoryCaled            = 0;
    pSlotInfo->SlotPar[i].CarPassTheSlotDistanceUsedToRecalTrajectoryIndex = 0;
    pSlotInfo->SlotPar[i].TrajectoryCalRequestType                         = APAParkProcSlotFoundTrajCalReqWithoutCaled;
#ifdef APA_SUPPORT_SLOT_POINT_COMPENSATE_ADJ
    pSlotInfo->SlotPar[i].bSlotHeadCompensated = FALSE;
    pSlotInfo->SlotPar[i].bSlotTailCompensated = FALSE;
#endif
    pSlotInfo->SlotPar[i].bSlotCurbHasBeenRechecked         = FALSE;
    pSlotInfo->SlotPar[i].bSlotCalConfirmed                 = FALSE;
    //pSlotInfo->SlotPar[i].bSlotCalConfirmedSpeakerHasChimed = FALSE;
    pSlotInfo->SlotPar[i].ParkProcCarEndPosition            = APA_PARKPROC_CAR_END_POSITION_MID_BETWEEN_OBJ1_AND_OBJ2;
  }

  if (bCheckResetSysCoordinate == TRUE) {
    if ((bMainSlot == TRUE) &&
        ((MATH_ABS(CarCenterPt.Coordinate.x) > APA_SUPPORT_MAX_DISTANCE / 2) || (CarCenterPt.Coordinate.y > APACal.APASlotCarCenterPtResetMaxY) ||
         (CarCenterPt.Coordinate.y < APACal.APASlotCarCenterPtResetMinY) ||
         (MATH_FABS(CarCenterPt.CarAng) > APACal.APASlotCarCenterPtResetMaxCarAng))) {

      APASlotProcResetSystemCoordinate();
    }
  }
}

void APASlotProcInsertPointCheckSlotStartEndIndex(APA_ENUM_TYPE CurrentSlotIndex, APA_ENUM_TYPE InsertPointIndex) {

  APA_INDEX_TYPE n, j, m, k;

  n = USSPar.Slot[CurrentSlotIndex].SlotNum;
  j = 0;

  while (j < n) {

    k = USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex;
    m = USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex;

    if (k > InsertPointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex++;
    } else if (k == InsertPointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex += 1;
    } else {
    }

    if (m > InsertPointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex++;
    } else if (m == InsertPointIndex) {
      if (m > k) {
        USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex++;
      } else {
        USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex += 1;
      }
    }

    if (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1StartPtIndex >= InsertPointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1StartPtIndex++;
    }
    if (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1EndPtIndex >= InsertPointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1EndPtIndex++;
    }
    if (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2StartPtIndex >= InsertPointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2StartPtIndex++;
    }
    if (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2EndPtIndex >= InsertPointIndex) {
      USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2EndPtIndex++;
    }
    j++;
  }

  for (j = 0; j < n; j++) {
    if ((USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex < 0) || (USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex < 0) ||
        (USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex >= USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex)) {
      // remove the cur slot.
      m = j;
      for (k = j + 1; k < n; k++) {
        USSPar.Slot[CurrentSlotIndex].SlotPar[m] = USSPar.Slot[CurrentSlotIndex].SlotPar[k];
        m++;
      }
      n--;
      j--;
    }
  }

  USSPar.Slot[CurrentSlotIndex].SlotNum = n;
}

BOOLEAN APASlotProcConvertRearSideSnsDtdObjPtIntoFrontSideSnsDtObjPt(APACarCoordinateDataCalFloatType CarCurPt,
                                                                     APACarCoordinateDataCalFloatType CarPrevPt,
                                                                     APACoordinateDataType ObjPt,
                                                                     APA_DISTANCE_TYPE CarToObjDis,
                                                                     APA_DISTANCE_CAL_FLOAT_TYPE CarPosYWithLine,
                                                                     APACarCoordinateDataCalFloatType *pCaledCarPos,
                                                                     APA_DISTANCE_TYPE *pCaledCarToObjDis) {

  APALineParameterABCType CarDrvLinePar;
  APACoordinateDataCalFloatType CircleCenterPt, ObjPtTemp, SnsPosPt, Ptc[2];
  APA_DISTANCE_CAL_FLOAT_TYPE Rc;
  APA_DISTANCE_CAL_FLOAT_TYPE X1, Y1, A, B, C, D, L1, L2, L3, L4;
  APA_DISTANCE_CAL_FLOAT_TYPE L1Sq, L2Sq, L3Sq, L4Sq;
  APA_DISTANCE_CAL_FLOAT_TYPE CarToObjDisTemp;
  APA_ANGLE_CAL_FLOAT_TYPE Ang1;
  APA_ENUM_TYPE CalResult;
  APACarCoordinateDataCalFloatType CarPosTemp;
  BOOLEAN bCarDrivingClockWise;

  CalResult = APATrajCalCarDriveTrajectoryByTwoCarPos(CarCurPt, CarPrevPt, &CarDrvLinePar, &CircleCenterPt, &Rc);
  if (CalResult == 0) {
    return FALSE;
  } else if (CalResult == 1) {
    // Line.
    (*pCaledCarToObjDis)       = CarToObjDis;
    pCaledCarPos->Coordinate.y = CarPosYWithLine;
    pCaledCarPos->CarAng       = CarCurPt.CarAng;
    if (CarDrvLinePar.LineType == APALineIsVertical) {
      pCaledCarPos->Coordinate.x = CarCurPt.Coordinate.x;
    } else if (CarDrvLinePar.A == 0) {
      // Data error.
      return FALSE;
    } else {
      pCaledCarPos->Coordinate.x = (CarPosYWithLine - CarDrvLinePar.C) / CarDrvLinePar.A;
    }
    return TRUE;
  } else {
    if (CarCurPt.Coordinate.x < CircleCenterPt.x) {
      // right circle.
      bCarDrivingClockWise = TRUE;
      L2                   = Rc - APACal.SnsPos[APA_FRS_SNS_INDEX].x;
      B                    = -L2;
    } else {
      // Left circle.
      // Cal the car to obj dis.
      bCarDrivingClockWise = FALSE;
      L2                   = Rc + APACal.SnsPos[APA_FRS_SNS_INDEX].x;
      B                    = L2;
    }
    ObjPtTemp.x = ObjPt.x;
    ObjPtTemp.y = ObjPt.y;
    X1          = ObjPtTemp.x - CircleCenterPt.x;
    Y1          = ObjPtTemp.y - CircleCenterPt.y;
    L1Sq        = X1 * X1 + Y1 * Y1; // square of
    L3          = APACal.SnsPos[APA_FRS_SNS_INDEX].y;
    B           = 2.0 * (B * APACal.SnsAngCos[APA_FRS_SNS_INDEX] + L3 * APACal.SnsAngSin[APA_FRS_SNS_INDEX]);
    L2Sq        = L2 * L2;
    L3Sq        = L3 * L3;
    C           = L2Sq + L3Sq - L1Sq;

    D = B * B - 4.0 * C;
    if (D < 0) {
      // no solution:
      return FALSE;
    }
    D               = MATH_SQRT(D);
    B               = -B;
    CarToObjDisTemp = (B + D) / 2.0;
    if ((CarToObjDisTemp < 0) || (MATH_FABS(CarToObjDisTemp - CarToObjDis) > 1000) || (CarToObjDisTemp > APA_SLOT_SENSOR_HFOV_MAX_DT_DIS)) {
      CarToObjDisTemp = (B - D) / 2.0;
      if ((CarToObjDisTemp < 0) || (MATH_FABS(CarToObjDisTemp - CarToObjDis) > 1000) || (CarToObjDisTemp > APA_SLOT_SENSOR_HFOV_MAX_DT_DIS)) {
        return FALSE;
      }
    }
    L4Sq = L2Sq + L3Sq;
    L4   = MATH_SQRT(L4Sq);

    CalResult = APATrajCalCrossPointOfTwoCircles(CircleCenterPt, L4, ObjPtTemp, CarToObjDisTemp, Ptc);

    if (CalResult == 0) {
      return FALSE;
    } else if (CalResult == 2) {
      if (bCarDrivingClockWise == FALSE) {
        if (Ptc[0].y < Ptc[1].y) {
          Ptc[0] = Ptc[1];
        }
      } else {
        if (Ptc[0].y > Ptc[1].y) {
          Ptc[0] = Ptc[1];
        }
      }
    }
    // Ptc[0] // FRS sns pos point

    APATrajCalCarPosByCarCenterPtAndPtOnCarSideLine(Ptc[0], L4, L2, Rc, CircleCenterPt, 0, bCarDrivingClockWise, pCaledCarPos);
    (*pCaledCarToObjDis) = (APA_DISTANCE_TYPE)CarToObjDisTemp;
    return TRUE;
  }
  return FALSE;
}

BOOLEAN APASlotProcCheckIfThePointIsASlotStartEndPt(APA_INDEX_TYPE CurrentSlotIndex, APA_INDEX_TYPE CheckPtIndex) {

  APA_INDEX_TYPE n, j;

  n = USSPar.Slot[CurrentSlotIndex].SlotNum;
  j = 0;

  while (j < n) {

    if ((USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotStartIndex == CheckPtIndex) ||
        (USSPar.Slot[CurrentSlotIndex].SlotPar[j].SlotEndIndex == CheckPtIndex) ||
        (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1StartPtIndex == CheckPtIndex) ||
        (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj1EndPtIndex == CheckPtIndex) ||
        (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2StartPtIndex == CheckPtIndex) ||
        (USSPar.Slot[CurrentSlotIndex].SlotPar[j].Obj2EndPtIndex == CheckPtIndex)) {
      return TRUE;
    }
    j++;
  }

  return FALSE;
}

void APASlotProcCheckCurbAccodingSlotDataDetectectedByRearSideSensor(uchar CurrentSlotSideIndex, uchar APAFSnsIndex) {

  /*
   Issue to be double checked:
   When a slot is found for Obj1 and Obj2 edge point:
   this function may also insert the point at the start or end of the obj1 or obj2. which may cause the
   accuracy of the slot detection be affected.

   */

  APASlotInfoDataType *pSlotInfo;
  APASlotOutlineCoordinateDataType *pSlot;
  APASlotOutlineDtcdByRearSideSnsCoordinateDataType *pSlotDetectecByRearSideSns;
  APA_INDEX_TYPE i, j, k, m, n, p, q, t, InsertPtIndex, DeletedPtIndex[2], ConvertedPtCnt;
  APA_DISTANCE_TYPE *pDisFromCarToObj;
  APACoordinateDataType *pCarCenterPointBuf;
  APACoordinateDataType *pObjPointBuf;
  APA_ANGLE_TYPE *pCarAngBuf, DeltaCarAng;
  APA_ENUM_TYPE *pSlotBufferObjCnt;
  UCHAR *pObjIsBigEnough;
  APA_INDEX_TYPE CurbIndex[APA_SLOT_SUPPORT_REAR_SIDE_MAX_SAMPLE_POINT_NUM];
  APA_INDEX_TYPE RemoveIndex, CurrentObjPtIndex0, CurrentObjPtIndex1, CurrentObjPtIndex2;
  APA_INDEX_TYPE CurbPtCnt;
  APA_DISTANCE_TYPE CarDriveDis;
  APA_SLOT_PT_SLOPE_TYPE PtSlope1, PtSlope2, DeltaSlope;
  APA_DISTANCE_TYPE CarCenterPtY1, CarCenterPtY2, DeltaYBtwFAndRSns;
  BOOLEAN bPtSlopeOutOfTol, bCurbPtIsInvalid;
  APA_INDEX_TYPE RemoveIndexBk, APARSideSnsIndex;
  APA_DISTANCE_TYPE StartPtY, Y1, Y2;
  APA_CAL_FLOAT_TYPE dbTemp1, dbTemp2;
  APA_DISTANCE_TYPE MinCarToObjDis1, MinCarToObjDis2, Obj1Width, Obj2Width;
  APA_DISTANCE_TYPE DeltaCarToObj1Dis, DeltaCarToObj2Dis, DeltaCarToObjDis;
  APA_ENUM_TYPE CalResult, ObjType;
  BOOLEAN bObj1IsFlatObj, bObj2IsFlatObj, ObjIsBigEnough1, ObjIsBigEnough2;

  APACarCoordinateDataCalFloatType CarCurPt;
  APACarCoordinateDataCalFloatType CarPrevPt;
  APA_DISTANCE_CAL_FLOAT_TYPE CarPosYWithLine;
  APACarCoordinateDataCalFloatType CaledCarPos;
  APA_DISTANCE_TYPE CaledCarToObjDis;
  APACoordinateDataType CarPosTemp, ObjPtToBeConverted;

  pSlotInfo                  = &USSPar.Slot[CurrentSlotSideIndex];
  pSlot                      = &(pSlotInfo->SlotOutline.Lane);
  pSlotDetectecByRearSideSns = &(pSlotInfo->SlotOutlineRearSideSnsDetected.LaneDetectedByRearSideSensor);
  pDisFromCarToObj           = pSlotDetectecByRearSideSns->DisFromCarToObjRSns;
  pCarCenterPointBuf         = pSlotDetectecByRearSideSns->CarCenterPointRSns;
  pObjPointBuf               = pSlotDetectecByRearSideSns->ObjPtRSns;
  pCarAngBuf                 = pSlotDetectecByRearSideSns->CarAngRSns;
  pSlotBufferObjCnt          = &(pSlotDetectecByRearSideSns->ObjPtCntRSns);
  pObjIsBigEnough            = pSlotDetectecByRearSideSns->bObjIsBigEnoughRSns;

  RemoveIndex = pSlotDetectecByRearSideSns->RemoveIndex;

  if (((*pSlotBufferObjCnt) < 3) || (pSlot->ObjPtCnt < 3) || (pSlot->ObjPtCnt > (APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM - 3))) {
    pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum   = 0;
    pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;
    return;
  }

  // Check if the obj is big enough.
  for (m = RemoveIndex; m < (*pSlotBufferObjCnt); m++) {
    pObjIsBigEnough[m] = APASlotProcCheckIfSlotObjIsBigEnough(pSlotInfo, TRUE, m, APASlotObjIsBigEnoughCheckType_Curb);
  }
  CurbPtCnt          = 0;
  CurrentObjPtIndex0 = RemoveIndex;
  CurrentObjPtIndex2 = (*pSlotBufferObjCnt);
  CurrentObjPtIndex1 = CurrentObjPtIndex2 - 1;
  RemoveIndexBk      = RemoveIndex;
  for (i = RemoveIndex; i < CurrentObjPtIndex2; i++) {
    if (pObjIsBigEnough[i] == TRUE) {
      CurbIndex[CurbPtCnt] = i;
      CurbPtCnt++;
    } else {
      if (CurbPtCnt == 0) {
        CarDriveDis = (pCarCenterPointBuf[CurrentObjPtIndex1].y - pCarCenterPointBuf[i].y);
        if (CarDriveDis > APACal.APASlotRearSideSnsStartInsertObjPtToFrnSideSnsCarDrvDis) { // 2000 mm
          RemoveIndexBk = i;
        }
      } else {
        break;
      }
    }
  }

  if ((pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum > 0) &&
      ((RemoveIndex <= 0) || (pObjIsBigEnough[RemoveIndex - 1] == FALSE) ||
       (pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope > APACal.APASlotRearSideSnsCheckCurbSlopeMaxValue) ||
       (pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope < -APACal.APASlotRearSideSnsCheckCurbSlopeMaxValue))) {
    pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum   = 0;
    pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;
  }
  if (CurbPtCnt == 0) {
    // pSlotDetectecByRearSideSns->RemoveIndex = RemoveIndexBk;
    return;
  }

  CurrentObjPtIndex0 = CurbIndex[0];
  CurrentObjPtIndex2 = CurbIndex[CurbPtCnt - 1];
  CarDriveDis        = (pCarCenterPointBuf[CurrentObjPtIndex2].y - pCarCenterPointBuf[CurrentObjPtIndex0].y);
  if ((CarDriveDis > APACal.APASlotRearSideSnsStartInsertObjPtToFrnSideSnsCarDrvDis) ||
      ((pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum > 0) &&
       ((CarDriveDis > (APACal.APASlotRearSideSnsStartInsertObjPtToFrnSideSnsCarDrvDis / 4)) || (RemoveIndexBk < ((*pSlotBufferObjCnt) - 3)))) &&
          (pCarCenterPointBuf[CurrentObjPtIndex0].y > pSlot->CarCenterPoint[0].y)) { // 2000 mm
    if (APAFSnsIndex == APA_FRS_SNS_INDEX) {
      DeltaYBtwFAndRSns = APACal.SnsPos[APAFSnsIndex].y - APACal.SnsPos[APA_RRS_SNS_INDEX].y;
      APARSideSnsIndex  = APA_RRS_SNS_INDEX;
    } else if (APAFSnsIndex == APA_FLS_SNS_INDEX) {
      DeltaYBtwFAndRSns = APACal.SnsPos[APAFSnsIndex].y - APACal.SnsPos[APA_RLS_SNS_INDEX].y;
      APARSideSnsIndex  = APA_RLS_SNS_INDEX;
    } else {
      return;
    }

    CurrentObjPtIndex1 = CurbIndex[1];
    bPtSlopeOutOfTol   = FALSE;
    PtSlope1           = APASlotProcCalTwoObjPtSlope(pCarCenterPointBuf[CurrentObjPtIndex0],
                                           pCarCenterPointBuf[CurrentObjPtIndex1],
                                           pDisFromCarToObj[CurrentObjPtIndex0],
                                           pDisFromCarToObj[CurrentObjPtIndex1]);
    if ((PtSlope1 > APACal.APASlotRearSideSnsCheckCurbSlopeMaxValue) || (PtSlope1 < -APACal.APASlotRearSideSnsCheckCurbSlopeMaxValue)) {
      // The obj pt CurrentObjPtIndex0 is out of tol.
      bPtSlopeOutOfTol = TRUE;
      if (pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum == 0) {
        pSlotDetectecByRearSideSns->RemoveIndex = CurrentObjPtIndex1;
        return;
      } else {
        DeltaSlope = MATH_ABS(pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope - PtSlope1);
        if (DeltaSlope > APACal.APASlotRearSideSnsSlopPtSlopeTolerance) { // 3 deg tolerance
          // The obj pt CurrentObjPtIndex0 is out of tol.
          pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum   = 0;
          pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;
          pSlotDetectecByRearSideSns->RemoveIndex                                     = CurrentObjPtIndex1;
          return;
        } else {
          CurbPtCnt = 1;
        }
      }
    } else {
      if (pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum == 0) {
      } else {
        DeltaSlope = MATH_ABS(pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope - PtSlope1);
        if (DeltaSlope > APACal.APASlotRearSideSnsSlopPtSlopeTolerance) { // 3 deg tolerance
          // The obj pt CurrentObjPtIndex0 is out of tol.
          pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum   = 0;
          pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;
        } else {
        }
      }
    }
    pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = PtSlope1;
    for (i = 1; i < (CurbPtCnt - 1); i++) {
      CurrentObjPtIndex0 = CurbIndex[i];
      CurrentObjPtIndex1 = CurbIndex[i + 1];
      PtSlope2           = APASlotProcCalTwoObjPtSlope(pCarCenterPointBuf[CurrentObjPtIndex0],
                                             pCarCenterPointBuf[CurrentObjPtIndex1],
                                             pDisFromCarToObj[CurrentObjPtIndex0],
                                             pDisFromCarToObj[CurrentObjPtIndex1]);
      if ((PtSlope2 > APACal.APASlotRearSideSnsCheckCurbSlopeMaxValue) || (PtSlope2 < -APACal.APASlotRearSideSnsCheckCurbSlopeMaxValue)) {
        CurbPtCnt        = i + 1;
        bPtSlopeOutOfTol = TRUE;
        break;
      }
      DeltaSlope = MATH_ABS(PtSlope1 - PtSlope2);
      if (DeltaSlope > APACal.APASlotRearSideSnsSlopPtSlopeTolerance) { // 3 deg tolerance
        CurbPtCnt        = i + 1;
        bPtSlopeOutOfTol = TRUE;
        break;
      } else {
        PtSlope1 = PtSlope2;
      }
      pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = PtSlope2;
    }

    // Check if curb length is big enough ??
    // Already checked.
    if (pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum == 0) {
      Y1 = (APA_DISTANCE_TYPE)APASlotProcCalTwoPtApproximateDisInt(pCarCenterPointBuf[CurbIndex[0]], pCarCenterPointBuf[CurbIndex[CurbPtCnt - 1]]);

      if (Y1 < APACal.APASlotRearSideSnsCheckCurbMinValidCurbLength) {
        // Slot length is not big enough.
        if (bPtSlopeOutOfTol == TRUE) {
          pSlotDetectecByRearSideSns->RemoveIndex = CurrentObjPtIndex1;
        }
        return;
      }
    }
    // Check curb point is big enough.

    if ((CurbPtCnt + pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum) <
        APACal.APASlotRearSideSnsCheckCurbMinValidCurbPtNum) {
      pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum   = 0;
      pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;

      if (bPtSlopeOutOfTol == TRUE) {
        pSlotDetectecByRearSideSns->RemoveIndex = CurrentObjPtIndex1;
      }
      return;
    }

    bCurbPtIsInvalid = TRUE;
    InsertPtIndex    = 0;
    do {
      CurrentObjPtIndex0 = CurbIndex[InsertPtIndex];
      StartPtY           = pObjPointBuf[CurrentObjPtIndex0].y;

      dbTemp1 = pDisFromCarToObj[CurrentObjPtIndex0];
      dbTemp2 = MATH_FABS(MATH_TAN(APACal.SnsAng[APARSideSnsIndex])) + MATH_FABS(MATH_TAN(APACal.SnsAng[APAFSnsIndex]));
      dbTemp1 *= dbTemp2;
      dbTemp1 += DeltaYBtwFAndRSns;
      dbTemp1 *= MATH_COS(pCarAngBuf[CurrentObjPtIndex0]);
      CarCenterPtY1 = pCarCenterPointBuf[CurrentObjPtIndex0].y - dbTemp1;
      Y1            = CarCenterPtY1;
      CalResult     = 0;

      if (InsertPtIndex == 0) {
        i = pSlot->ObjPtCnt;
        j = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // Under Curb Pt Index
        k = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // Upper curb pt index
        m = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // under car pos index
        n = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // upper car pos index

        while (i > 0) {
          i--;
          if (pSlot->CarCenterPoint[i].y < CarCenterPtY1) {
            Y2 = (Y1 - pSlot->CarCenterPoint[i].y);
            if (Y2 > APA_SLOT_REAR_SIDE_SNS_DT_CURB_PT_FIT_CAR_DRV_PATH_MIN_DIS) {
              CalResult = 1;
              if (Y2 > APACal.APASlotRearSideSnsCheckCurbMaxAllowSearchBkDis) {
                CalResult = 2;
              }
            }
            if ((m == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) || (CalResult == 0)) {
              m = i;
            }
          } else {
            Y1 = pSlot->CarCenterPoint[i].y;
            n  = i;
          }
          if (j == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
            if (pSlot->DisFromCarToObj[i] != NO_OBJ_DISTANCE) {
              if (pSlot->ObjPt[i].y < StartPtY) {
                j = i;
              } else {
                k = i;
              }
            }
            if (CalResult > 1) {
              break;
            }
          } else if (CalResult > 0) {
            break;
          }
        }
      } else {
        // j = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // Under Curb Pt Index
        // k = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // Upper curb pt index
        // m = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // under car pos index
        // n = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // upper car pos index

        i = m;
        if (i > j) {
          i = j;
        }
        // j = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // Under Curb Pt Index
        k = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM; // Upper curb pt index
        while (i < pSlot->ObjPtCnt) {
          if (pSlot->CarCenterPoint[i].y < CarCenterPtY1) {
            Y2 = (CarCenterPtY1 - pSlot->CarCenterPoint[i].y);
            if (Y2 < APA_SLOT_REAR_SIDE_SNS_DT_CURB_PT_FIT_CAR_DRV_PATH_MIN_DIS) {
              if (m == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
                m  = i;
                Y1 = pSlot->CarCenterPoint[i].y;
              }
            } else {
              m  = i;
              Y1 = pSlot->CarCenterPoint[i].y;
            }
          } else {
            Y2 = (pSlot->CarCenterPoint[i].y - Y1);
            if (Y2 > APA_SLOT_REAR_SIDE_SNS_DT_CURB_PT_FIT_CAR_DRV_PATH_MIN_DIS) {
              if (n == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
                n = i;
              }
              CalResult = 1;
              if (Y2 > APACal.APASlotRearSideSnsCheckCurbMaxAllowSearchBkDis) {
                CalResult = 2;
              }
            } else {
              n = i;
            }
          }
          if (k == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
            if (pSlot->DisFromCarToObj[i] != NO_OBJ_DISTANCE) {
              if (pSlot->ObjPt[i].y < StartPtY) {
                j = i;
              } else {
                k = i;
              }
            }
            if (CalResult > 1) {
              break;
            }
          } else if (CalResult > 0) {
            break;
          }
          i++;
        }
      }

      if ((n == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) || (m == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) ||
          (MATH_FABS(pCarAngBuf[CurrentObjPtIndex0] - pSlot->CarAng[m]) > APACal.APASlotRearSideSnsCheckAsInvalidCurbPtMinDeltaCarAng)) {
        // data error or invalid car angle.
        pSlotDetectecByRearSideSns->RemoveIndex                                     = CurrentObjPtIndex1;
        pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum   = 0;
        pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;
        return;
      }

      if ((j != APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) && (k != APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM)) {
        // Both obj1 and obj 2 exist.
        if ((pSlot->DisFromCarToObj[j + 1] == NO_OBJ_DISTANCE) &&
            (APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[j + 1], pSlot->CarCenterPoint[k]) >
             APACal.APASlotRearSideSnsCheckCurbAsValidMinNoObjDisWidth)) {
          // Ok, regarded as valid insert point.
          bCurbPtIsInvalid = FALSE;
          break;
        } else {
          // do not insert the current point and search for next point.
        }

      } else {
        bCurbPtIsInvalid = FALSE;
        break;
      }
      InsertPtIndex++;
    } while (InsertPtIndex < CurbPtCnt);

    if ((bCurbPtIsInvalid == TRUE) || (k < 2)) {
      pSlotDetectecByRearSideSns->RemoveIndex                                     = CurrentObjPtIndex1;
      pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum   = 0;
      pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;
      return;
    }

    // check the min dis to obj1 and obj2.
    Obj2Width      = 0;
    bObj2IsFlatObj = FALSE;
    if (k == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
      // k upper point
      MinCarToObjDis2 = NO_OBJ_DISTANCE;
    } else {
      MinCarToObjDis2 = pSlot->DisFromCarToObj[k];
      Y1              = pSlot->CarCenterPoint[k].y;
      p               = k; // end dis pt.
      q               = k; // half dis pt.
      for (i = k + 1; i < pSlot->ObjPtCnt; i++) {
        if (MinCarToObjDis2 > pSlot->DisFromCarToObj[i]) {
          MinCarToObjDis2 = pSlot->DisFromCarToObj[i];
        }
        Y2 = (pSlot->CarCenterPoint[i].y - Y1);
        if (pSlot->DisFromCarToObj[i] != NO_OBJ_DISTANCE) {
          Obj2Width = Y2;
          if (Y2 < (APACal.APASlotRearSideSnsCheckCurbMaxAllowObj12SearchBkDis / 4)) {
            q = i;
          }
          p = i;
        }
        if (Y2 > APACal.APASlotRearSideSnsCheckCurbMaxAllowObj12SearchBkDis) {
          break;
        }
      }
      DeltaCarToObj2Dis = pDisFromCarToObj[CurbIndex[InsertPtIndex]] - MinCarToObjDis2;
      if (Obj2Width > (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth)) {
        // big obj.
        Y2 = MATH_ABS(pSlot->DisFromCarToObj[k] - pSlot->DisFromCarToObj[p]);
        if (Y2 < APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxDeltaDis) {
          // Ok. flat obj.
          bObj2IsFlatObj = TRUE;
        } else {
          if (q == k) {
            q++;
          }
          if ((p > q)) {
            // end point, mid point, start point exist.
            PtSlope1 =
                APASlotProcCalTwoObjPtSlope(pSlot->CarCenterPoint[p], pSlot->CarCenterPoint[q], pSlot->DisFromCarToObj[p], pSlot->DisFromCarToObj[q]);
            PtSlope2 =
                APASlotProcCalTwoObjPtSlope(pSlot->CarCenterPoint[q], pSlot->CarCenterPoint[k], pSlot->DisFromCarToObj[q], pSlot->DisFromCarToObj[k]);
            if ((PtSlope1 > APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope) ||
                (PtSlope1 < -APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope) ||
                (PtSlope2 > APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope) ||
                (PtSlope2 < -APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope)) {
              // Not a valid flat obj.
            } else {
              DeltaSlope = MATH_ABS(PtSlope1 - PtSlope2);
              if (DeltaSlope < APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxDeltaSlope) {
                // Ok. flat obj.
                bObj2IsFlatObj = TRUE;
              }
            }
          }
        }
      }
    }

    Obj1Width      = 0;
    bObj1IsFlatObj = FALSE;
    if (j == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
      // j under point
      // No obj pt detected at front apa sns
      MinCarToObjDis1 = NO_OBJ_DISTANCE;
    } else {

      MinCarToObjDis1 = pSlot->DisFromCarToObj[j];
      Y1              = pSlot->CarCenterPoint[j].y;
      p               = j; // end dis pt.
      q               = j; // half dis pt.
      for (i = j - 1; i > 0; i--) {
        if (MinCarToObjDis1 > pSlot->DisFromCarToObj[i]) {
          MinCarToObjDis1 = pSlot->DisFromCarToObj[i];
        }
        Y2 = (Y1 - pSlot->CarCenterPoint[i].y);
        if (pSlot->DisFromCarToObj[i] != NO_OBJ_DISTANCE) {
          Obj1Width = Y2;
          if (Y2 < (APACal.APASlotRearSideSnsCheckCurbMaxAllowObj12SearchBkDis / 4)) {
            q = i;
          }
          p = i;
        }
        if (Y2 > APACal.APASlotRearSideSnsCheckCurbMaxAllowObj12SearchBkDis) {
          break;
        }
      }
      DeltaCarToObj1Dis = pDisFromCarToObj[CurbIndex[InsertPtIndex]] - MinCarToObjDis1;
      if (Obj1Width > (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth)) {
        // big obj.
        Y2 = MATH_ABS(pSlot->DisFromCarToObj[j] - pSlot->DisFromCarToObj[p]);
        if (Y2 < APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxDeltaDis) {
          // Ok. flat obj.
          bObj1IsFlatObj = TRUE;
        } else {
          if (q == j) {
            q--;
          }
          if ((p < q)) {
            // end point, mid point, start point exist.
            PtSlope1 =
                APASlotProcCalTwoObjPtSlope(pSlot->CarCenterPoint[p], pSlot->CarCenterPoint[q], pSlot->DisFromCarToObj[p], pSlot->DisFromCarToObj[q]);
            PtSlope2 =
                APASlotProcCalTwoObjPtSlope(pSlot->CarCenterPoint[q], pSlot->CarCenterPoint[j], pSlot->DisFromCarToObj[q], pSlot->DisFromCarToObj[j]);
            if ((PtSlope1 > APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope) ||
                (PtSlope1 < -APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope) ||
                (PtSlope2 > APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope) ||
                (PtSlope2 < -APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope)) {
              // Not a valid flat obj.
            } else {
              DeltaSlope = MATH_ABS(PtSlope1 - PtSlope2);
              if (DeltaSlope < APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxDeltaSlope) {
                // Ok. flat obj.
                bObj1IsFlatObj = TRUE;
              }
            }
          }
        }
      }
    }

    bCurbPtIsInvalid = FALSE;
    ObjType          = 0; // 0: default small obj, 1: flat obj, 2: car. 3: very close high curb. 4: Normal curb.
    DeltaCarToObjDis = DeltaCarToObj1Dis;

    if (j == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
      // j under point, obj1
      // No obj pt detected at front apa sns
      // Just insert directly ??
      // Not insert, just wait for the obj2 is detected.

      if (k == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
        // k upper point, obj2
        CarDriveDis =
            (pCarCenterPointBuf[(pSlotDetectecByRearSideSns->ObjPtCntRSns) - 1].y - pCarCenterPointBuf[pSlotDetectecByRearSideSns->RemoveIndex].y);
        if (CarDriveDis > 8000) {
          // 8m.
          pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum = 0;
          pSlotDetectecByRearSideSns->RemoveIndex++;
        }
        return;
      } else {
        if (pDisFromCarToObj[CurbIndex[InsertPtIndex]] < APACal.APASlotRearSideSnsCheckCurbAsValidForHighCurbCarToObjDis1) {
          // Very close high curb.
          // regarded as valid.
          ObjType = 3;
        } else {
          DeltaCarToObjDis = DeltaCarToObj2Dis;
          if (Obj2Width < (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth)) {
            // Samll obj2. 80cm
          } else {
            if (bObj2IsFlatObj == FALSE) {
              ObjType = 2; // car
            } else {
              ObjType = 1; // flat obj.
            }
          }
        }
      }
    } else {
      // obj1
      if (pDisFromCarToObj[CurbIndex[InsertPtIndex]] < APACal.APASlotRearSideSnsCheckCurbAsValidForHighCurbCarToObjDis1) {
        // Very close high curb.
        // regarded as valid.
        ObjType = 3;
      } else {
        if (k != APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
          Y1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[j], pSlot->CarCenterPoint[k]);
          if (Y1 < APACal.APASlotRearSideSnsCheckCurbAsValidCurbMaxLength) {
            // May be a curb.
            if ((bObj1IsFlatObj == TRUE) && (bObj2IsFlatObj == TRUE)) {
              // curb confirmed ??
              ObjType = 1;
            } else {
              if (((bObj1IsFlatObj == TRUE) && (Obj2Width < (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth))) ||
                  ((bObj2IsFlatObj == TRUE) && (Obj1Width < (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth))) ||
                  ((Obj2Width < (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth)) &&
                   (Obj1Width < (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth)))) {

                PtSlope1 = APASlotProcCalTwoObjPtSlope(
                    pSlot->CarCenterPoint[j], pSlot->CarCenterPoint[k], pSlot->DisFromCarToObj[j], pSlot->DisFromCarToObj[k]);
                if ((PtSlope1 < APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope) &&
                    (PtSlope1 > -APACal.APASlotRearSideSnsCheckCurbRegardedAsFlatObjMaxSlope)) {
                  // Regarded as a curb.
                  ObjType = 1;
                }
              }
            }
          }
          if (ObjType == 0) {
            if (MATH_ABS(MinCarToObjDis1 - MinCarToObjDis2) > APACal.APASlotMinSlotDepth) {
              // may be a curb found.
              if (MinCarToObjDis1 < MinCarToObjDis2) {
                DeltaCarToObjDis = DeltaCarToObj2Dis;
              }
              ObjType = 1;
            }
          }
        }
        if (ObjType == 0) {
          if (Obj1Width < (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth)) {
            // Samll obj. 80cm
            if (k == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
              // DeltaCarToObjDis = DeltaCarToObj1Dis;
            } else {
              if (Obj2Width < (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth)) {
                // Samll obj2. 80cm
                // use the max delta car to obj dis.
                if (DeltaCarToObj1Dis < DeltaCarToObj2Dis) {
                  DeltaCarToObjDis = DeltaCarToObj2Dis;
                }
              } else {
                // big obj2.
                DeltaCarToObjDis = DeltaCarToObj2Dis;
                if (bObj2IsFlatObj == FALSE) {
                  // Car ??
                  ObjType = 2;
                } else {
                  // curb ??
                  ObjType = 1;
                }
              }
            }
          } else {
            // big obj1.
            if (bObj1IsFlatObj == FALSE) {
              // Car ??
              ObjType = 2;
              if (Obj2Width < (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth)) {
                // Samll obj2. 80cm
              } else {
                // big obj2.
                if (bObj2IsFlatObj == FALSE) {
                  // car obj2.
                  if (DeltaCarToObj1Dis < DeltaCarToObj2Dis) {
                    DeltaCarToObjDis = DeltaCarToObj2Dis;
                  }
                } else {
                }
              }
            } else {
              // curb ??
              ObjType = 1;
              if (Obj2Width < (APACal.APASlotRearSideSnsCheckCurbRegardedAsSmallObjWidth)) {
                // Samll obj2. 80cm
              } else {
                // big obj2.
                if (bObj2IsFlatObj == FALSE) {
                  // car obj2.
                  ObjType          = 2;
                  DeltaCarToObjDis = DeltaCarToObj2Dis;
                } else {
                  // Curb.
                  if (DeltaCarToObj1Dis < DeltaCarToObj2Dis) {
                    DeltaCarToObjDis = DeltaCarToObj2Dis;
                  }
                }
              }
            }
          }
        }
      }
    }

    if (ObjType == 0) {
      // small obj
      if ((DeltaCarToObjDis < APACal.APASlotRearSideSnsCheckCurbAsValidForSmallObjDeltaCarToObjDis1) ||
          (DeltaCarToObjDis > APACal.APASlotRearSideSnsCheckCurbAsValidForSmallObjDeltaCarToObjDis2)) {
        //  < 80cm or > 1.6m, Just insert the curb point.

      } else {
        // regarded as invalid point, do not insert.
        bCurbPtIsInvalid = TRUE;
      }
    } else if (ObjType == 1) {
      // Flat obj
      // curb ??

      if (((DeltaCarToObjDis > APACal.APASlotRearSideSnsCheckCurbAsValidForFlatObjDeltaCarToObjDis1) &&
           (DeltaCarToObjDis < APACal.APASlotRearSideSnsCheckCurbAsValidForFlatObjDeltaCarToObjDis2)) ||
          (DeltaCarToObjDis > APACal.APASlotRearSideSnsCheckCurbAsValidForFlatObjDeltaCarToObjDis3)) {
        // -20cm < delta dis < 80cm or > 1.6m, Just insert the curb point.
      } else {
        // regarded as invalid point, do not insert.
        bCurbPtIsInvalid = TRUE;
      }
    } else if (ObjType == 2) {
      // Car ??
      if ((DeltaCarToObjDis < APACal.APASlotRearSideSnsCheckCurbAsValidForCarDeltaCarToObjDis1) ||
          (DeltaCarToObjDis > APACal.APASlotRearSideSnsCheckCurbAsValidForCarDeltaCarToObjDis2)) {
        //  < -400cm or > 1.6m, Just insert the curb point.

      } else {
        // regarded as invalid point, do not insert.
        bCurbPtIsInvalid = TRUE;
      }
    } else {
      // high close curb.
    }

    pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum = 0;
    if (bCurbPtIsInvalid == FALSE) {
      // insert the curb point
      ConvertedPtCnt = 0;
      do {

        CarCurPt.CarAng        = pSlot->CarAng[n];
        CarCurPt.Coordinate.x  = pSlot->CarCenterPoint[n].x;
        CarCurPt.Coordinate.y  = pSlot->CarCenterPoint[n].y;
        CarPrevPt.CarAng       = pSlot->CarAng[m];
        CarPrevPt.Coordinate.x = pSlot->CarCenterPoint[m].x;
        CarPrevPt.Coordinate.y = pSlot->CarCenterPoint[m].y;
        p                      = CurbIndex[InsertPtIndex];
        CarPosYWithLine        = CarCenterPtY1;
        ObjPtToBeConverted     = pObjPointBuf[p];
        if (APASlotProcConvertRearSideSnsDtdObjPtIntoFrontSideSnsDtObjPt(
                CarCurPt, CarPrevPt, ObjPtToBeConverted, pDisFromCarToObj[p], CarPosYWithLine, &CaledCarPos, &CaledCarToObjDis) == FALSE) {
          // insert the point failed.
          bCurbPtIsInvalid = TRUE;
          break;
        }

        pSlotDetectecByRearSideSns->RemoveIndex = p + 1;

        if (CarCurPt.Coordinate.y > CaledCarPos.Coordinate.y) {
          for (p = n - 1; p > 0; p--) {
            if (pSlot->CarCenterPoint[p].y < CaledCarPos.Coordinate.y) {
              break;
            }
          }
          if (p < 0) {
            // data error ??.
            bCurbPtIsInvalid = TRUE;
            break;
          }
        } else {
          for (p = n + 1; p < pSlot->ObjPtCnt; p++) {
            if (pSlot->CarCenterPoint[p].y > CaledCarPos.Coordinate.y) {
              break;
            }
          }
          if (p >= pSlot->ObjPtCnt) {
            // data error ??.
            bCurbPtIsInvalid = TRUE;
            break;
          }
          p--;
        }

        // insert the point at the above of p.
        if (p >= k) {
          // stop insert the point.
          pSlotDetectecByRearSideSns->RemoveIndex = CurbIndex[InsertPtIndex] + 1;
          return;
        }
        if (p < j) {
          // Invalid. don't insert.
        } else {
          CurbIndex[ConvertedPtCnt] = p + 1;
          CarPosTemp.x              = CaledCarPos.Coordinate.x;
          CarPosTemp.y              = CaledCarPos.Coordinate.y;
          DeletedPtIndex[0]         = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM;
          DeletedPtIndex[1]         = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM;

          if ((p > 0) && (APASlotProcCheckIfThePointIsASlotStartEndPt(CurrentSlotSideIndex, p) == FALSE)) {
            if (pSlot->DisFromCarToObj[p] == NO_OBJ_DISTANCE) {
              q = p - 1;
              if (pSlot->DisFromCarToObj[q] != NO_OBJ_DISTANCE) {
                Y1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[p], CarPosTemp);
                // if(Y1 < APACal.APASlotFPointCanBeRemovedContiguousPointMinDisP)
                if (Y1 < 500) {
                  // Less than 50cm.
                  // remove the point p.
                  DeletedPtIndex[0] = p;
                }
              }
            } else if ((CaledCarToObjDis - pSlot->DisFromCarToObj[p]) < 400) {
              Y1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[p], CarPosTemp);
              if (Y1 < APACal.APASlotFPointCanBeRemovedContiguousPointMinDisP) {
                // Less than 70cm.
                // remove the point p.
                DeletedPtIndex[0] = p;
              }
            }
          }
          q = p + 1;
          if ((q < (pSlot->ObjPtCnt - 1)) && (APASlotProcCheckIfThePointIsASlotStartEndPt(CurrentSlotSideIndex, q) == FALSE)) {

            if (pSlot->DisFromCarToObj[q] == NO_OBJ_DISTANCE) {
              if (pSlot->DisFromCarToObj[q + 1] != NO_OBJ_DISTANCE) {
                Y1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[q + 1], CarPosTemp);
                // if(Y1 < APACal.APASlotFPointCanBeRemovedContiguousPointMinDisP)
                if (Y1 < 500) {
                  // Less than 50cm.
                  // remove the point q.
                  DeletedPtIndex[1] = q;
                }
              }
            } else if ((CaledCarToObjDis - pSlot->DisFromCarToObj[q]) < 400) {
              Y1 = APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[q], CarPosTemp);
              if (Y1 < APACal.APASlotFPointCanBeRemovedContiguousPointMinDisP) {
                // Less than 70cm.
                // remove the point q.
                DeletedPtIndex[1] = q;
              }
            }
          }
          if (DeletedPtIndex[0] == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
            if (DeletedPtIndex[1] == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
              // move a position to save current point.
              q = p + 1;
              APASlotProcInsertPointCheckSlotStartEndIndex(CurrentSlotSideIndex, q);
              if ((k != APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) && (k >= q)) {
                k++;
              }
              if (m >= q) {
                m++;
              }
              if (n >= q) {
                n++;
              }
              t = pSlot->ObjPtCnt;
              for (q = t - 1; q > p; q--) {
                pSlot->CarCenterPoint[t].x = pSlot->CarCenterPoint[q].x;
                pSlot->CarCenterPoint[t].y = pSlot->CarCenterPoint[q].y;
                pSlot->DisFromCarToObj[t]  = pSlot->DisFromCarToObj[q];
                pSlot->ObjPt[t].x          = pSlot->ObjPt[q].x;
                pSlot->ObjPt[t].y          = pSlot->ObjPt[q].y;
                pSlot->CarAng[t]           = pSlot->CarAng[q];
                pSlot->bObjIsBigEnough[t]  = pSlot->bObjIsBigEnough[q];
                pSlot->CarSpeed[t]         = pSlot->CarSpeed[q];
                t--;
              }
              pSlot->ObjPtCnt++;
            } else {
              // just replace this pt.
              if (m == DeletedPtIndex[1]) {
                m--;
              }
              if (n == DeletedPtIndex[1]) {
                n++;
              }
            }
          } else {
            // just replace this pt.
            CurbIndex[ConvertedPtCnt] = DeletedPtIndex[0];
            if (DeletedPtIndex[1] == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
              // Ok. don't move.
              if (m == DeletedPtIndex[0]) {
                m--;
              }
              if (n == DeletedPtIndex[0]) {
                n++;
              }

            } else {
              // just replace this pt.
              t = DeletedPtIndex[1];
              APASlotProcDeletePointCheckSlotStartEndIndex(CurrentSlotSideIndex, t);
              if ((k != APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) && (k >= t)) {
                k--;
              }
              if (m >= t) {
                m--;
              }
              if (n >= t) {
                n--;
              }

              q = t + 1;
              for (; q < pSlot->ObjPtCnt; q++) {
                pSlot->CarCenterPoint[t].x = pSlot->CarCenterPoint[q].x;
                pSlot->CarCenterPoint[t].y = pSlot->CarCenterPoint[q].y;
                pSlot->DisFromCarToObj[t]  = pSlot->DisFromCarToObj[q];
                pSlot->ObjPt[t].x          = pSlot->ObjPt[q].x;
                pSlot->ObjPt[t].y          = pSlot->ObjPt[q].y;
                pSlot->CarAng[t]           = pSlot->CarAng[q];
                pSlot->bObjIsBigEnough[t]  = pSlot->bObjIsBigEnough[q];
                pSlot->CarSpeed[t]         = pSlot->CarSpeed[q];
                t++;
              }
              pSlot->ObjPtCnt--;
            }
          }

          t                          = CurbIndex[ConvertedPtCnt];
          pSlot->CarCenterPoint[t].x = (APA_DISTANCE_TYPE)CaledCarPos.Coordinate.x;
          pSlot->CarCenterPoint[t].y = (APA_DISTANCE_TYPE)CaledCarPos.Coordinate.y;
          pSlot->CarAng[t]           = CaledCarPos.CarAng;
          pSlot->DisFromCarToObj[t]  = CaledCarToObjDis;
          pSlot->ObjPt[t].x          = ObjPtToBeConverted.x;
          pSlot->ObjPt[t].y          = ObjPtToBeConverted.y;
          // No need to change the value of CarSpeed
          ObjIsBigEnough1            = APASlotProcCheckIfSlotObjIsBigEnough(pSlotInfo,
                                                                 // StartIndex,
                                                                 // pSlot->ObjPtCnt - 1,
                                                                 FALSE,
                                                                 t,
                                                                 APASlotObjIsBigEnoughCheckType_Obj);

          ObjIsBigEnough2 = APASlotProcCheckIfSlotObjIsBigEnough(pSlotInfo,
                                                                 // StartIndex,
                                                                 // pSlot->ObjPtCnt - 1,
                                                                 FALSE,
                                                                 t,
                                                                 APASlotObjIsBigEnoughCheckType_Curb);

          ObjIsBigEnough1 |= (ObjIsBigEnough2 << 1);
          pSlot->bObjIsBigEnough[t] = ObjIsBigEnough1;

          // Ok. keep insert the next curb point
          if ((pSlot->ObjPtCnt > (APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM - 3)) || (k < 2)) {
            // stop insert point.
            bCurbPtIsInvalid = TRUE;
            break;
          }

          pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum = CurbPtCnt;
        }
        // m = under car pos index
        // n = upper car pos index

        // j = Under Curb Pt Index
        // k = Upper curb pt index

        InsertPtIndex++;
        if (InsertPtIndex >= CurbPtCnt) {
          // Insert completed.
          return;
        }

        CalResult = 0;
        do {
          CurrentObjPtIndex0 = CurbIndex[InsertPtIndex];
          ObjPtToBeConverted = pObjPointBuf[CurrentObjPtIndex0];
          if (k == APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM) {
            // No obj2.
            // keep insert the point.
            CalResult = 1;
          } else {
            if (pSlot->ObjPt[k].y < ObjPtToBeConverted.y) {
              j = k;
              k++;
              if (pSlot->DisFromCarToObj[k] == NO_OBJ_DISTANCE) {
                // Ok. may be should still insert.
                q = pSlot->ObjPtCnt - 2;
                while (k < q) {
                  k++;
                  if (pSlot->DisFromCarToObj[k] != NO_OBJ_DISTANCE) {
                    if (pSlot->ObjPt[k].y < ObjPtToBeConverted.y) {
                      // Don't insert again.
                      return;
                    } else {
                      if (APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[j + 1], pSlot->CarCenterPoint[k]) >
                          APACal.APASlotRearSideSnsCheckCurbAsValidMinNoObjDisWidth) {
                        // Ok, regarded as valid insert point.
                        // break;
                      } else {
                        // do not insert the current point and search for next point.
                        return;
                      }
                    }
                    break;
                  }
                }

                // insert the point.
                if (k == q) {
                  k = APA_SLOT_SUPPORT_FRONT_SIDE_MAX_SAMPLE_POINT_NUM;
                }
                CalResult = 1;
              } else {
                // do not insert again.
                // stop
                return;
              }
            } else {
              p = k - 1;
              if (pSlot->DisFromCarToObj[p] == NO_OBJ_DISTANCE) {
                while (p > j) {
                  p--;
                  if (pSlot->DisFromCarToObj[p] != NO_OBJ_DISTANCE) {
                    break;
                  }
                }
                p++;
                if (APASlotProcCalTwoPtApproximateDisInt(pSlot->CarCenterPoint[j + 1], pSlot->CarCenterPoint[k]) >
                    APACal.APASlotRearSideSnsCheckCurbAsValidMinNoObjDisWidth) {
                  // Ok, regarded as valid insert point.
                  // break;
                  CalResult = 1;
                } else {
                  // do not insert the current point and search for next point.
                }
              } else {
                // don't insert the current point.
              }
            }
          }
          if ((CalResult == 1)) {
            break;
          }
          pSlotDetectecByRearSideSns->RemoveIndex = CurbIndex[InsertPtIndex] + 1;
          InsertPtIndex++;
        } while (InsertPtIndex < CurbPtCnt);

        if ((CalResult == 0)) {
          // insert completed.
          return;
        }

        ConvertedPtCnt++;

        // search the insert point car pos: m, n

        dbTemp1 = pDisFromCarToObj[CurrentObjPtIndex0];
        dbTemp2 = MATH_FABS(MATH_TAN(APACal.SnsAng[APARSideSnsIndex])) + MATH_FABS(MATH_TAN(APACal.SnsAng[APAFSnsIndex]));
        dbTemp1 *= dbTemp2;
        dbTemp1 += DeltaYBtwFAndRSns;
        dbTemp1 *= MATH_COS(pCarAngBuf[CurrentObjPtIndex0]);
        CarCenterPtY1 = pCarCenterPointBuf[CurrentObjPtIndex0].y - dbTemp1;

        q = pSlot->ObjPtCnt - 1;
        while (n < q) {
          CalResult = 0;
          for (p = 0; p < ConvertedPtCnt; p++) {
            if (n == CurbIndex[p]) {
              CalResult = 1;
              break;
            }
          }
          if (CalResult == 0) {
            if (pSlot->CarCenterPoint[n].y > CarCenterPtY1) {
              break;
            }
          }
          n++;
        }
        if (n >= q) {
          // data error.
          return;
        }
        // n is confirmed.

        Y2 = (CarCenterPtY1 - pSlot->CarCenterPoint[m].y);
        if (Y2 > APA_SLOT_REAR_SIDE_SNS_DT_CURB_PT_FIT_CAR_DRV_PATH_MIN_DIS) {
          q = m;
          while (m < n) {
            m++;
            CalResult = 0;
            for (p = 0; p < ConvertedPtCnt; p++) {
              if (m == CurbIndex[p]) {
                CalResult = 1;
                break;
              }
            }
            if (CalResult == 0) {
              Y2 = (CarCenterPtY1 - pSlot->CarCenterPoint[m].y);
              if (Y2 < APA_SLOT_REAR_SIDE_SNS_DT_CURB_PT_FIT_CAR_DRV_PATH_MIN_DIS) {
                m = q;
                break;
              }
              q = m;
            }
          }
        } else {
          while (m > 0) {
            m--;
            CalResult = 0;
            for (p = 0; p < ConvertedPtCnt; p++) {
              if (m == CurbIndex[p]) {
                CalResult = 1;
                break;
              }
            }
            if (CalResult == 0) {
              Y2 = (CarCenterPtY1 - pSlot->CarCenterPoint[m].y);
              if (Y2 > APA_SLOT_REAR_SIDE_SNS_DT_CURB_PT_FIT_CAR_DRV_PATH_MIN_DIS) {
                break;
              }
            }
          }
        }

        // m  is confirmed. under pt car pos

      } while (InsertPtIndex < CurbPtCnt);
    }
    if (bCurbPtIsInvalid == TRUE) {
      // don't insert the curb point.
      pSlotDetectecByRearSideSns->RemoveIndex                                     = CurbIndex[CurbPtCnt - 1];
      pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtNum   = 0;
      pSlotDetectecByRearSideSns->APASlotRearSideSnsCheckCurbPrevValidCurbPtSlope = APA_SLOT_OBJ_PT_SLOPE_MAX_VALUE;
      return;
    }
  } else {
    CarDriveDis = (pCarCenterPointBuf[CurrentObjPtIndex1].y - pCarCenterPointBuf[CurrentObjPtIndex2].y);
    if (CarDriveDis > APACal.APASlotRearSideSnsStartInsertObjPtToFrnSideSnsCarDrvDis) {
      // remove the previous invalid pt.
      pSlotDetectecByRearSideSns->RemoveIndex = CurrentObjPtIndex1;
    }
  }
}

#if 1 // modified by DSH 2012.2.15
// if 1 2012 05 04
// Parking out mode start
void APAPOCalculateSlotLength(void) {
  APA_DISTANCE_TYPE SnsFDtMinDis, SnsRDtMinDis, RSideSnsDis, LSideSnsDis, SlotDepth, SubSlotDepth;
  APA_DISTANCE_TYPE SlotLen, LSideSnsDis_Rear, RSideSnsDis_Rear;

  // 1.	Check if the vehicle speed is zero.
  if (bAPAVehicleIsStatic == FALSE) {
    //### Changed 2012 05 04
    // Vehicle is moving, just wait for the speed down to 0.
    APASlotProcResetSlotInfo(APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM);
    return;
  }
  // delay for at least 1 second to get a stable object.
  if (USSPar.SlotPEStartSlotCheckTimer < APACal.APASlotPESlotCheckStartDelayTime) {
    USSPar.SlotPEStartSlotCheckTimer++;
    return;
  }
  // Driver should turn on the trafic light.
  /*if((bVehicleTurningLeftFlag == FALSE)
   && (bVehicleTurningLeftFlag == FALSE)){
   APASlotProcResetSlotInfo ();
   return;
   }*/

  // 2.	Check if the gear is at park (Optional - now it is not checked).
  // 3.	Consider the objects at the front and rear.
  // Calculate the distance between the front object and the bumper.
#if 0
	APAGetFRUPASnsDtdMinDistance(&SnsFDtMinDis, &SnsRDtMinDis);
#else
#if OFILM_REVISE
//	APAGetMinSnsDtdDistance(USSPar.ParkProcSnsDtNearestDis);
#endif
#endif

  SnsFDtMinDis = USSPar.ParkProcSnsDtNearestDis[PAFrontSys].NearestDis.MidObjDis;
  if ((SnsFDtMinDis > USSPar.ParkProcSnsDtNearestDis[PAFrontSys].NearestDis.RObjDis) &&
      (USSPar.ParkProcSnsDtNearestDis[PAFrontSys].NearestDis.RObjDis < APACal.APASlotPEStartConsiderCornerObjMaxDis)) {
    // Corner object may hit the car
    SnsFDtMinDis = USSPar.ParkProcSnsDtNearestDis[PAFrontSys].NearestDis.RObjDis;
  }
  if ((SnsFDtMinDis > USSPar.ParkProcSnsDtNearestDis[PAFrontSys].NearestDis.LObjDis) &&
      (USSPar.ParkProcSnsDtNearestDis[PAFrontSys].NearestDis.LObjDis < APACal.APASlotPEStartConsiderCornerObjMaxDis)) {
    // Corner object may hit the car
    SnsFDtMinDis = USSPar.ParkProcSnsDtNearestDis[PAFrontSys].NearestDis.LObjDis;
  }

  SnsRDtMinDis = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.MidObjDis;
  if ((SnsRDtMinDis > USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.RObjDis) &&
      (USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.RObjDis < APACal.APASlotPEStartConsiderCornerObjMaxDis)) {
    // Corner object may hit the car
    SnsRDtMinDis = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.RObjDis;
  }
  if ((SnsRDtMinDis > USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.LObjDis) &&
      (USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.LObjDis < APACal.APASlotPEStartConsiderCornerObjMaxDis)) {
    // Corner object may hit the car
    SnsRDtMinDis = USSPar.ParkProcSnsDtNearestDis[PARearSys].NearestDis.LObjDis;
  }

  // For the situation 1:
  // The parking slot length is car length + distance of front + distance of rear.
  // For the situation 2:
  // The parking slot length is car length + DefaultRearObjectDisWhenNoObjectIsDetected + distance of the front.

  // 4.	Consider the object at the left and right side:
  // Save the left and right side object distance.

  APAGetSideSnsDtdDistance(&LSideSnsDis, &RSideSnsDis, &LSideSnsDis_Rear, &RSideSnsDis_Rear);

#if 1 /* DX7: Parallel Solt and Pendicular Slot shoud indicate different images if unpark failure */
  if ((LSideSnsDis < 1000) && (RSideSnsDis < 1000) && (LSideSnsDis_Rear < 1000) && (RSideSnsDis_Rear < 1000)) {
    bParkOutCarWithinPerependicularSlot = TRUE;
  } else {
    bParkOutCarWithinPerependicularSlot = FALSE;
  }
#endif

  // 5.	Check parking out side.
  // Check the left and right traffic turning light, if the car is turning right, check if the right side has object or not? If yes, set the parking
  // failure flag. If no, go to next step. Also, if the car is turning left, check if the left side has object or not? If yes, set the parking failure
  // flag. If no, go to next step.
  if (USSPar.APACarParkAtLeftOrRightSide == APA_CAR_PARK_AT_LEFT_SIDE) {
#if 1 /* DX7: also use rear side distance to charge */
    if ((RSideSnsDis_Rear < 1000) || (RSideSnsDis < APACal.APASlotPEMinParkingOutSideObjectDis))
#else
    if (RSideSnsDis < APACal.APASlotPEMinParkingOutSideObjectDis)
#endif
    {
      // Side object is too close to the car.
      APASlotProcResetSlotInfo(APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM);
      USSPar.Slot[USSPar.APARightSlotDataIndex].SlotDtFailCause = APA_SLOT_DT_FAILED_BY_SIDE_OBJECT_TOO_CLOSE;
      return;
    }
    SlotDepth    = LSideSnsDis;
    SubSlotDepth = RSideSnsDis;
  } else {
    // car is turning left.
#if 1 /* DX7: also use rear side distance to charge */
    if ((LSideSnsDis_Rear < 1000) || (LSideSnsDis < APACal.APASlotPEMinParkingOutSideObjectDis))
#else
    if (LSideSnsDis < APACal.APASlotPEMinParkingOutSideObjectDis)
#endif
    {
      // Side object is too close to the car.
      APASlotProcResetSlotInfo(APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM);
      USSPar.Slot[USSPar.APARightSlotDataIndex].SlotDtFailCause = APA_SLOT_DT_FAILED_BY_SIDE_OBJECT_TOO_CLOSE;
      return;
    }
    SlotDepth    = RSideSnsDis;
    SubSlotDepth = LSideSnsDis;
  }

  USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SubSlotDepth       = SubSlotDepth;    // left side object dis
  USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotDepth          = SlotDepth;       // right side object dis
  USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotDepthDetected1 = NO_OBJ_DISTANCE; // left side object dis
  USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotDepthDetected2 = NO_OBJ_DISTANCE; // left side object dis
  USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotDepthDetected3 = NO_OBJ_DISTANCE; // left side object dis

  // 6.	Check if the slot length is big enough.
  // If there is no object at rear,

  USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotCalDisCarToObj1 = SnsRDtMinDis; // rear object dis
  USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotCalDisCarToObj2 = SnsFDtMinDis; // front object dis.
  if (SnsFDtMinDis == NO_OBJ_DISTANCE) {
    if (APACal.APASlotPEDefaultFrontObjectDisWhenNoObjectIsDetected == 0) {
      APASlotProcResetSlotInfo(APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM);
      USSPar.Slot[USSPar.APARightSlotDataIndex].SlotDtFailCause = APA_SLOT_DT_FAILED_BY_INVALID_FRONT_OBJECT;
      return;
    }
  }

  if (SnsRDtMinDis == NO_OBJ_DISTANCE) {
    if (APACal.APASlotPEDefaultRearObjectDisWhenNoObjectIsDetected == 0) {
      APASlotProcResetSlotInfo(APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM);
      USSPar.Slot[USSPar.APARightSlotDataIndex].SlotDtFailCause = APA_SLOT_DT_FAILED_BY_INVALID_REAR_OBJECT;
      return;
    }
  }

  if (SnsRDtMinDis == NO_OBJ_DISTANCE) {
    // no object at rear.
    // If the cal RegardVeryShortDisWhenNoRearObjectDetected is set to true

    // For the situation 2:
    // The parking slot length is car length + DefaultRearObjectDisWhenNoObjectIsDetected + distance of the front.
    USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotCalDisCarToObj1 =
        APACal.APASlotPEDefaultRearObjectDisWhenNoObjectIsDetected; // rear object dis.
    if (SnsFDtMinDis == NO_OBJ_DISTANCE) {
      SlotLen = APACal.LengthOfCar + APACal.APASlotPEDefaultRearObjectDisWhenNoObjectIsDetected +
                APACal.APASlotPEDefaultFrontObjectDisWhenNoObjectIsDetected;
      USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotCalDisCarToObj2 =
          APACal.APASlotPEDefaultFrontObjectDisWhenNoObjectIsDetected; // front object dis.
    } else {
      SlotLen = APACal.LengthOfCar + APACal.APASlotPEDefaultRearObjectDisWhenNoObjectIsDetected + SnsFDtMinDis;
    }
  } else {
    // there is object at rear.	Just check if the slot is big enough.
    // For the situation 1:
    // The parking slot length is car length + distance of front + distance of rear.
    if (SnsFDtMinDis == NO_OBJ_DISTANCE) {
      SlotLen = APACal.LengthOfCar + SnsRDtMinDis + APACal.APASlotPEDefaultFrontObjectDisWhenNoObjectIsDetected;

      USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotCalDisCarToObj2 =
          APACal.APASlotPEDefaultFrontObjectDisWhenNoObjectIsDetected; // front object dis.
    } else {
      SlotLen = APACal.LengthOfCar + SnsRDtMinDis + SnsFDtMinDis;
    }
  }

  if (SlotLen > APACal.APASlotPEMinSlotLength) {
    // OK, Slot length is big enough.
    USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLengthDetected1 = SlotLen;
    USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLengthDetected2 = 0;
    USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLengthDetected3 = 0;
    USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLengthTotal     = SlotLen;
    USSPar.Slot[USSPar.APARightSlotDataIndex].SlotPar[0].SlotLength          = SlotLen;
    USSPar.Slot[USSPar.APARightSlotDataIndex].SlotNum                        = 1;
    USSPar.Slot[USSPar.APARightSlotDataIndex].SlotDtFailCause                = APA_SLOT_DT_FAILED_BY_NO_FAILURE;
  } else {
    APASlotProcResetSlotInfo(APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM);
    USSPar.Slot[USSPar.APARightSlotDataIndex].SlotDtFailCause = APA_SLOT_DT_FAILED_BY_SLOT_LENGTH_TOO_SMALL;
    return;
  }
}

// Parking out mode end

#endif

void APAGetSideSnsDtdDistance(APA_DISTANCE_TYPE *pSnsLDtMinDis,
                              APA_DISTANCE_TYPE *pSnsRDtMinDis,
                              APA_DISTANCE_TYPE *pSnsLDtMinDis_Rear,
                              APA_DISTANCE_TYPE *pSnsRDtMinDis_Rear) {
#if 1 /* DX7 */
  schar cBufIndex, cIndex, cCnt1, cCnt2, cCnt3;
  SINT16 siDis, siDis1;

  (*pSnsLDtMinDis)      = NO_OBJ_DISTANCE;
  (*pSnsRDtMinDis)      = NO_OBJ_DISTANCE;
  (*pSnsLDtMinDis_Rear) = NO_OBJ_DISTANCE;
  (*pSnsRDtMinDis_Rear) = NO_OBJ_DISTANCE;

  for (cIndex = 0; cIndex < 2; cIndex++) {
    cCnt1  = 0;
    cCnt2  = 0;
    cCnt3  = 0;
    siDis1 = NO_OBJ_DISTANCE;
    for (cBufIndex = 0; cBufIndex < 24; cBufIndex++) {
      siDis = APASideSnsDtObjDisBuf[PAFrontSys][cIndex][cBufIndex];
      if (siDis != NO_OBJ_DISTANCE) {
        cCnt1++;
        if (siDis < 3000) {
          cCnt2++;
          if (cBufIndex > 18) {
            cCnt3++;
          }
        }
      }
    }
    if (cCnt1 > 12) {
      if (cCnt2 > 6) {
        siDis1 = 2500;
      } else {
        if (cCnt3 > 3) {
          siDis1 = 2500;
        } else {
          siDis1 = 3500;
        }
      }
    }
    if (cIndex == 0) {
      if (((siDis1 == 2500) && (APASideSnsDtObjDis[PAFrontSys][0] <= siDis1)) ||
          ((siDis1 == 3500) && (APASideSnsDtObjDis[PAFrontSys][0] >= siDis1))) {
        siDis1 = APASideSnsDtObjDis[PAFrontSys][0];
      }
      (*pSnsRDtMinDis) = siDis1;
    } else {
      if (((siDis1 == 2500) && (APASideSnsDtObjDis[PAFrontSys][1] <= siDis1)) ||
          ((siDis1 == 3500) && (APASideSnsDtObjDis[PAFrontSys][1] >= siDis1))) {
        siDis1 = APASideSnsDtObjDis[PAFrontSys][1];
      }
      (*pSnsLDtMinDis) = siDis1;
    }
  }
  (*pSnsRDtMinDis_Rear) = APASideSnsDtObjDis[PARearSys][0];
  (*pSnsLDtMinDis_Rear) = APASideSnsDtObjDis[PARearSys][1];
#else
  (*pSnsLDtMinDis) = NO_OBJ_DISTANCE;
  (*pSnsRDtMinDis) = NO_OBJ_DISTANCE;

#if 1 /* DX7 */
  (*pSnsLDtMinDis_Rear) = NO_OBJ_DISTANCE;
  (*pSnsRDtMinDis_Rear) = NO_OBJ_DISTANCE;
  (*pSnsRDtMinDis_Rear) = APASideSnsDtObjDis[PARearSys][0];
  (*pSnsLDtMinDis_Rear) = APASideSnsDtObjDis[PARearSys][1];
#endif
  // here, we don't check rear side sensors.

  (*pSnsRDtMinDis) = APASideSnsDtObjDis[PAFrontSys][0];
  (*pSnsLDtMinDis) = APASideSnsDtObjDis[PAFrontSys][1];
#endif
  /*
   (*pSnsRDtMinDis) =
   USSPar.APASnsDtdObjDisInfoBuf[USSPar.APASnsDtdObjDisInfoBufWriteIndex - 1].APASnsDtdObjDis[APA_FRS_SNS_DT_OBJ_DIS_INDEX];
   (*pSnsLDtMinDis) =
   USSPar.APASnsDtdObjDisInfoBuf[USSPar.APASnsDtdObjDisInfoBufWriteIndex - 1].APASnsDtdObjDis[APA_FLS_SNS_DT_OBJ_DIS_INDEX];
   */
  /*
   // right side sns.
   if((*pSnsRDtMinDis) > (USSPar.pSnsDtDis[APA_FRS_SNS_INDEX])){
   (*pSnsRDtMinDis) = (USSPar.pSnsDtDis[APA_FRS_SNS_INDEX]);
   }
   // left side sns.
   if((*pSnsLDtMinDis) > (USSPar.pSnsDtDis[APA_FLS_SNS_INDEX])){
   (*pSnsLDtMinDis) = (USSPar.pSnsDtDis[APA_FLS_SNS_INDEX]);
   }
   */
}

/*************************************************************************************************************************************************
 ** Syntax :  BOOLEAN APASlotProcSlotMeasuringTask(void) **
 **                                                                                                                                              **
 ** Service ID:   : NA                                                                                                                           **
 **                                                                                                                                              **
 ** Sync/Async:   : Synchronous                                                                                                                  **
 **                                                                                                                                              **
 ** Reentrancy:   : Non Reentrant                                                                                                                **
 **                                                                                                                                              **
 ** Parameters (in): none                                                                                                                        **
 **                                                                                                                                              **
 ** Parameters (out): none                                                                                                                       **
 **                                                                                                                                              **
 ** Return value: none                                                                                                                           **
 **                                                                                                                                              **
 ** Description : ..                                                                                                                             **
 *************************************************************************************************************************************************/

BOOLEAN APASlotProcSlotMeasuringTask(void) {

  APA_ENUM_TYPE cSnsReadPointer, cSnsWritePointer, cProcessCnt, ObjPtCnt;
  APA_DISTANCE_TYPE APASnsDtdObjDis[APA_SIDE_SENSOR_NUM];
  APA_DISTANCE_TYPE APASnsDtdSmallObjDis[APA_SIDE_SENSOR_NUM];
  APA_SPEED_TYPE VehSpd;
  UCHAR VehSpdWhenObjPtDtd;
  APASlotObjPointType ObjPt[2];
  BOOLEAN bAPACarIsRunningBackwards;
  APA_ENUM_TYPE APAState;
  UCHAR CurrentProcessSlotIndex;
  APACarCoordinateDataCalFloatType CarCenterPt;
  static APA_ENUM_TYPE APACalObjPtSnsIndex[APA_SIDE_SENSOR_NUM];
  APA_INDEX_TYPE APASlotDataIndex[APA_SIDE_SENSOR_NUM];
  APA_INDEX_TYPE APASensorIndex[APA_SIDE_SENSOR_NUM];
  BOOLEAN bReturn, bVehicleIsStatic, bVehicleIsMoving;
  APA_INDEX_TYPE i, j, k, VehSpdIndex;
  APACarCoordinateDataType CarCenterPtTemp;
 
  bReturn = FALSE;

  // USSPar.APAState = APA_STATE_ENABLE;  /* ethan: 靎�?�喗妞介�?鎾�?�矗椤愶絽鈪电�顕嗘嫹缂嶅洭骞忛悜鑺ユ�?�闝哄�?靊栫�褰掓煥閻斿憡靝�???��椋庡厴閺佹杇�?妶靡�?�伓USS闂佽法靠愰弸濠氬�?闝垮瑔渚�煥閻斿憡靝柟�?�庡厴閺佹杇宕ｉ銉﹀涧闝归靝橀�?鎾�?��?�閵堝�?��?�堕梺璺ㄥ枑閺�??骞忔杴⌒﹂柟顑跨窔閺佹杇鎳樺靗炵�?�闝瑰嚖鎷�/

  APAState = USSPar.APAState;

  if (USSPar.APARequestToMirrorSlot == APASlotMirrorReqType_REQ) { /* ethan: APASlotMirrorReqType_REQ = 1  闂佽法靠愰弸濠氬�?缝屾�??chance for this condition */
    // USSPar.APARequestToMirrorSlot = APASlotMirrorReqType_PERMIT; // it is moved to main after apa task is exceuted.
    bReturn = TRUE;
  }

  if ((APAState == APA_STATE_OFF) || (APAState == APA_STATE_DISABLE)) {
    APASlotProcResetSlotBufAndFilterBufData(); // no-1
    APASlotDetectState = 0;                    // Off
    return FALSE;

  } else if ((USSPar.APACarParkingMode == APA_PARKPROC_PARKING_MODE_PARKEXIT)) {
    APASlotDetectState = 0; // Off
    return FALSE;
  }

   
  #if SPLITTASK
  if (u8USS_CutSteps == 1)
  {
    u8USS_CutSteps = 2;

  #endif

  if (APAObjDisUpdateFlag.Byte == u8SideSensorUpdateBackupFlag) 
  {
    // APA sensor is detecting object, and it has not finished yet.
	  return FALSE;
  } else {
    APAObjDisUpdateFlag.Byte = u8SideSensorUpdateBackupFlag;
  }

  // LeftSlotDepth = wProcessedObjBeingDtdDis_APA[1];
  // RightSlotDepth = wProcessedObjBeingDtdDis_APA[0]

  if ((APAState == APA_STATE_ACTIVE)) {
 //   APASlotProcCorrectSlotDuringParkingIn();
    APAObjDisUpdateFlag.Byte = 0;
    APASlotDetectState       = 0; // Off
    return FALSE;
  }
  APASlotCorrectionFlag.SlotCorrectionFlag                     = 0;
  APASlotCorrectionIndicationFlag.SlotCorrectionIndicationFlag = 0;
  // APAObjDisUpdateFlag.Byte = 0; /*20200424 commented by wsc */
  APACarInSlotCarMayHitObj1Or2Flag.CarInSlotCarMayHitObj1Or2Flag = 0;

  cProcessCnt = APA_MAX_SUPPORT_SNS_DTD_OBJ_DIS_BUF_SIZE;

  APACalObjPtSnsIndex[0] = APACal.APASlotRAPASnsIndex; // frs
  APACalObjPtSnsIndex[1] = APACal.APASlotLAPASnsIndex; // fls
  APACalObjPtSnsIndex[2] = APA_RRS_SNS_INDEX;          // dsh 20140723
  APACalObjPtSnsIndex[3] = APA_RLS_SNS_INDEX;          // dsh 20140723

  USSPar.APARightSlotDataIndex = 0;
  USSPar.APALeftSlotDataIndex  = 1;

  APASlotDataIndex[0] = USSPar.APARightSlotDataIndex;
  APASlotDataIndex[1] = USSPar.APALeftSlotDataIndex;
  APASlotDataIndex[2] = USSPar.APARightSlotDataIndex;
  APASlotDataIndex[3] = USSPar.APALeftSlotDataIndex;

  APASensorIndex[0] = 0;
  APASensorIndex[1] = 1;
  APASensorIndex[2] = 2;
  APASensorIndex[3] = 3;
  //	APASensorIndex [0] = USSPar.APARightSlotDataIndex;
  //	APASensorIndex [1] = USSPar.APALeftSlotDataIndex;
  //	APASensorIndex [2] = USSPar.APARightSlotDataIndex + 2;
  //	APASensorIndex [3] = USSPar.APALeftSlotDataIndex + 2;

  if (APASlotDetectState != 1) {
    USSPar.APASnsDtdObjDisInfoBufReadIndex  = 0;
    USSPar.APASnsDtdObjDisInfoBufWriteIndex = 0;
    APASlotProcResetSlotInfo(APA_SLOT_SUPPORT_SEARCHING_SLOT_SENSOR_NUM);
    APASlotProcResetSystemCoordinate();
    APASlotDetectState = 1;
    return FALSE;
  }

  // cProcessCnt =25
  while (cProcessCnt > 0) 
  {
    cProcessCnt--;

    cSnsReadPointer  = USSPar.APASnsDtdObjDisInfoBufReadIndex;
    cSnsWritePointer = USSPar.APASnsDtdObjDisInfoBufWriteIndex;

    bAPACarIsRunningBackwards = USSPar.APACommonFlags.Bits.bCarIsDrivingBackwards;
    
  CarCenterPt.Coordinate.x  = USSPar.APACarCenterPt.Coordinate.x;
  CarCenterPt.Coordinate.y  = USSPar.APACarCenterPt.Coordinate.y;
  CarCenterPt.CarAng        = USSPar.APACarCenterPt.CarAng;
  VehSpd                    = USSPar.APAVehicleSpeed;




    /*20200821 */
    CarCenterPtBackUp.Coordinate.x = CarCenterPt.Coordinate.x;
    CarCenterPtBackUp.Coordinate.y = CarCenterPt.Coordinate.y;
    CarCenterPtBackUp.CarAng = CarCenterPt.CarAng;
    
 
    bVehicleIsMoving          = bAPAVehicleIsMoving;
    bVehicleIsStatic          = bAPAVehicleIsStatic;
    

    if (cSnsReadPointer >= cSnsWritePointer) 
    {
      USSPar.APASnsDtdObjDisInfoBufReadIndex  = 0;
      USSPar.APASnsDtdObjDisInfoBufWriteIndex = 0; /*ETHAN */
      break;
    } 
    else 
    {
      /* There is sns dtd dis need to be processed */
      /*if(cSnsReadPointer >= APA_MAX_SUPPORT_SNS_DTD_OBJ_DIS_BUF_SIZE){
       cSnsReadPointer = cSnsReadPointer % APA_MAX_SUPPORT_SNS_DTD_OBJ_DIS_BUF_SIZE;
       }*/

      if ((bVehicleIsMoving == FALSE) && (bVehicleIsStatic == TRUE)) 
      {
        if (APASlotVehicleStaticTimer < APA_SLOT_VEHICLE_STATIC_MAX_TIME) 
        {
          APASlotVehicleStaticTimer++;
        }
      } 
      else 
      {
        APASlotVehicleStaticTimer = 0;
      }

      if (APASlotSnsDtdObjLoopCnt < 100) 
      {
        APASlotSnsDtdObjLoopCnt++;
      }
      APASnsDtdObjDis[APA_FRS_SNS_DT_OBJ_DIS_INDEX]      = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].APASnsDtdObjDis[0];
      APASnsDtdObjDis[APA_FLS_SNS_DT_OBJ_DIS_INDEX]      = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].APASnsDtdObjDis[1];
      // APASnsDtdSmallObjDis[APA_FRS_SNS_DT_OBJ_DIS_INDEX] = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].APASnsDtdSmallObjDis[0];
      // APASnsDtdSmallObjDis[APA_FLS_SNS_DT_OBJ_DIS_INDEX] = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].APASnsDtdSmallObjDis[1];

      // added by dsh 20140722
      APASnsDtdObjDis[APA_RRS_SNS_DT_OBJ_DIS_INDEX]      = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].APASnsDtdObjDis[2];
      APASnsDtdObjDis[APA_RLS_SNS_DT_OBJ_DIS_INDEX]      = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].APASnsDtdObjDis[3];
      // APASnsDtdSmallObjDis[APA_RRS_SNS_DT_OBJ_DIS_INDEX] = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].APASnsDtdSmallObjDis[2];
      // APASnsDtdSmallObjDis[APA_RLS_SNS_DT_OBJ_DIS_INDEX] = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].APASnsDtdSmallObjDis[3];
      // added by dsh 20140722

      if ((APASnsDtdObjDis[APA_FLS_SNS_DT_OBJ_DIS_INDEX] < APACal.APASlotFrontSideSnsCheckAsNoObjDisValue) &&
          (APASnsDtdObjDis[APA_FLS_SNS_DT_OBJ_DIS_INDEX] > -APACal.APASlotFrontSideSnsCheckAsNoObjDisValue)) 
      {
        APASnsDtdObjDis[APA_FLS_SNS_DT_OBJ_DIS_INDEX] = NO_OBJ_DISTANCE;
      }

      if ((APASnsDtdObjDis[APA_FRS_SNS_DT_OBJ_DIS_INDEX] < APACal.APASlotFrontSideSnsCheckAsNoObjDisValue) &&
          (APASnsDtdObjDis[APA_FRS_SNS_DT_OBJ_DIS_INDEX] > -APACal.APASlotFrontSideSnsCheckAsNoObjDisValue)) 
      {
        APASnsDtdObjDis[APA_FRS_SNS_DT_OBJ_DIS_INDEX] = NO_OBJ_DISTANCE;
      }

      // if (APASnsDtdSmallObjDis[APA_FLS_SNS_DT_OBJ_DIS_INDEX] < APACal.APASlotFrontSideSnsCheckAsNoObjDisValue) 
      // {
      //   APASnsDtdSmallObjDis[APA_FLS_SNS_DT_OBJ_DIS_INDEX] = NO_OBJ_DISTANCE;
      // }

      // if (APASnsDtdSmallObjDis[APA_FRS_SNS_DT_OBJ_DIS_INDEX] < APACal.APASlotFrontSideSnsCheckAsNoObjDisValue) 
      // {
      //   APASnsDtdSmallObjDis[APA_FRS_SNS_DT_OBJ_DIS_INDEX] = NO_OBJ_DISTANCE;
      // }
      // added by dsh 20140722
      if ((APASnsDtdObjDis[APA_RLS_SNS_DT_OBJ_DIS_INDEX] < APACal.APASlotRearSideSnsCheckAsNoObjDisValue) &&
          (APASnsDtdObjDis[APA_RLS_SNS_DT_OBJ_DIS_INDEX] > -APACal.APASlotRearSideSnsCheckAsNoObjDisValue)) 
      {
        APASnsDtdObjDis[APA_RLS_SNS_DT_OBJ_DIS_INDEX] = NO_OBJ_DISTANCE;
      }
      if ((APASnsDtdObjDis[APA_RRS_SNS_DT_OBJ_DIS_INDEX] < APACal.APASlotRearSideSnsCheckAsNoObjDisValue) &&
          (APASnsDtdObjDis[APA_RRS_SNS_DT_OBJ_DIS_INDEX] > -APACal.APASlotRearSideSnsCheckAsNoObjDisValue)) 
      {
        APASnsDtdObjDis[APA_RRS_SNS_DT_OBJ_DIS_INDEX] = NO_OBJ_DISTANCE;
      }
      // if (APASnsDtdSmallObjDis[APA_RLS_SNS_DT_OBJ_DIS_INDEX] < APACal.APASlotRearSideSnsCheckAsNoObjDisValue) 
      // {
      //   APASnsDtdSmallObjDis[APA_RLS_SNS_DT_OBJ_DIS_INDEX] = NO_OBJ_DISTANCE;
      // }
      // if (APASnsDtdSmallObjDis[APA_RRS_SNS_DT_OBJ_DIS_INDEX] < APACal.APASlotRearSideSnsCheckAsNoObjDisValue) 
      // {
      //   APASnsDtdSmallObjDis[APA_RRS_SNS_DT_OBJ_DIS_INDEX] = NO_OBJ_DISTANCE;
      // }
      // added by dsh 20140722
      for (i = 0; i < 4; i++) { /*20191231 */
        for (k = 0; k <= (APA_SLOT_MAX_SUPPORT_SNS_DTD_OBJ_POINT_BUF_SIZE); k++) 
        {
          if (k == 0) 
          {
            CarCenterPt.Coordinate.x = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].CarCenterPt.Coordinate.x;
            CarCenterPt.Coordinate.y = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].CarCenterPt.Coordinate.y;
            CarCenterPt.CarAng       = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].CarCenterPt.CarAng;
            VehSpdWhenObjPtDtd       = USSPar.APASnsDtdObjDisInfoBuf[cSnsReadPointer].VehicleSpd; // kph
            
            for (VehSpdIndex = 0; VehSpdIndex < (APA_SLOT_SUPPORT_OBJ_DIS_NOISE_CHECK_SPEED_DEVIDED_NUM - 1); VehSpdIndex++) 
            {
              if (VehSpdWhenObjPtDtd <= APACal.APASlotSnsDtdObjDisFilterSpeedDevidedThreshold[VehSpdIndex]) 
              {
                break;
              }
            }          
            ObjPtCnt                = APASlotProcSaveSnsDtdObjDisToFilterBuf(APASnsDtdObjDis[i],
                                                              APASnsDtdSmallObjDis[i],
                                                              APASensorIndex[i],
                                                              APACalObjPtSnsIndex[i],
                                                              &CarCenterPt,
                                                              VehSpdIndex,
                                                              ObjPt,
                                                              bAPACarIsRunningBackwards,
                                                              VehSpdWhenObjPtDtd);
          } 
          else 
          {
            if (USSPar.Slot[APASlotDataIndex[i]].SlotConfirmSeq == 0) 
            {
              // break; // note: wsc 20200407
            }
            j = APASnsDtdObjPtBuf[APASensorIndex[i]].WrIndex - APASnsDtdObjPtBuf[APASensorIndex[i]].RemovedPtIndex; // 10-5(4)
            if (j > APACal.APASlotSnsDtdObjDisFilterMinBufSize[VehSpdIndex]) 
            {

              APASlotProcGetSnsDtdObjPtFromFilterBuf(
                  &APASnsDtdObjPtBuf[APASensorIndex[i]], APASnsDtdObjPtBuf[APASensorIndex[i]].RemovedPtIndex, APACalObjPtSnsIndex[i], ObjPt);

              ObjPtCnt = 1;
              APASnsDtdObjPtBuf[APASensorIndex[i]].RemovedPtIndex++;

            } 
            else 
            {
              if (APASensorIndex[i] < 2) 
              {
                // FRS, FLS
                USSPar.Slot[APASlotDataIndex[i]].SlotConfirmSeq = 2;
              }
              break;
            }
          }
          if (i < 2) 
          {
            if (i == 0) 
            {
              j = 1;
            } 
            else 
            {
              j = 0;
            }
            if (ObjPtCnt > 0) 
            {
              APASlotProcSaveObjPointToSlotBuf(APASlotDataIndex[i], &ObjPt[0]); // , VehSpd, bAPACarIsRunningBackwards);
              APASlotProcRemoveUselessObjPtFromSlotBuffer(APASlotDataIndex[i], APASlotDataIndex[j]);   
            }      
            if (ObjPtCnt > 1) 
            {
              APASlotProcSaveObjPointToSlotBuf(APASlotDataIndex[i], &ObjPt[1]); // , VehSpd, bAPACarIsRunningBackwards);
              APASlotProcRemoveUselessObjPtFromSlotBuffer(APASlotDataIndex[i], APASlotDataIndex[j]);
            }
          } 
          else 
          {
            if (ObjPtCnt > 0) 
            {
              APASlotProcSaveObjPointToSlotBufRearSideSnsDectected(APASlotDataIndex[i], &ObjPt[0]); // , VehSpd, bAPACarIsRunningBackwards);
              APASlotProcRemoveUselessObjPtFromSlotBufferDetectedByFRSideSns(APASlotDataIndex[i], TRUE);
            }
            if (ObjPtCnt > 1) 
            {
              APASlotProcSaveObjPointToSlotBufRearSideSnsDectected(APASlotDataIndex[i], &ObjPt[1]); // , VehSpd, bAPACarIsRunningBackwards);
              APASlotProcRemoveUselessObjPtFromSlotBufferDetectedByFRSideSns(APASlotDataIndex[i], TRUE);
            }
          }
        }
      }


#ifdef SUPPORT_SDG_FUNCTION
      if (SDGState == SDG_OPERATION_MODE) {
        SDGSensorDtdObjectDisProcessTask(1);
      }
#endif
      USSPar.APASnsDtdObjDisInfoBufReadIndex++;
       
    }
  }
  #if SPLITTASK
  } /*u8USS_CutSteps = 2*/
  else if (u8USS_CutSteps == 2) {
    u8USS_CutSteps = 3;
  #endif
  // CarCenterPtTemp.Coordinate.x = USSPar.APACarCenterPt.Coordinate.x;
  // CarCenterPtTemp.Coordinate.y = USSPar.APACarCenterPt.Coordinate.y;
  // CarCenterPtTemp.CarAng       = USSPar.APACarCenterPt.CarAng;
  CarCenterPtTemp.Coordinate.x = CarCenterPtBackUp.Coordinate.x;
  CarCenterPtTemp.Coordinate.y = CarCenterPtBackUp.Coordinate.y;
  CarCenterPtTemp.CarAng       = CarCenterPtBackUp.CarAng;

  CurrentProcessSlotIndex      = USSPar.APARightSlotDataIndex;
  
  // APASlotProcCheckCurbAccodingSlotDataDetectectedByRearSideSensor(CurrentProcessSlotIndex, APACalObjPtSnsIndex[0]);
  APASlotProcCheckAndRemoveSlot(APACalObjPtSnsIndex[0], 
  								              CarCenterPtTemp, 
								                CurrentProcessSlotIndex, 
								                FALSE);
#if SPLITTASK                           
  }
  else if (u8USS_CutSteps == 3) {
    u8USS_CutSteps = 4;
#endif
  // CarCenterPtTemp.Coordinate.x = USSPar.APACarCenterPt.Coordinate.x;
  // CarCenterPtTemp.Coordinate.y = USSPar.APACarCenterPt.Coordinate.y;
  // CarCenterPtTemp.CarAng       = USSPar.APACarCenterPt.CarAng;
  CarCenterPtTemp.Coordinate.x = CarCenterPtBackUp.Coordinate.x;
  CarCenterPtTemp.Coordinate.y = CarCenterPtBackUp.Coordinate.y;
  CarCenterPtTemp.CarAng       = CarCenterPtBackUp.CarAng;
  CurrentProcessSlotIndex      = USSPar.APALeftSlotDataIndex;
  // APASlotProcCheckCurbAccodingSlotDataDetectectedByRearSideSensor(CurrentProcessSlotIndex, APACalObjPtSnsIndex[1]);
  APASlotProcCheckAndRemoveSlot(APACalObjPtSnsIndex[1], 
  								              CarCenterPtTemp, 
								                CurrentProcessSlotIndex, 
								                FALSE);
  // USSPar.of_APACarInSlotCarMayHitObj1Or2Flag = APACarInSlotCarMayHitObj1Or2Flag; // ethan:tbd
#if SPLITTASK
  } /*u8USS_CutSteps = 3*/
  else if (u8USS_CutSteps == 4)
  {
    u8USS_CutSteps = 5;
  }
#endif
  return TRUE;
}

#define ALG_STOP_SEC_CODE
#include "IS31_UserMemMap.h"
